
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>pycsamt.ff.processing.zcalculator &#8212; pyCSAMT v1.0.03 documentation</title>
    <link rel="stylesheet" href="../../../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">pyCSAMT v1.0.03 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pycsamt.ff.processing.zcalculator</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">===============================================================================</span>
<span class="sd">    Copyright Â© 2021  Kouadio K.Laurent</span>
<span class="sd">    </span>
<span class="sd">    This file is part of pyCSAMT.</span>
<span class="sd">    </span>
<span class="sd">    pyCSAMT is free software: you can redistribute it and/or modify</span>
<span class="sd">    it under the terms of the GNU Lesser General Public License as published by</span>
<span class="sd">    the Free Software Foundation, either version 3 of the License, or</span>
<span class="sd">    (at your option) any later version.</span>
<span class="sd">    </span>
<span class="sd">    pyCSAMT is distributed in the hope that it will be useful,</span>
<span class="sd">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="sd">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="sd">    GNU Lesser General Public License for more details.</span>
<span class="sd">    </span>
<span class="sd">    You should have received a copy of the GNU Lesser General Public License</span>
<span class="sd">    along with pyCSAMT.  If not, see &lt;https://www.gnu.org/licenses/&gt;.</span>

<span class="sd">===============================================================================</span>

<span class="sd">.. _module-ZCalculator::`pycsamt.ff.processing.zcalculator`</span>
<span class="sd">    :synopsis:  helper functions special calculator </span>

<span class="sd">Created on Thu Dec  3 16:44:29 2020</span>

<span class="sd">@author: @Daniel03</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">os</span><span class="o">,</span><span class="nn">warnings</span> 
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
<span class="kn">from</span> <span class="nn">pycsamt.etc</span> <span class="kn">import</span> <span class="n">infos</span>
<span class="kn">from</span> <span class="nn">pycsamt.utils</span> <span class="kn">import</span> <span class="n">exceptions</span> <span class="k">as</span> <span class="n">CSex</span>
<span class="kn">from</span> <span class="nn">pycsamt.utils</span> <span class="kn">import</span> <span class="n">func_utils</span> <span class="k">as</span> <span class="n">func</span>
<span class="kn">from</span> <span class="nn">pycsamt.utils.decorator</span> <span class="kn">import</span> <span class="n">deprecated</span><span class="p">,</span> <span class="n">redirect_cls_or_func</span>
<span class="kn">from</span> <span class="nn">pycsamt.utils._csamtpylog</span> <span class="kn">import</span> <span class="n">csamtpylog</span> 

<span class="n">_logger</span> <span class="o">=</span><span class="n">csamtpylog</span><span class="o">.</span><span class="n">get_csamtpy_logger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">scipy</span>

    <span class="n">scipy_version</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">ss</span><span class="p">)</span> <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">scipy</span><span class="o">.</span><span class="n">__version__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">scipy_version</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">scipy_version</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">14</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Note: need scipy version 0.14.0 or higher or interpolation &#39;</span>
                          <span class="s1">&#39;might not work.&#39;</span><span class="p">,</span> <span class="ne">ImportWarning</span><span class="p">)</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Note: need scipy version 0.14.0 or higher or interpolation &#39;</span>
                            <span class="s1">&#39;might not work.&#39;</span><span class="p">)</span>
    <span class="kn">import</span> <span class="nn">scipy.interpolate</span> <span class="k">as</span> <span class="nn">spi</span>

    <span class="n">interp_import</span> <span class="o">=</span> <span class="kc">True</span>

<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span> 
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Could not find scipy.interpolate, cannot use method interpolate&#39;</span>
                  <span class="s1">&#39;check installation you can get scipy from scipy.org.&#39;</span><span class="p">)</span>
    <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Could not find scipy.interpolate, cannot use method interpolate&#39;</span>
                    <span class="s1">&#39;check installation you can get scipy from scipy.org.&#39;</span><span class="p">)</span>
    <span class="n">interp_import</span> <span class="o">=</span> <span class="kc">False</span>

<span class="c1">############################# END MODULE IMPORT ############################################</span>

<span class="n">mu0</span><span class="o">=</span> <span class="mi">4</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">1e-7</span> 
<span class="n">phase_referencing</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> 

<div class="viewcode-block" id="mag_avg"><a class="viewcode-back" href="../../../../processing.html#pycsamt.ff.processing.zcalculator.mag_avg">[docs]</a><span class="k">def</span> <span class="nf">mag_avg</span> <span class="p">(</span><span class="n">mag_array</span> <span class="p">,</span> <span class="n">A_spacing</span><span class="p">,</span> <span class="n">Txcur</span><span class="p">):</span> 
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    RAW, E-, or H-field magnitude values)for each frequency</span>
<span class="sd">        units : mV/Km*</span>
<span class="sd">        </span>
<span class="sd">    :param mag_array:  magnnitude value for each data block</span>
<span class="sd">    :type mag_array: np.array (ndarray, 1),</span>

<span class="sd">    :param a_spacing: dipole length </span>
<span class="sd">    :type a_spacing: float </span>
<span class="sd">    </span>
<span class="sd">    :param txcur:  curv coil, transmitter length </span>
<span class="sd">    :type txcurv: float</span>

<span class="sd">    :returns: averaged data of magnitude data Block</span>
<span class="sd">    :rtype mag_avg: np.ndarray </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">mag_array</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span> <span class="p">:</span> 
        <span class="n">mag_avg</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mag_array</span><span class="p">)</span> 
    <span class="k">try</span> <span class="p">:</span> 
        <span class="n">mag_avg</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">mag_array</span><span class="p">])</span>
    <span class="k">except</span> <span class="p">:</span> 
        <span class="k">raise</span> <span class="n">CSex</span><span class="o">.</span><span class="n">pyCSAMTError_inputarguments</span><span class="p">(</span><span class="s2">&quot;Input first arguments is wrong. must&quot;</span>\
                                               <span class="s2">&quot;be a list of ndarray of numbers.&quot;</span><span class="p">)</span>
        
    <span class="n">mag_avg</span> <span class="o">=</span><span class="n">mag_array</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">En</span> <span class="o">=</span><span class="n">mag_avg</span> <span class="o">/</span><span class="p">(</span><span class="n">A_spacing</span> <span class="o">*</span>  <span class="n">Txcur</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">mag_avg</span><span class="p">,</span> <span class="n">En</span> </div>


<div class="viewcode-block" id="phz_avg"><a class="viewcode-back" href="../../../../processing.html#pycsamt.ff.processing.zcalculator.phz_avg">[docs]</a><span class="k">def</span> <span class="nf">phz_avg</span> <span class="p">(</span><span class="n">phz_array</span><span class="p">,</span> <span class="n">to_degree</span><span class="p">):</span> 
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    E-, H-field, or Impedance Phase values unit in  mrad</span>
<span class="sd">    </span>
<span class="sd">    :param phz_array: array of phase values in mrad </span>
<span class="sd">    :type phz_array: array_like </span>
<span class="sd">    </span>
<span class="sd">    :param to_degree: ascertain convertion to degree </span>
<span class="sd">    :type to_degree: bool </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span> <span class="p">(</span><span class="n">phz_array</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span> <span class="p">:</span> 
        <span class="n">phz_array</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">phz_array</span><span class="p">)</span>
        
    <span class="k">try</span> <span class="p">:</span> 
        <span class="n">phz_array</span> <span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">kk</span><span class="p">)</span> <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">phz_array</span> <span class="p">]</span>
    <span class="k">except</span> <span class="p">:</span> 
        <span class="k">raise</span> <span class="n">CSex</span><span class="o">.</span><span class="n">pyCSAMTError_inputarguments</span><span class="p">(</span><span class="s2">&quot;input argument must be a number in array or list.&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">to_degree</span> <span class="p">:</span> <span class="k">return</span> <span class="p">(</span><span class="n">phz_array</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">/</span><span class="mf">1e3</span><span class="p">)</span> <span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="p">(</span><span class="n">phz_array</span><span class="o">/</span><span class="mi">1000</span><span class="p">)</span> <span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    
    <span class="k">return</span> <span class="n">phz_array</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span></div>
    
<div class="viewcode-block" id="param_rho"><a class="viewcode-back" href="../../../../processing.html#pycsamt.ff.processing.zcalculator.param_rho">[docs]</a><span class="k">def</span> <span class="nf">param_rho</span> <span class="p">(</span><span class="n">rho_array</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameter Average RHO (RHOp), RHO are from each data block, unit ( ohm.m)</span>
<span class="sd">    </span>
<span class="sd">    :param rho_array: array of resistivity values </span>
<span class="sd">    :type rho_array: array_like </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">rho_array</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span> <span class="p">:</span> <span class="n">rho_array</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rho_array</span><span class="p">)</span>
    <span class="k">try</span> <span class="p">:</span> 
        <span class="n">phz_array</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">kk</span><span class="p">)</span> <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">rho_array</span> <span class="p">])</span>
    <span class="k">except</span> <span class="p">:</span> 
        <span class="k">raise</span> <span class="n">CSex</span><span class="o">.</span><span class="n">pyCSAMTError_inputarguments</span><span class="p">(</span><span class="s1">&#39;Error inputs arguments . must be list or&#39;</span>\
                                               <span class="s1">&#39;ndarray of numbers.&#39;</span><span class="p">)</span>
    <span class="k">return</span>  <span class="n">phz_array</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span></div>

<div class="viewcode-block" id="param_phz"><a class="viewcode-back" href="../../../../processing.html#pycsamt.ff.processing.zcalculator.param_phz">[docs]</a><span class="k">def</span> <span class="nf">param_phz</span> <span class="p">(</span><span class="n">pphz_array</span><span class="p">,</span> <span class="n">to_degree</span> <span class="o">=</span><span class="kc">False</span><span class="p">):</span> 
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    PHZn are from each data block ,  units in  mrad </span>
<span class="sd">       </span>
<span class="sd">    :param pphz_array: average parameters phase for data blocs.</span>
<span class="sd">    :type pphz_array: array_like</span>
<span class="sd">    </span>
<span class="sd">    :param to_degree: ascertain convertion to degree </span>
<span class="sd">    :type to_degree: bool </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">pphz_array</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span> <span class="p">:</span> <span class="n">pphz_array</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pphz_array</span><span class="p">)</span>
    <span class="k">try</span> <span class="p">:</span> 
        <span class="n">pphz_array</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">kk</span><span class="p">)</span> <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">pphz_array</span> <span class="p">])</span>
    <span class="k">except</span> <span class="p">:</span> 
        <span class="k">raise</span> <span class="n">CSex</span><span class="o">.</span><span class="n">pyCSAMTError_inputarguments</span><span class="p">(</span><span class="s1">&#39;Error inputs arguments. must be list or&#39;</span>\
                                               <span class="s1">&#39;ndarray of numbers.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">to_degree</span> <span class="p">:</span> <span class="k">return</span> <span class="p">(</span><span class="n">pphz_array</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">/</span><span class="mi">1000</span><span class="p">)</span> <span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="p">(</span><span class="n">pphz_array</span><span class="o">/</span><span class="mi">1000</span><span class="p">)</span> <span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    
    <span class="k">return</span>  <span class="n">pphz_array</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span></div>

<div class="viewcode-block" id="comp_rho"><a class="viewcode-back" href="../../../../processing.html#pycsamt.ff.processing.zcalculator.comp_rho">[docs]</a><span class="k">def</span> <span class="nf">comp_rho</span> <span class="p">(</span><span class="n">mag_E_field</span><span class="p">,</span> <span class="n">mag_H_field</span><span class="p">,</span> <span class="n">freq_array</span><span class="p">,</span> <span class="n">A_spacing</span><span class="p">,</span> <span class="n">Txcurr</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to compute component average </span>
<span class="sd">    unit in in ohm.m </span>

<span class="sd">    :param mag_E_field: magnitude of E-filed , averaged </span>
<span class="sd">    :type mag_E_field: np.ndarray(ndarray,1)</span>
<span class="sd">  </span>
<span class="sd">    :param mag_H_field: magnitude of H-Field ,  averaged </span>
<span class="sd">    :type mag_H_field: np.ndarray(ndarray,1)</span>
<span class="sd">    </span>
<span class="sd">    :param freq_array:  frequency of station field</span>
<span class="sd">    :type freq_array: np.ndarray(ndarray,1)</span>
<span class="sd">    </span>
<span class="sd">    :param  A_spacing: step_between station</span>
<span class="sd">    :type A_spacing: np.float</span>
<span class="sd">    </span>
<span class="sd">    :param Txcurr:  distance of coil in meter </span>
<span class="sd">    :type Txcurr: np.float,</span>

<span class="sd">    :returns: comp_rho , component averaged rho.</span>
<span class="sd">    :rtype: np.ndarray </span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span><span class="p">[</span><span class="n">mag_E_field</span><span class="p">,</span> <span class="n">mag_H_field</span><span class="p">,</span> <span class="n">freq_array</span><span class="p">,</span> <span class="n">A_spacing</span><span class="p">,</span> <span class="n">Txcurr</span><span class="p">]</span>
    
    <span class="k">for</span> <span class="n">a_args</span> <span class="ow">in</span> <span class="n">args</span> <span class="p">:</span> 
        <span class="k">if</span> <span class="nb">type</span> <span class="p">(</span><span class="n">a_args</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="p">:</span>
            <span class="k">try</span> <span class="p">:</span>
                <span class="n">a_args</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="nb">float</span><span class="p">(</span><span class="n">ss</span><span class="p">)</span> <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">a_args</span> <span class="p">])</span>
            <span class="k">except</span> <span class="p">:</span> 
                <span class="k">raise</span> <span class="n">CSex</span><span class="o">.</span><span class="n">pyCSAMTError_inputarguments</span><span class="p">(</span><span class="s2">&quot;Elemts composed of each array must be a number.&quot;</span><span class="p">)</span>
        
    <span class="c1"># if comp_rho.__code__.co_argcount ==5 : </span>
    <span class="c1">#     if mag_E_field.ndim !=1 or  mag_H_field.ndim !=1 or freq_array.ndim !=1 : </span>
    <span class="c1">#         raise CSex.pyCSAMTError_inputarguments (&quot;dimension of Input arguments must me equal to 1.&quot;)</span>
    
    <span class="n">Emag</span> <span class="o">=</span><span class="n">mag_E_field</span> <span class="o">/</span><span class="p">(</span><span class="n">A_spacing</span> <span class="o">*</span> <span class="n">Txcurr</span><span class="p">)</span>
    <span class="n">Hmag</span> <span class="o">=</span><span class="n">mag_H_field</span> <span class="o">/</span><span class="n">Txcurr</span> 
    <span class="n">comp_rho</span> <span class="o">=</span><span class="p">(</span><span class="n">Emag</span><span class="o">/</span><span class="n">Hmag</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">5</span><span class="o">*</span><span class="n">freq_array</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">comp_rho</span></div>

<div class="viewcode-block" id="comp_phz"><a class="viewcode-back" href="../../../../processing.html#pycsamt.ff.processing.zcalculator.comp_phz">[docs]</a><span class="k">def</span> <span class="nf">comp_phz</span> <span class="p">(</span><span class="n">comphz_array</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span><span class="s1">&#39;deg&#39;</span><span class="p">):</span>
    
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    PHZc are from each data block, units in rad </span>

<span class="sd">    :param comphz_array: average parameters phase for data blocs.</span>
<span class="sd">    :type comphz_array: float </span>
<span class="sd">    </span>
<span class="sd">    :returns: component phase averaged.</span>
<span class="sd">    :rtype: component phase averaged.</span>
<span class="sd">    </span>
<span class="sd">    :Example:</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; path =  os.path.join(os.environ[&quot;pyCSAMT&quot;], </span>
<span class="sd">        ...              &#39;csamtpy&#39;,&#39;data&#39;, &#39;K1.AVG&#39;)</span>
<span class="sd">        &gt;&gt;&gt; from pycsamt.core import avg  </span>
<span class="sd">        &gt;&gt;&gt; phs_obj =avg.Phase(path)</span>
<span class="sd">        &gt;&gt;&gt; phs_obj.loc[&#39;S00&#39;]</span>
<span class="sd">        &gt;&gt;&gt; value, ss = comp_phz(comphz_array=phs_obj.loc[</span>
<span class="sd">        ...            &#39;S00&#39;], to_degree=True)</span>
<span class="sd">        ... print(value)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">comphz_array</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span> <span class="p">:</span> <span class="n">comphz_array</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">comphz_array</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">comphz_array</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;float&quot;</span><span class="p">,</span> <span class="s2">&quot;int&quot;</span><span class="p">]</span> <span class="p">:</span> 
        <span class="k">raise</span> <span class="n">CSex</span><span class="o">.</span><span class="n">pyCSAMTError_inputarguments</span><span class="p">(</span><span class="s2">&quot;Type provided is wrong ! number must be float&quot;</span><span class="p">)</span>  

    <span class="k">try</span> <span class="p">:</span> 
        <span class="n">comphz_array</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">kk</span><span class="p">)</span> <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">comphz_array</span> <span class="p">])</span>
    <span class="k">except</span> <span class="p">:</span> 
        <span class="k">raise</span> <span class="n">CSex</span><span class="o">.</span><span class="n">pyCSAMTError_inputarguments</span><span class="p">(</span><span class="s1">&#39;Error inputs arguments. must be list or&#39;</span>\
                                               <span class="s1">&#39;ndarray of numbers.&#39;</span><span class="p">)</span>
    
            
    <span class="k">if</span> <span class="n">units</span> <span class="o">==</span><span class="s1">&#39;deg&#39;</span> <span class="p">:</span> <span class="k">return</span> <span class="n">comphz_array</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">comphz_array</span> <span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    
    <span class="k">return</span>  <span class="n">comphz_array</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span></div>


<div class="viewcode-block" id="compute_components_Z_Phz"><a class="viewcode-back" href="../../../../processing.html#pycsamt.ff.processing.zcalculator.compute_components_Z_Phz">[docs]</a><span class="k">def</span> <span class="nf">compute_components_Z_Phz</span><span class="p">(</span><span class="n">magn_E_field</span> <span class="p">,</span> <span class="n">magn_H_field</span><span class="p">,</span> <span class="n">phz_E_field</span><span class="p">,</span>
               <span class="n">phz_H_field</span><span class="p">,</span> <span class="n">freq_value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to compute all components  derived from Impedance Z. </span>
<span class="sd">    user can  enter specifik units in kwargs arguments . program will compute and converts value </span>
<span class="sd">    automatically.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        * magn_E_field : np.ndarray </span>
<span class="sd">            E_.field magnitude (ndarray,1) in  microV/KM*A</span>
<span class="sd">            </span>
<span class="sd">        * magn_H_field : np.ndarray </span>
<span class="sd">             H_.field magnitude (ndarray,1)in  mGammas/A or picoTesla/A</span>
<span class="sd">             </span>
<span class="sd">        * phz_E_field : np.ndarray </span>
<span class="sd">            E_field phase (ndarray, 1) in  mrad </span>
<span class="sd">            </span>
<span class="sd">        * phz_H_field : np.ndarray </span>
<span class="sd">             H_field phase (ndarray,1) in  mrad.</span>
<span class="sd">             </span>
<span class="sd">        * freq_value : np.ndarray </span>
<span class="sd">             Frequency at which data was measured(ndarray,1)in  Hz</span>
<span class="sd">             </span>
<span class="sd">        * kwargs : str </span>
<span class="sd">             units conversion.</span>
<span class="sd">        </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">        CSex.pyCSAMTError_z(), </span>
<span class="sd">            Exceptions if units entered by the user doesnt match or are messy.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        rho: ndarray </span>
<span class="sd">            Cagnard resistivity calculation. ohm.m </span>
<span class="sd">        phz: ndarray </span>
<span class="sd">             Impedance phase value.</span>
<span class="sd">        Zij: ndarray  </span>
<span class="sd">             Impedance Tensor value.</span>
<span class="sd">        Zreal: ndarray </span>
<span class="sd">            Value of Real part of impedance Tensor.</span>
<span class="sd">        Zimag: float</span>
<span class="sd">             Value of Imaginary part of impedance Tensor.</span>
<span class="sd">        Zreal_imag: ndarray , complex </span>
<span class="sd">            Complex value of impedance Tensor.</span>
<span class="sd">         </span>
<span class="sd">    :Example: </span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; from pycsamt.core import avg </span>
<span class="sd">        &gt;&gt;&gt; path =  os.path.join(os.environ[&quot;pyCSAMT&quot;], </span>
<span class="sd">        ...              data&#39;, &#39;avg&#39;, &#39;K1.AVG&#39;)</span>
<span class="sd">        &gt;&gt;&gt; emag_ob = avg.Emag(path)</span>
<span class="sd">        &gt;&gt;&gt; hmag_obj = avg.Hmag(path)</span>
<span class="sd">        &gt;&gt;&gt; ephz_obj = avg.Ephz(path)</span>
<span class="sd">        &gt;&gt;&gt; hphz_obj = avg.Hphz(path)</span>
<span class="sd">        &gt;&gt;&gt; freq_obj =avg.Frequency(path)</span>
<span class="sd">        &gt;&gt;&gt; station_name =&#39;S00&#39;</span>
<span class="sd">        &gt;&gt;&gt; rho, phz, Z, real, imag, comp =compute_components_Z_Phz( </span>
<span class="sd">        ...    magn_E_field=emag_ob.loc[station_name], </span>
<span class="sd">        ...                            magn_H_field =hmag_obj.loc[station_name], </span>
<span class="sd">        ...                            phz_E_field =ephz_obj.loc[station_name], </span>
<span class="sd">        ...                            phz_H_field=hphz_obj.loc[station_name], </span>
<span class="sd">        ...                            freq_value=freq_obj.loc[station_name])</span>
<span class="sd">        ... rho</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">units_E_field</span> <span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;unit_E_field&#39;</span><span class="p">,</span> <span class="s1">&#39;microV/km*A&#39;</span><span class="p">)</span>
    <span class="n">units_H_field</span> <span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;unit_E_field&#39;</span><span class="p">,</span> <span class="s1">&#39;mGamma/A&#39;</span><span class="p">)</span>
    <span class="n">unit_phz</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;unit_phase&#39;</span><span class="p">,</span> <span class="s1">&#39;mrad&#39;</span><span class="p">)</span>
    <span class="n">unit_freq</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;unit&#39;</span><span class="p">,</span> <span class="s1">&#39;Hz&#39;</span><span class="p">)</span>
    
    <span class="c1">#units converter</span>
    <span class="n">units</span> <span class="o">=</span><span class="p">{</span><span class="n">units_E_field</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;microv/km*a&#39;</span><span class="p">:</span><span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span>
                            <span class="s1">&#39;nv/ma&#39;</span><span class="p">:</span><span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span>
                           <span class="s1">&#39;mmv/km*a&#39;</span><span class="p">:</span><span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span>
                           <span class="s1">&#39;v/km*a&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
                   <span class="p">},</span>               <span class="c1"># SI : --&gt; E-Field  V/KM*A</span>
            <span class="n">units_H_field</span> <span class="p">:</span> <span class="p">{</span><span class="s1">&#39;mgamma/a&#39;</span><span class="p">:</span><span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span>
                             <span class="s1">&#39;pt/a&#39;</span><span class="p">:</span><span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span>
                            <span class="s1">&#39;picotesla/a&#39;</span><span class="p">:</span><span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span>
                            <span class="s1">&#39;gamma/km*a&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
                   <span class="p">},</span> <span class="c1">#SI : --&gt; KGamma/A or microTesla/A </span>
            <span class="n">unit_phz</span><span class="p">:{</span><span class="s1">&#39;rad&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> 
                      <span class="s1">&#39;mrad&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span>
                      <span class="s1">&#39;deg&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span>
                  <span class="p">},</span>        <span class="c1"># S.I : angle  on radians </span>
            <span class="n">unit_freq</span><span class="p">:{</span><span class="s2">&quot;hz&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> 
                         <span class="s1">&#39;rad/s&#39;</span><span class="p">:</span> <span class="mf">0.1592</span><span class="p">,</span>
                         <span class="s1">&#39;mrad/s&#39;</span><span class="p">:</span><span class="mf">0.1592</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">3</span><span class="p">)}</span> <span class="c1"># on Hz </span>
            <span class="p">}</span>
    <span class="c1">#check units </span>
    <span class="k">for</span> <span class="n">keys</span> <span class="p">,</span><span class="n">values</span> <span class="ow">in</span> <span class="n">units</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">keys</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="n">units_E_field</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">keys</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">values</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">magn_E_field</span> <span class="o">=</span> <span class="n">magn_E_field</span> <span class="o">*</span> <span class="n">values</span><span class="p">[</span><span class="n">keys</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
            <span class="k">else</span> <span class="p">:</span> 
                <span class="k">raise</span> <span class="n">CSex</span><span class="o">.</span><span class="n">pyCSAMTError_Emag</span><span class="p">(</span><span class="s2">&quot;Input units is not valid. try : </span><span class="si">{0}</span><span class="s2">&quot;</span>\
                                                     <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>
        <span class="k">if</span> <span class="n">keys</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span><span class="n">units_H_field</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="p">:</span> 
            <span class="k">if</span> <span class="n">keys</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">values</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">magn_H_field</span><span class="o">=</span> <span class="n">magn_H_field</span><span class="o">*</span> <span class="n">values</span><span class="p">[</span><span class="n">keys</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
            <span class="k">else</span> <span class="p">:</span> 
                <span class="k">raise</span> <span class="n">CSex</span><span class="o">.</span><span class="n">pyCSAMTError_Emag</span><span class="p">(</span><span class="s2">&quot;Input units is not valid. try : </span><span class="si">{0}</span><span class="s2">&quot;</span>\
                                                 <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span> 
                    
        <span class="k">if</span> <span class="n">keys</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span><span class="n">unit_phz</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span> 
            <span class="k">if</span> <span class="n">keys</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">values</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                
                <span class="n">phz_E_field</span> <span class="o">=</span> <span class="n">phz_E_field</span><span class="o">*</span> <span class="n">values</span><span class="p">[</span><span class="n">keys</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
                <span class="n">phz_H_field</span> <span class="o">=</span> <span class="n">phz_H_field</span>  <span class="o">*</span> <span class="n">values</span><span class="p">[</span><span class="n">keys</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
            <span class="k">else</span> <span class="p">:</span> 
                <span class="k">raise</span> <span class="n">CSex</span><span class="o">.</span><span class="n">pyCSAMTError_Emag</span><span class="p">(</span><span class="s2">&quot;Input units is not valid. try : </span><span class="si">{0}</span><span class="s2">&quot;</span>\
                                                 <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span> 
        <span class="k">if</span> <span class="n">keys</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span><span class="n">unit_freq</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span> 
            <span class="k">if</span> <span class="n">keys</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">values</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">freq_value</span><span class="o">=</span> <span class="n">freq_value</span> <span class="o">*</span> <span class="n">values</span><span class="p">[</span><span class="n">keys</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
            <span class="k">else</span> <span class="p">:</span> 
                <span class="k">raise</span> <span class="n">CSex</span><span class="o">.</span><span class="n">pyCSAMTError_Emag</span><span class="p">(</span><span class="s2">&quot;Input units is not valid. try : </span><span class="si">{0}</span><span class="s2">&quot;</span>\
                                                 <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span> 
        
    <span class="c1">#--&gt; component real part and imag </span>
    <span class="n">Zij</span> <span class="o">=</span><span class="n">magn_E_field</span> <span class="o">/</span><span class="n">magn_H_field</span>
    <span class="n">phz</span><span class="o">=</span><span class="n">phz_E_field</span> <span class="o">-</span> <span class="n">phz_H_field</span>
    <span class="n">Zreal</span><span class="p">,</span> <span class="n">Zimag</span>  <span class="o">=</span><span class="n">Zij</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phz</span><span class="p">),</span> <span class="n">Zij</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phz</span><span class="p">)</span>
    <span class="c1"># Zreal_imag= np.complex(real=Zreal, imag=Zimag)</span>
    <span class="n">Zreal_imag</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">(</span><span class="n">real</span><span class="o">=</span><span class="n">Zreal</span> <span class="p">,</span> <span class="n">imag</span><span class="o">=</span><span class="n">Zimag</span><span class="p">)</span> 
    <span class="n">rho</span> <span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="n">freq_value</span><span class="p">))</span><span class="o">*</span> <span class="n">Zij</span><span class="o">**</span><span class="mi">2</span>
    
    <span class="k">return</span> <span class="n">rho</span> <span class="p">,</span> <span class="n">phz</span><span class="p">,</span>  <span class="n">Zij</span><span class="p">,</span> <span class="n">Zreal</span><span class="p">,</span> <span class="n">Zimag</span><span class="p">,</span> <span class="n">Zreal_imag</span></div>


<div class="viewcode-block" id="z_error2r_phi_error"><a class="viewcode-back" href="../../../../processing.html#pycsamt.ff.processing.zcalculator.z_error2r_phi_error">[docs]</a><span class="k">def</span> <span class="nf">z_error2r_phi_error</span><span class="p">(</span><span class="n">z_real</span><span class="p">,</span> <span class="n">z_imag</span><span class="p">,</span> <span class="n">error</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Error estimation from rectangular to polar coordinates.</span>
<span class="sd">    By standard error propagation, relative error in resistivity is </span>
<span class="sd">    2*relative error in z amplitude. </span>
<span class="sd">    Uncertainty in phase (in degrees) is computed by defining a circle around </span>
<span class="sd">    the z vector in the complex plane. The uncertainty is the absolute angle</span>
<span class="sd">    between the vector to (x,y) and the vector between the origin and the</span>
<span class="sd">    tangent to the circle.</span>
<span class="sd"> </span>
<span class="sd">    :param z_real: real component of z (real number or array)</span>
<span class="sd">    :type z_real: float </span>
<span class="sd">    </span>
<span class="sd">    :param z_imag:  imaginary component of z (real number or array)</span>
<span class="sd">    :type z_imag: complex</span>
<span class="sd">    </span>
<span class="sd">    :param error: absolute error in z (real number or array)</span>
<span class="sd">    :type error: float</span>
<span class="sd">    </span>
<span class="sd">    :returns: containers of relative error in resistivity, absolute error in phase</span>
<span class="sd">    :rtupe: tuple</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
        
    <span class="n">z_amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z_real</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">z_imag</span><span class="p">)</span>

    <span class="n">z_rel_err</span> <span class="o">=</span> <span class="n">error</span><span class="o">/</span><span class="n">z_amp</span>
    
    <span class="n">res_rel_err</span> <span class="o">=</span> <span class="mf">2.</span><span class="o">*</span><span class="n">z_rel_err</span>
    
    <span class="c1">#if the relative error of the amplitude is &gt;=100% that means that the relative </span>
    <span class="c1">#error of the resistivity is 200% - that is then equivalent to an uncertainty </span>
    <span class="c1">#in the phase angle of 90 degrees:</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">z_real</span><span class="p">):</span>
        <span class="n">phi_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">z_rel_err</span><span class="p">))</span>   
        <span class="n">phi_err</span><span class="p">[</span><span class="n">res_rel_err</span> <span class="o">&gt;</span> <span class="mf">1.</span><span class="p">]</span> <span class="o">=</span> <span class="mf">90.</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">res_rel_err</span> <span class="o">&gt;</span> <span class="mf">1.</span><span class="p">:</span>
            <span class="n">phi_err</span> <span class="o">=</span> <span class="mi">90</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">phi_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">z_rel_err</span><span class="p">))</span>    
    
    
    <span class="k">return</span> <span class="n">res_rel_err</span><span class="p">,</span> <span class="n">phi_err</span></div>

<div class="viewcode-block" id="rhophi2z"><a class="viewcode-back" href="../../../../processing.html#pycsamt.ff.processing.zcalculator.rhophi2z">[docs]</a><span class="k">def</span> <span class="nf">rhophi2z</span> <span class="p">(</span> <span class="n">phase</span><span class="p">,</span> <span class="n">freq</span> <span class="p">,</span> <span class="n">resistivity</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="n">z_array</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to compute z , real part and imag part . </span>

<span class="sd">    :param phase: phase angles array in radians</span>
<span class="sd">    :type phase: ndarray </span>
<span class="sd">     </span>
<span class="sd">    :param freq: frequencies array in Hz</span>
<span class="sd">    :type freq: array_like</span>
<span class="sd">    </span>
<span class="sd">    :param resistivity:  rho array in ohm.m</span>
<span class="sd">    :type resistivity: array_like</span>
<span class="sd">    </span>
<span class="sd">    :param z_array: impedance z array in V/m </span>
<span class="sd">    :type z_array: array_like </span>

<span class="sd">    :returns: z_abs , absolute value of zz</span>
<span class="sd">    :rtype: float </span>
<span class="sd">    </span>
<span class="sd">    :returns: z_real, real part of complex number</span>
<span class="sd">    :rtype: float </span>
<span class="sd">    </span>
<span class="sd">    :returns: z_imag, imaginary part of zz</span>
<span class="sd">    :rtype: complex </span>
<span class="sd">    </span>
<span class="sd">    :returns: ndarray </span>
<span class="sd">    :rtype: zz, array of z_abs, z_imag, z_real </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">phase</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="p">:</span>
        <span class="n">phase</span><span class="p">,</span> <span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">phase</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">phase</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="s1">&#39;int&#39;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">freq</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="s1">&#39;int&#39;</span><span class="p">]:</span>
        <span class="k">try</span> <span class="p">:</span> 
            <span class="n">phase</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">ss</span><span class="p">)</span> <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">phase</span> <span class="p">])</span>
            <span class="n">freq</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">freq</span> <span class="p">])</span>
        <span class="k">except</span> <span class="p">:</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;must be flost number of integer . not str !&#39;</span><span class="p">)</span>
    
    <span class="k">try</span> <span class="p">:</span>    
        <span class="k">if</span> <span class="n">resistivity</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="p">:</span> <span class="n">resistivity</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">resistivity</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">z_array</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="p">:</span> <span class="n">z_array</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">z_array</span><span class="p">])</span>
    <span class="k">except</span> <span class="p">:</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Arguments number must be float or int&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">freq</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">phase</span><span class="o">.</span><span class="n">size</span> <span class="ow">and</span> <span class="p">(</span><span class="n">phase</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">resistivity</span><span class="o">.</span><span class="n">size</span> <span class="ow">or</span> <span class="n">phase</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">z_array</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
        <span class="k">raise</span> <span class="s1">&#39;Arrays nust get the same size.&#39;</span>
    
    
    <span class="k">if</span> <span class="n">resistivity</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="p">:</span> <span class="n">z_abs</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.2</span> <span class="o">*</span> <span class="n">freq</span> <span class="o">*</span> <span class="n">resistivity</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">resistivity</span> <span class="ow">is</span>  <span class="kc">None</span> <span class="ow">and</span> <span class="n">z_array</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="p">:</span> <span class="n">z_abs</span> <span class="o">=</span> <span class="n">z_array</span> 
    
    
    <span class="n">z_real</span><span class="p">,</span> <span class="n">z_imag</span>  <span class="o">=</span> <span class="n">z_abs</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span> <span class="p">(</span><span class="n">phase</span><span class="p">),</span> <span class="n">z_abs</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phase</span><span class="p">)</span>
    <span class="c1"># zz =np.complex(z_real , z_imag)</span>
    <span class="n">zz</span><span class="o">=</span><span class="n">z_real</span> <span class="o">+</span> <span class="n">z_imag</span> <span class="o">*</span><span class="mi">1</span><span class="n">j</span>
    
    <span class="k">return</span> <span class="n">z_abs</span><span class="p">,</span> <span class="n">z_real</span><span class="p">,</span> <span class="n">z_imag</span> <span class="p">,</span><span class="n">zz</span></div>


<div class="viewcode-block" id="get_reffreq_index"><a class="viewcode-back" href="../../../../processing.html#pycsamt.ff.processing.zcalculator.get_reffreq_index">[docs]</a><span class="k">def</span> <span class="nf">get_reffreq_index</span><span class="p">(</span><span class="n">freq_array</span><span class="p">,</span> <span class="n">reffreq_value</span><span class="p">):</span> 
    <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Get the index of reference index. From this index ,All array will filter data at this reffreq</span>
<span class="sd">    value . </span>
<span class="sd">    :param freq_array: array of frequency values</span>
<span class="sd">    :type freq_array: array_like </span>
<span class="sd">    </span>
<span class="sd">    :param reffreq_value:  value of frequency at clean data </span>
<span class="sd">    :type reffreq_value: float, int </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">freq_array</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">ss</span><span class="p">)</span> <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">freq_array</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">reffreq_value</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">freq_array</span> <span class="p">:</span> 
        <span class="k">raise</span> <span class="n">CSex</span><span class="o">.</span><span class="n">pyCSAMTError_frequency</span><span class="p">(</span><span class="s1">&#39;Reference frequency must be a value of frequency array.&#39;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">freq_array</span><span class="p">):</span> 
        <span class="k">if</span> <span class="n">freq</span> <span class="o">==</span> <span class="n">reffreq_value</span><span class="p">:</span>
            <span class="n">index_rf</span> <span class="o">=</span> <span class="n">ii</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">index_rf</span></div>

<div class="viewcode-block" id="interpolate_sets"><a class="viewcode-back" href="../../../../processing.html#pycsamt.ff.processing.zcalculator.interpolate_sets">[docs]</a><span class="k">def</span> <span class="nf">interpolate_sets</span> <span class="p">(</span><span class="n">array_to</span><span class="p">,</span> <span class="n">fill_value</span> <span class="o">=</span><span class="kc">None</span> <span class="p">,</span> <span class="n">array_size</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to interpolate data contain of multiple nan values. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">array_size</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span> <span class="n">array_size</span> <span class="o">==</span> <span class="n">array_to</span><span class="o">.</span><span class="n">size</span> 
    
    <span class="n">xx_array_to</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">array_size</span><span class="p">)</span>
    
    <span class="n">ff</span> <span class="o">=</span> <span class="n">spi</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">xx_array_to</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">array_to</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>
    <span class="c1"># new_array = ff(xx_array_to)</span>
    <span class="k">return</span> <span class="n">ff</span><span class="p">(</span><span class="n">xx_array_to</span><span class="p">)</span></div>

<span class="k">def</span>  <span class="nf">_interpolate_array_fromreffreq</span><span class="p">(</span><span class="n">stationNames</span> <span class="p">,</span> <span class="n">freq_array</span> <span class="p">,</span> <span class="n">reffreq_array</span><span class="p">,</span>
                                    <span class="n">array_dict_loc</span><span class="p">,</span> <span class="n">x_new</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rigoureous</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>  <span class="n">order_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span> 
    <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Interpolate value from  reference frequency : </span>
<span class="sd"> </span>
<span class="sd">    :param stationNames:  list of stations of survey .</span>
<span class="sd">    :type stationNames: list</span>
<span class="sd">     </span>
<span class="sd">    :param freq_array:  array of frequencies </span>
<span class="sd">    :type freq_array: (ndarray,1)</span>
<span class="sd">     </span>
<span class="sd">    :param reffreq_array: reference frequence for clean Data .</span>
<span class="sd">    :type reffreq_array: float </span>
<span class="sd">     </span>
<span class="sd">    :param array_dict_loc: location of each value according each station names  </span>
<span class="sd">                            keys are stationsNmes and value of array</span>
<span class="sd">                            at that station , eg -S00 , valueof RhO  </span>
<span class="sd">    :type array_dict_loc: dict </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="nf">_interpolate_array</span><span class="p">(</span><span class="n">array_to</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="s1">&#39;extrapolate&#39;</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        Interpolate value to according the list of frequencies. </span>
<span class="sd">        </span>
<span class="sd">        :param array_to: (ndarray,1), array to interpolate</span>
<span class="sd">        :type array_to: array_like</span>
<span class="sd">        </span>
<span class="sd">        :param fill_value: kind of extrapolation</span>
<span class="sd">        :type fill_value: str </span>
<span class="sd">        &quot;&quot;&quot;</span> 

        <span class="n">Y_intp_value</span> <span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">ss</span><span class="p">,</span> <span class="n">rowline</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">array_to</span><span class="p">):</span>
            <span class="n">func_interp</span> <span class="o">=</span> <span class="n">spi</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">x_old</span><span class="p">,</span> <span class="n">rowline</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>
            <span class="n">y_new</span><span class="o">=</span><span class="n">func_interp</span><span class="p">(</span><span class="n">x_new</span><span class="p">)</span>

            <span class="n">Y_intp_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_new</span><span class="p">)</span>
        <span class="n">new_Y_array</span> <span class="o">=</span><span class="n">func</span><span class="o">.</span><span class="n">concat_array_from_list</span><span class="p">(</span><span class="n">list_of_array</span><span class="o">=</span><span class="n">Y_intp_value</span><span class="p">,</span> <span class="n">concat_axis</span><span class="o">=</span><span class="n">order_axis</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">new_Y_array</span>
    
    <span class="k">if</span> <span class="n">x_new</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span> <span class="n">x_new</span><span class="o">=</span><span class="n">freq_array</span>
    <span class="n">x_old</span> <span class="o">=</span><span class="n">freq_array</span><span class="p">[:</span><span class="n">get_reffreq_index</span><span class="p">(</span><span class="n">freq_array</span><span class="o">=</span><span class="n">freq_array</span><span class="p">,</span>
                                                    <span class="n">reffreq_value</span><span class="o">=</span><span class="n">reffreq_array</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># add the value of rffreq_freqq</span>
    <span class="k">if</span> <span class="n">rigoureous</span> <span class="ow">is</span> <span class="kc">True</span> <span class="p">:</span> 
        <span class="n">x_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">freq_array</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">freq_array</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x_old</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

    <span class="n">temp_list</span> <span class="o">=</span><span class="p">[</span><span class="n">values</span> <span class="p">[:</span><span class="n">get_reffreq_index</span><span class="p">(</span><span class="n">freq_array</span><span class="o">=</span><span class="n">freq_array</span><span class="p">,</span>
                                                     <span class="n">reffreq_value</span><span class="o">=</span><span class="n">reffreq_array</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span>  <span class="n">keys</span> <span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">array_dict_loc</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> \
                                                       <span class="k">for</span>  <span class="n">stn</span> <span class="ow">in</span> <span class="n">stationNames</span>  <span class="k">if</span> <span class="n">keys</span> <span class="o">==</span><span class="n">stn</span>  <span class="p">]</span>
    <span class="n">value_to_intp</span> <span class="o">=</span><span class="n">func</span><span class="o">.</span><span class="n">concat_array_from_list</span><span class="p">(</span><span class="n">list_of_array</span><span class="o">=</span><span class="n">temp_list</span><span class="p">,</span> <span class="n">concat_axis</span><span class="o">=</span><span class="n">order_axis</span><span class="p">)</span> 
    <span class="k">return</span> <span class="n">value_to_intp</span> <span class="p">,</span> <span class="n">_interpolate_array</span><span class="p">(</span><span class="n">array_to</span><span class="o">=</span><span class="n">value_to_intp</span><span class="p">)</span>
       

<div class="viewcode-block" id="find_reference_frequency"><a class="viewcode-back" href="../../../../processing.html#pycsamt.ff.processing.zcalculator.find_reference_frequency">[docs]</a><span class="k">def</span> <span class="nf">find_reference_frequency</span><span class="p">(</span><span class="n">freq_array</span> <span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reffreq_value</span> <span class="o">=</span><span class="kc">None</span> <span class="p">,</span> <span class="n">sharp</span> <span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">etching</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span> 
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Method to find and interpolate reference value if it is not present on the frequency range. </span>

<span class="sd">    :param freq_array: array_like frequency range </span>
<span class="sd">    :type freq_array: array_like</span>
<span class="sd">    </span>
<span class="sd">    :param reffreq_value: reference frequency value</span>
<span class="sd">    :type reffreq_value: float or int </span>
<span class="sd">    </span>
<span class="sd">    :param sharp:  if set to True , it forces the program to find mainly </span>
<span class="sd">                    a value closest inside the  frequency range.</span>
<span class="sd">    :type sharp: bool  </span>

<span class="sd">    :param etching: bool , if set to True , it will print in your stdout.</span>
<span class="sd">    :type etching: bool </span>
<span class="sd">    </span>
<span class="sd">    :returns: reference frequency </span>
<span class="sd">    :rtype: float </span>
<span class="sd">            </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">freq_array</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">reffreq_value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span> 
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;None value can not be computed. check your frequency array or reference value.&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">freq_array</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="s1">&#39;int&#39;</span><span class="p">]:</span> 
        <span class="k">try</span> <span class="p">:</span> <span class="n">freq_array</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">ff</span><span class="p">)</span> <span class="k">for</span> <span class="n">ff</span> <span class="ow">in</span> <span class="n">freq_array</span><span class="p">])</span>
        <span class="k">except</span> <span class="p">:</span><span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Frequency data must be on (ndarray,1) of float value not str.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">reffreq_value</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">reffreq_value</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">float</span><span class="p">:</span> 
        <span class="k">try</span> <span class="p">:</span> <span class="n">reffreq_value</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">reffreq_value</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span> <span class="k">raise</span> <span class="n">CSex</span><span class="o">.</span><span class="n">pyCSAMTError_frequency</span><span class="p">(</span><span class="s2">&quot;Reference frequency must be either float value or integer.&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">freq_array</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">reffreq_value</span> <span class="o">&gt;</span> <span class="n">freq_array</span><span class="o">.</span><span class="n">max</span><span class="p">():</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Reference frequency is out of frequency range. see more infos about reference &#39;</span>\
                                                  <span class="s1">&#39; frequency.|</span><span class="si">{0}</span><span class="s1">|&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">infos</span><span class="o">.</span><span class="n">notion</span><span class="o">.</span><span class="n">reference_frequency</span><span class="p">))</span>
        <span class="k">raise</span> <span class="n">CSex</span><span class="o">.</span><span class="n">pyCSAMTError_frequency</span> <span class="p">(</span><span class="s2">&quot;Input reference frequency is out the frequency range. &quot;</span>\
                                          <span class="s2">&quot;Please put value between the frequency range. &quot;</span>\
                                        <span class="s2">&quot;Frequency range is [</span><span class="si">{0}</span><span class="s2"> Hz to </span><span class="si">{1}</span><span class="s2"> Hz].&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">freq_array</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">freq_array</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>
    
    <span class="k">def</span> <span class="nf">force_interpolation</span> <span class="p">(</span><span class="n">value_to_steep</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span> 
        <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        Method to force reference value interpolated to find a value in frequency range close to . </span>

<span class="sd">        :param value_to_steep:  reference frequency value to be forced .</span>
<span class="sd">        :type value_to_steep: float </span>
<span class="sd">        </span>
<span class="sd">        :returns: closet value of interpolated frequency </span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span> 
        <span class="c1">#find the value close to reference array.</span>
        
        <span class="k">if</span> <span class="n">freq_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">freq_array</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span> <span class="c1"># check whether frequencies are range to higher frequency to lower :  </span>
            <span class="n">temp_freq_array</span><span class="o">=</span> <span class="n">freq_array</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># sorted to lower to Highest </span>
        <span class="k">else</span> <span class="p">:</span> <span class="n">temp_freq_array</span> <span class="o">=</span> <span class="n">freq_array</span>
        
        <span class="k">if</span> <span class="n">value_to_steep</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="p">:</span> 
            <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">temp_freq_array</span> <span class="p">:</span> 
                <span class="k">if</span> <span class="n">xi</span> <span class="o">==</span> <span class="n">value_to_steep</span> <span class="p">:</span> 
                    <span class="n">index_refreq</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">temp_freq_array</span><span class="o">==</span><span class="n">xi</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">#find the index location on the normalization freq </span>
                    <span class="k">break</span> 
                <span class="k">elif</span> <span class="n">xi</span> <span class="o">&gt;</span> <span class="n">value_to_steep</span> <span class="p">:</span> 
                    <span class="c1"># check which frequency is closet one : </span>
                    <span class="n">index_temp</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">temp_freq_array</span><span class="o">==</span><span class="n">xi</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># find the upper location and take the lower value </span>
                                                       <span class="c1">#assume to be the -1nieme element of the range.</span>
                    <span class="c1"># print(xi, index_temp)</span>
                    <span class="n">dx1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">temp_freq_array</span><span class="p">[</span><span class="n">index_temp</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span> <span class="n">xi</span> <span class="p">)</span>
                    <span class="n">dx2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">temp_freq_array</span><span class="p">[</span><span class="n">index_temp</span><span class="p">]</span> <span class="o">-</span><span class="n">xi</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">dx1</span> <span class="o">&lt;</span> <span class="n">dx2</span> <span class="p">:</span> <span class="n">index_refreq</span> <span class="o">=</span><span class="n">index_temp</span><span class="o">-</span><span class="mi">1</span> 
                    <span class="k">else</span> <span class="p">:</span> <span class="n">index_refreq</span><span class="o">=</span><span class="n">index_temp</span>
                    <span class="k">break</span>
        <span class="c1">#new_value find  . and </span>
            <span class="n">new_val</span> <span class="o">=</span> <span class="n">temp_freq_array</span><span class="p">[</span><span class="n">index_refreq</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">freq_array</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">freq_array</span> <span class="o">==</span><span class="n">new_val</span><span class="p">)]</span>
        
        <span class="c1"># return freq_array[index_refreq]</span>
    
    <span class="n">interp_func</span> <span class="o">=</span><span class="n">spi</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">freq_array</span><span class="p">),</span> <span class="n">y</span><span class="o">=</span><span class="n">freq_array</span><span class="p">)</span>
    <span class="n">new_reference_value</span> <span class="o">=</span> <span class="n">interp_func</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">reffreq_value</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">sharp</span> <span class="o">==</span><span class="kc">True</span> <span class="p">:</span>
        <span class="k">if</span> <span class="n">etching</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;---&gt; Input reference frequency &lt;</span><span class="si">{0}</span><span class="s1">&gt; Hz has been interpolated to &lt; </span><span class="si">{1}</span><span class="s1"> &gt; Hz.&#39;</span><span class="o">.</span>\
                   <span class="nb">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="n">reffreq_value</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">new_reference_value</span> <span class="p">),</span><span class="mi">2</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">force_interpolation</span><span class="p">(</span><span class="n">value_to_steep</span><span class="o">=</span><span class="n">new_reference_value</span>  <span class="p">)</span>
    <span class="k">elif</span> <span class="n">sharp</span> <span class="o">==</span><span class="kc">False</span> <span class="p">:</span><span class="k">return</span> <span class="n">new_reference_value</span> </div>



     
                                                              
<div class="viewcode-block" id="get_data_from_reference_frequency"><a class="viewcode-back" href="../../../../processing.html#pycsamt.ff.processing.zcalculator.get_data_from_reference_frequency">[docs]</a><span class="k">def</span> <span class="nf">get_data_from_reference_frequency</span><span class="p">(</span><span class="n">array_loc</span><span class="p">,</span> <span class="n">freq_array</span><span class="p">,</span> <span class="n">reffreq_value</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to get reference frequency  without call especially stations array.</span>
<span class="sd">    The function is profitable but . It&#39;s less expensive However if something wrong happened</span>
<span class="sd">    by using the first step to get a reference array , it will try the traditionnally function </span>
<span class="sd">    to get it. If none value is found , an Error will </span>
<span class="sd">    occurs. </span>

<span class="sd">    :param array_loc: assume to be a dictionnary of stations_data_values. </span>
<span class="sd">    :type  array_loc: dict</span>
<span class="sd">    </span>
<span class="sd">    :param freq_array:  frequency array </span>
<span class="sd">    :type  freq_array: array_like</span>
<span class="sd">    </span>
<span class="sd">    :param reffreq_value:  reffrence value, If the reference value is not in frequency array ,</span>
<span class="sd">                            function will force to interpolate value and find the correlative array.</span>
<span class="sd">                           </span>
<span class="sd">    :type reffreq_value: float or int </span>
<span class="sd">            </span>
<span class="sd">    :returns:  an array of reference value at specific index </span>
<span class="sd">    :rtype: array_like </span>
<span class="sd">            </span>
<span class="sd">    :Example: </span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; get_data_from_reference_frequency(array_loc=rho,freq_array=freq_array,</span>
<span class="sd">        ...                                      reffreq_value=1023.)</span>
<span class="sd">        ... Input reference frequency has been interpolated to &lt; 1024.0 &gt; Hz </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">reffreq_value</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span> <span class="p">:</span> 
        <span class="k">try</span><span class="p">:</span> <span class="n">reffreq_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="n">reffreq_value</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span><span class="k">raise</span> <span class="n">CSex</span><span class="o">.</span><span class="n">pyCSAMTError_frequency</span><span class="p">(</span><span class="s2">&quot;Reference value must be float or int value, not str!&quot;</span><span class="p">)</span>
    <span class="c1">#find the size of array loc : seem to be the size of stationsNames .</span>
    <span class="n">stn_size</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">array_loc</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span><span class="o">.</span><span class="n">size</span>
    <span class="c1"># # we sorted data for ensurity</span>
    <span class="n">reffreq_array</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">values</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">freq_array</span><span class="o">==</span><span class="n">reffreq_value</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>
                             <span class="k">for</span> <span class="n">keys</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">array_loc</span><span class="o">.</span><span class="n">items</span><span class="p">())])</span>

    <span class="k">if</span> <span class="n">reffreq_value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">freq_array</span> <span class="p">:</span> 
        <span class="n">reffreq_array</span><span class="o">=</span> <span class="n">get_data_from_reference_frequency</span><span class="p">(</span><span class="n">array_loc</span><span class="o">=</span><span class="n">array_loc</span><span class="p">,</span>
                                                         <span class="n">freq_array</span><span class="o">=</span><span class="n">freq_array</span><span class="p">,</span>
                                                         <span class="n">reffreq_value</span><span class="o">=</span><span class="n">find_reference_frequency</span><span class="p">(</span>
                                                                      <span class="n">freq_array</span> <span class="o">=</span><span class="n">freq_array</span><span class="p">,</span> 
                                                                      <span class="n">reffreq_value</span> <span class="o">=</span><span class="n">reffreq_value</span> <span class="p">,</span>
                                                                      <span class="n">sharp</span> <span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                                                                      <span class="n">etching</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">reffreq_array</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">stn_size</span> <span class="p">:</span>
        <span class="k">return</span> <span class="n">reffreq_array</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">reffreq_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span>
    <span class="k">else</span> <span class="p">:</span>

        <span class="kn">from</span> <span class="nn">pycsamt.processing.callffunc</span> <span class="kn">import</span> <span class="n">get_array_from_reffreq</span>  <span class="k">as</span> <span class="n">gfreq</span>
        <span class="n">reffreq_array</span><span class="o">=</span><span class="n">gfreq</span><span class="p">(</span><span class="n">array_loc</span><span class="o">=</span><span class="n">array_loc</span> <span class="p">,</span> <span class="n">freq_array</span><span class="o">=</span><span class="n">freq_array</span><span class="p">,</span> 
                            <span class="n">reffreq_value</span><span class="o">=</span><span class="n">reffreq_value</span><span class="p">,</span>
                            <span class="n">stnNames</span><span class="o">=</span><span class="nb">sorted</span><span class="p">(</span><span class="n">array_loc</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="k">if</span> <span class="n">reffreq_array</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span>
            <span class="k">raise</span> <span class="n">CSex</span><span class="o">.</span><span class="n">pyCSAMTError_frequency</span><span class="p">(</span><span class="s1">&#39;Something wrong happened during reference array computing.&#39;</span>\
                                             <span class="s1">&#39; Please check the your inputs data size, and your station size.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">reffreq_array</span></div>

<div class="viewcode-block" id="perforce_reference_freq"><a class="viewcode-back" href="../../../../processing.html#pycsamt.ff.processing.zcalculator.perforce_reference_freq">[docs]</a><span class="k">def</span> <span class="nf">perforce_reference_freq</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">frequency_array</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Function to get automatically the reference frequency. If user doesnt provide the value , </span>
<span class="sd">    function will find automatically value . </span>
<span class="sd"> </span>
<span class="sd">    :param data: array of avg DATA,  ndim&gt;1 </span>
<span class="sd">    :type data: array_like </span>
<span class="sd">    </span>
<span class="sd">    :param frequency_array: array of frequency</span>
<span class="sd">    :type frequency_array: array_like   </span>
<span class="sd">    </span>
<span class="sd">    :returns: reffreq_value float , reference frequency value </span>
<span class="sd">    :rtype: float</span>
<span class="sd">    </span>
<span class="sd">    :returns: uncover_index,  index of reference value on frequency array </span>
<span class="sd">    :rtype: int </span>
<span class="sd">     </span>
<span class="sd">    :returns: nan_ratio , the ratio or the prevalence of nan in the data_set </span>
<span class="sd">    :rtype: float </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">copy</span>
    <span class="n">new_data_array</span> <span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">frequency_array</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span>
        <span class="n">frequency_array</span><span class="p">,</span><span class="o">*</span><span class="n">_</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">new_data_array</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1">#find according to AVGData disposal .</span>
        
    <span class="c1"># ifall data are cleaned the take the highst freqeuncy </span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">new_data_array</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">/</span><span class="n">new_data_array</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span><span class="mi">0</span><span class="p">:</span> 
        <span class="k">if</span> <span class="n">frequency_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">frequency_array</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">:</span>
            <span class="n">reffreq_value</span> <span class="o">=</span> <span class="n">frequency_array</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> 
        <span class="k">else</span> <span class="p">:</span> <span class="n">reffreq_value</span> <span class="o">=</span> <span class="n">frequency_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;--&gt; Reference frequency is estimated to &lt;</span><span class="si">{0}</span><span class="s1">&gt; Hz&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">reffreq_value</span> <span class="p">))</span>
        
        <span class="k">return</span>  <span class="n">reffreq_value</span> <span class="p">,</span> <span class="n">frequency_array</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mf">0.</span>
    
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">new_data_array</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">/</span><span class="n">new_data_array</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span><span class="mi">0</span> <span class="p">:</span> 
        <span class="n">nan_ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">new_data_array</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">/</span><span class="n">new_data_array</span><span class="o">.</span><span class="n">size</span> 
        <span class="n">new_data_array</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">new_data_array</span><span class="p">,</span> <span class="n">nan</span> <span class="o">=</span> <span class="o">-</span><span class="mi">99999</span><span class="p">)</span>
        <span class="c1"># uncover_index = np.where(new_data_array==-99999)   </span>
        <span class="n">reffreq_value</span> <span class="o">=</span> <span class="n">frequency_array</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">new_data_array</span><span class="o">==-</span><span class="mi">99999</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;--&gt; Reference frequency is estimated to &lt;</span><span class="si">{0}</span><span class="s1">&gt; Hz&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">reffreq_value</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">reffreq_value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">new_data_array</span><span class="o">==-</span><span class="mi">99999</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>  <span class="n">nan_ratio</span> </div>

<div class="viewcode-block" id="hanning"><a class="viewcode-back" href="../../../../processing.html#pycsamt.ff.processing.zcalculator.hanning">[docs]</a><span class="k">def</span> <span class="nf">hanning</span> <span class="p">(</span><span class="n">dipole_length</span><span class="o">=</span><span class="mf">50.</span><span class="p">,</span> <span class="n">number_of_points</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">large_band</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Function to compute hanning window .</span>
<span class="sd">    </span>
<span class="sd">    .. seealso::Torres-Verdin and Bostick, 1992, Principles of spatial surface electric</span>
<span class="sd">             field filtering in magnetotellurics: electromagnetic array profiling (EMAP),</span>
<span class="sd">             Geophysics, v57, p603-622.</span>
<span class="sd">        </span>
<span class="sd">    :param dipole_length: the length of dipole , xk is centered between dipole </span>
<span class="sd">    :type dipole_length: float</span>
<span class="sd">    </span>
<span class="sd">    :param number_of_points: number of filter points </span>
<span class="sd">    :type number_of_points: int  </span>
<span class="sd">    </span>
<span class="sd">    :returns: windowed hanning </span>
<span class="sd">    :rtype: array_like </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">dipole_length</span><span class="p">)</span> <span class="o">!=</span><span class="nb">float</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">number_of_points</span><span class="p">)</span> <span class="o">!=</span><span class="nb">int</span><span class="p">:</span> 
        
        <span class="k">try</span> <span class="p">:</span> 
            <span class="n">dipole_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="n">dipole_length</span><span class="p">)</span>
            <span class="n">number_of_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">number_of_points</span><span class="p">))</span>
        <span class="k">except</span> <span class="p">:</span>
            <span class="k">raise</span> <span class="n">CSex</span><span class="o">.</span><span class="n">pyCSAMTError_processing</span><span class="p">(</span><span class="s1">&#39;Dipole length and number of&#39;</span>\
                                           <span class="s1">&#39; points must be a float number.&#39;</span><span class="p">)</span>
        
    <span class="n">window_width</span> <span class="o">=</span> <span class="n">number_of_points</span> <span class="o">*</span> <span class="n">dipole_length</span>
    <span class="n">xk</span> <span class="p">,</span> <span class="n">HAN</span> <span class="o">=</span> <span class="n">window_width</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">,</span> <span class="p">[]</span>                           <span class="c1"># center point xk </span>
    <span class="n">X</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">xk</span><span class="p">,</span> <span class="n">xk</span><span class="p">,</span> <span class="n">number_of_points</span><span class="p">)</span>
    <span class="c1"># X = np.arange(  -xk , xk, dipole_length)</span>
    <span class="c1"># xpos= np.arange(number_of_points+1)*xk </span>
    
    <span class="k">if</span> <span class="n">large_band</span> <span class="o">==</span> <span class="kc">True</span> <span class="p">:</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mi">1</span><span class="o">/</span><span class="n">window_width</span> <span class="o">*</span> \
                                              <span class="p">(</span><span class="mi">1</span><span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">xx</span> <span class="o">/</span> <span class="n">window_width</span><span class="p">)))</span> <span class="k">for</span> <span class="n">xx</span> <span class="ow">in</span> <span class="n">X</span> <span class="p">])</span>

    <span class="k">for</span> <span class="n">xx</span> <span class="ow">in</span> <span class="n">X</span> <span class="p">:</span> 
        <span class="k">if</span> <span class="n">xx</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span> <span class="n">hannx</span><span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">window_width</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">xx</span> <span class="o">/</span> <span class="n">window_width</span><span class="p">))</span>
        <span class="k">else</span> <span class="p">:</span><span class="n">hannx</span> <span class="o">=</span> <span class="mi">0</span> 
        <span class="n">HAN</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hannx</span><span class="p">)</span>
    <span class="c1"># import matplotlib.pyplot as plt </span>
    <span class="c1"># plt.plot(X,np.array(HAN) )</span>
    <span class="c1"># plt.show()</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">HAN</span><span class="p">)</span></div>

 
<div class="viewcode-block" id="weight_beta"><a class="viewcode-back" href="../../../../processing.html#pycsamt.ff.processing.zcalculator.weight_beta">[docs]</a><span class="k">def</span> <span class="nf">weight_beta</span> <span class="p">(</span><span class="n">dipole_length</span> <span class="o">=</span><span class="mf">50.</span> <span class="p">,</span> <span class="n">number_of_points</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span> <span class="n">window_width</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> 
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    WeightBeta function is  weight Hanning window . if window width is not provide  , function </span>
<span class="sd">    will compute the width of window. </span>
<span class="sd">    </span>
<span class="sd">    .. seealso:: </span>
<span class="sd">            Torres-Verdin and Bostick, 1992, Principles of spatial surface electric field filtering in</span>
<span class="sd">            magnetotellurics: electromagnetic array profiling (EMAP), Geophysics, v57, p603-622.</span>
<span class="sd">            ...</span>
<span class="sd">            </span>
<span class="sd">    .. note::SUM(Betaj (j=1..M)=1 .</span>
<span class="sd">              </span>
<span class="sd">    :param dipole_length: length of dipole in meter (m) </span>
<span class="sd">    :type dipole_length: float</span>
<span class="sd">    </span>
<span class="sd">    :param number_of_points: number of station points to filter</span>
<span class="sd">    :type  number_of_points: int </span>
<span class="sd">    </span>
<span class="sd">    :param window_width: the width of window filter </span>
<span class="sd">    :type window_width: float </span>
<span class="sd">      </span>
<span class="sd">    :returns: beta_array at each station </span>
<span class="sd">    :rtype: array_like </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span> <span class="s1">&#39;Computing weight Hanning window &#39;</span><span class="p">)</span>
    <span class="c1"># beta_infx = - dipole_length/2 </span>
    <span class="c1"># beta_posfx = dipole_length /2 </span>
    <span class="k">if</span> <span class="n">window_width</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span> <span class="n">window_width</span> <span class="o">=</span> <span class="n">number_of_points</span> <span class="o">*</span>  <span class="n">dipole_length</span>
    <span class="k">if</span> <span class="n">window_width</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="p">:</span> 
        <span class="k">try</span> <span class="p">:</span> <span class="n">number_of_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">window_width</span> <span class="o">/</span> <span class="n">dipole_length</span> <span class="p">)</span> 
        <span class="k">except</span> <span class="p">:</span> 
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Please see more info about coeff.Beta :&lt;</span><span class="si">{0}</span><span class="s1">&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">infos</span><span class="o">.</span><span class="n">notion</span><span class="o">.</span><span class="n">weighted_Beta</span><span class="p">))</span>

            <span class="k">raise</span> <span class="n">CSex</span><span class="o">.</span><span class="n">pyCSAMTError_processing</span><span class="p">(</span><span class="s1">&#39;Window width type must be float number.&#39;</span><span class="p">)</span>
    
    <span class="n">xk</span> <span class="o">=</span> <span class="n">window_width</span> <span class="o">/</span> <span class="mi">2</span> 
    <span class="n">num_pk</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dipole_length</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">window_width</span> <span class="p">,</span> <span class="n">dipole_length</span><span class="p">)</span>
    <span class="n">beta_range</span><span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">xp</span> <span class="ow">in</span> <span class="n">num_pk</span> <span class="p">:</span> 
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">xp</span> <span class="o">-</span> <span class="n">xk</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">window_width</span> <span class="o">/</span><span class="mi">2</span> <span class="p">:</span> 
            <span class="n">beta_xp</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="o">/</span><span class="n">window_width</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">xp</span> <span class="o">+</span> <span class="n">dipole_length</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">xk</span><span class="p">)</span> <span class="o">+</span><span class="p">(</span><span class="n">window_width</span><span class="o">/</span> <span class="mi">2</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span>\
                       <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">xp</span> <span class="o">+</span> <span class="n">dipole_length</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span><span class="n">xk</span> <span class="p">)</span><span class="o">/</span><span class="n">window_width</span><span class="p">))))</span><span class="o">-</span>\
                <span class="p">((</span><span class="mi">1</span><span class="o">/</span><span class="n">window_width</span><span class="p">)</span><span class="o">*</span> <span class="p">((</span><span class="n">xp</span> <span class="o">-</span> <span class="n">dipole_length</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">xk</span><span class="p">)</span> <span class="o">+</span><span class="p">(</span><span class="n">window_width</span><span class="o">/</span> <span class="mi">2</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span>\
                 <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">xp</span> <span class="o">-</span> <span class="n">dipole_length</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span><span class="n">xk</span><span class="p">)</span><span class="o">/</span><span class="n">window_width</span><span class="p">))))</span>
                    
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">xp</span> <span class="o">-</span> <span class="n">xk</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">window_width</span><span class="o">/</span><span class="mi">2</span> <span class="p">:</span> <span class="n">beta_xp</span> <span class="o">=</span> <span class="mf">0.</span>
        
        <span class="n">beta_range</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beta_xp</span><span class="p">)</span> 
    
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">beta_range</span><span class="p">)</span></div>
    <span class="c1"># for xj in enra</span>
    
<div class="viewcode-block" id="compute_adaptative_moving_average"><a class="viewcode-back" href="../../../../processing.html#pycsamt.ff.processing.zcalculator.compute_adaptative_moving_average">[docs]</a><span class="nd">@deprecated</span><span class="p">(</span><span class="s1">&#39;Function deprecated&#39;</span><span class="p">)</span> 
<span class="k">def</span> <span class="nf">compute_adaptative_moving_average</span> <span class="p">(</span> <span class="n">z_array</span> <span class="o">=</span><span class="kc">None</span>  <span class="p">,</span> <span class="n">weighted_window</span><span class="o">=</span><span class="kc">None</span> <span class="p">,</span>
                  <span class="n">dipole_length</span> <span class="o">=</span> <span class="kc">None</span> <span class="p">,</span> <span class="n">number_of_points</span> <span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. note:: </span>
<span class="sd">        see `compute_AMA` !</span>
<span class="sd">    &quot;&quot;&quot;</span>
     
    <span class="k">if</span> <span class="n">z_array</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span> <span class="k">raise</span> <span class="n">CSex</span><span class="o">.</span><span class="n">pyCSAMTError_Z</span><span class="p">(</span><span class="s1">&#39;NoneType Impedance can not be computed.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">weighted_window</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span> 
        <span class="k">if</span> <span class="n">dipole_length</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">number_of_points</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span>
            <span class="k">raise</span> <span class="n">CSex</span><span class="o">.</span><span class="n">pyCSAMTError_inputarguments</span><span class="p">(</span><span class="s1">&#39;Please check &#39;</span>
                <span class="s1">&#39;your Inputs values ! NoneType values of dipole length or number_of_stations&#39;</span>
                <span class="s1">&#39; can not be computed.!&#39;</span><span class="p">)</span>
        <span class="k">try</span> <span class="p">:</span> 
            <span class="n">dipole_length</span> <span class="p">,</span> <span class="n">number_of_points</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="n">dipole_length</span><span class="p">)</span> <span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">number_of_points</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">:</span> <span class="k">raise</span> <span class="n">CSex</span><span class="o">.</span><span class="n">pyCSAMTError_float</span><span class="p">(</span><span class="s1">&#39;Dipole length, number of points must be a float, and &#39;</span>\
                                               <span class="s1">&#39; int  number respectively.!&#39;</span><span class="p">)</span>

        <span class="n">weighted_window</span> <span class="o">=</span><span class="n">weight_beta</span><span class="p">(</span><span class="n">dipole_length</span><span class="o">=</span><span class="n">dipole_length</span><span class="p">,</span> 
                                      <span class="n">number_of_points</span><span class="o">=</span><span class="n">number_of_points</span><span class="p">)</span>

    <span class="n">xc_pk</span> <span class="p">,</span> <span class="n">cFLAM</span> <span class="p">,</span> <span class="n">cut_off</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">weighted_window</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)),</span> <span class="p">[],</span> <span class="o">-</span><span class="mi">1</span> 

    <span class="k">for</span> <span class="n">kk</span> <span class="p">,</span> <span class="n">zz</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">z_array</span><span class="p">):</span> 
        <span class="k">if</span> <span class="n">kk</span> <span class="o">&lt;</span> <span class="n">xc_pk</span> <span class="p">:</span> 
            <span class="n">cut_off</span> <span class="o">+=</span> <span class="mi">1</span> 
            <span class="n">zz_new</span> <span class="o">=</span> <span class="n">weighted_window</span><span class="p">[</span><span class="n">xc_pk</span> <span class="o">-</span> <span class="n">cut_off</span> <span class="p">:</span> <span class="n">weighted_window</span><span class="o">.</span><span class="n">size</span><span class="p">]</span> <span class="o">*</span>\
            <span class="n">z_array</span><span class="p">[</span><span class="n">kk</span> <span class="o">-</span> <span class="n">cut_off</span><span class="p">:</span> <span class="n">weighted_window</span><span class="p">[</span><span class="n">xc_pk</span><span class="o">-</span><span class="n">cut_off</span> <span class="p">:</span> <span class="n">weighted_window</span><span class="o">.</span><span class="n">size</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>
            <span class="n">cFLAM</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">zz_new</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">kk</span> <span class="o">==</span> <span class="n">xc_pk</span> <span class="ow">or</span> <span class="n">kk</span> <span class="o">&lt;=</span> <span class="n">z_array</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">weighted_window</span><span class="p">[</span><span class="n">xc_pk</span><span class="p">:]</span><span class="o">.</span><span class="n">size</span><span class="p">:</span> 
            <span class="n">zz_new</span><span class="p">,</span> <span class="n">cut_off</span><span class="o">=</span> <span class="n">weighted_window</span> <span class="o">*</span> <span class="n">z_array</span><span class="p">[</span><span class="n">kk</span><span class="o">-</span> <span class="n">xc_pk</span> <span class="p">:</span> <span class="n">kk</span> <span class="o">+</span> <span class="n">weighted_window</span><span class="p">[</span><span class="n">xc_pk</span> <span class="p">:</span>\
                                                                <span class="n">weighted_window</span><span class="o">.</span><span class="n">size</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">],</span> <span class="mi">0</span>
            <span class="n">cFLAM</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">zz_new</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">kk</span> <span class="o">&gt;</span> <span class="n">z_array</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">weighted_window</span><span class="p">[</span><span class="n">xc_pk</span><span class="p">:]</span><span class="o">.</span><span class="n">size</span><span class="p">:</span> 
            <span class="n">cut_off</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">zz_new</span> <span class="o">=</span> <span class="n">z_array</span><span class="p">[</span><span class="n">kk</span><span class="o">-</span><span class="n">xc_pk</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">weighted_window</span><span class="p">[:(</span><span class="n">weighted_window</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span><span class="n">cut_off</span><span class="p">)]</span>
            <span class="n">cFLAM</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">zz_new</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
            
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cFLAM</span><span class="p">)</span></div>
            
<div class="viewcode-block" id="hanning_xk"><a class="viewcode-back" href="../../../../processing.html#pycsamt.ff.processing.zcalculator.hanning_xk">[docs]</a><span class="k">def</span> <span class="nf">hanning_xk</span> <span class="p">(</span><span class="n">dipole_length</span> <span class="o">=</span><span class="mf">50.</span> <span class="p">,</span> <span class="n">number_of_points</span> <span class="o">=</span><span class="mi">7</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    compute _hanning window on a wtdth of number of point : </span>
<span class="sd">        integrate value on all the window_bandwidth discrete and continue.</span>
<span class="sd">        if value is greater than Hald of the width  value == 0 . </span>
<span class="sd">       </span>
<span class="sd">    :param dipole_length: length of dipole </span>
<span class="sd">    :type dipole_length: float </span>
<span class="sd">    </span>
<span class="sd">    :param number_of_points:  value of points or survey stations . </span>
<span class="sd">    :type number_of_points: int </span>
<span class="sd">    </span>
<span class="sd">    :returns: han_xk , continue value on half bandwidth x0-- xk (center point) </span>
<span class="sd">    :rtype: array_like </span>
<span class="sd">    </span>
<span class="sd">    :returns: windowed hanning, discrete _value ,SUM(han(x0, xk))</span>
<span class="sd">    :rtype: array_like </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">window_width</span> <span class="o">=</span> <span class="n">number_of_points</span> <span class="o">*</span>  <span class="n">dipole_length</span> 
    <span class="n">xk</span> <span class="p">,</span> <span class="n">hannx</span><span class="o">=</span> <span class="n">window_width</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">,</span> <span class="p">[]</span>
    <span class="n">xpk_num</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dipole_length</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">window_width</span><span class="p">,</span> <span class="n">dipole_length</span><span class="p">)</span>

    <span class="n">han_xk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">1</span><span class="o">/</span> <span class="n">window_width</span> <span class="o">*</span> <span class="p">(</span> <span class="n">xk</span>  <span class="o">+</span> <span class="p">(</span><span class="n">window_width</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">xk</span><span class="p">)</span> <span class="o">/</span><span class="n">window_width</span><span class="p">)))</span> <span class="o">-</span> \
                <span class="p">(</span><span class="mi">1</span><span class="o">/</span> <span class="n">window_width</span> <span class="o">*</span> <span class="p">(</span> <span class="n">xpk_num</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="o">+</span> <span class="p">(</span><span class="n">window_width</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">xpk_num</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span><span class="n">window_width</span><span class="p">))))</span>
    
    <span class="c1"># compute Hanning discrete : </span>
    <span class="k">for</span>  <span class="n">ii</span><span class="p">,</span> <span class="n">xx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xpk_num</span><span class="p">)</span> <span class="p">:</span> 
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">window_width</span> <span class="o">/</span><span class="mi">2</span> <span class="p">:</span>
            <span class="n">han_xx</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span> <span class="n">window_width</span> <span class="o">*</span> <span class="p">(</span> <span class="p">(</span><span class="n">xx</span> <span class="o">+</span> <span class="n">dipole_length</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>  <span class="o">+</span> <span class="p">(</span><span class="n">window_width</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>  <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">xx</span> <span class="o">+</span> <span class="n">dipole_length</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span><span class="n">window_width</span><span class="p">)))</span> <span class="o">-</span> \
                <span class="mi">1</span><span class="o">/</span> <span class="n">window_width</span> <span class="o">*</span> <span class="p">(</span> <span class="p">(</span><span class="n">xx</span> <span class="o">-</span> <span class="n">dipole_length</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>  <span class="o">+</span> <span class="p">(</span><span class="n">window_width</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>  <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">xx</span> <span class="o">-</span> <span class="n">dipole_length</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span><span class="n">window_width</span><span class="p">)))</span>
        <span class="k">else</span> <span class="p">:</span> <span class="n">han_xx</span><span class="o">=</span> <span class="mi">0</span> 
        
        <span class="n">hannx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">han_xx</span><span class="p">)</span>

    
    <span class="k">return</span> <span class="n">han_xk</span> <span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hannx</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="hanning_x"><a class="viewcode-back" href="../../../../processing.html#pycsamt.ff.processing.zcalculator.hanning_x">[docs]</a><span class="k">def</span> <span class="nf">hanning_x</span> <span class="p">(</span><span class="n">x_point_value</span><span class="p">,</span> <span class="n">dipole_length</span> <span class="o">=</span><span class="mf">50.</span><span class="p">,</span>  <span class="n">number_of_points</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> 
               <span class="n">bandwidth_values</span><span class="o">=</span><span class="kc">False</span> <span class="p">,</span> <span class="n">on_half</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to compute point on window width .  Use discrete computing . Function show the value</span>
<span class="sd">    at center point of window assume that the point is center locate on the window width . </span>
<span class="sd">    It intergrates  value between dipole length. User can use see_extraband to see the values </span>
<span class="sd">    on the total bandwith. If half is False the value of greater than center point will be</span>
<span class="sd">    computed and not be 0 as the normal definition of Hanning window filter. </span>
<span class="sd">    </span>
<span class="sd">    :param x_point_value:  value  to intergrate.</span>
<span class="sd">    :type x_point_value: float </span>
<span class="sd">    </span>
<span class="sd">    :param dipole_length: length of dipole on survey</span>
<span class="sd">    :type dipole_length: float </span>
<span class="sd">    </span>
<span class="sd">    :param number_of_point: survey point or number point to apply.</span>
<span class="sd">    :type number_of_point: int </span>
<span class="sd">    </span>
<span class="sd">    :param bandwidth_values: see all value on the bandwith , value greater than x_center</span>
<span class="sd">                            point will be computed .</span>
<span class="sd">    :type bandwidth_values:bool </span>
<span class="sd">                            </span>
<span class="sd">    :param on_half:  value on the bandwith; value greater that x_center point = 0.</span>
<span class="sd">    :type on_half: bool </span>

<span class="sd">    :returns: hannx  integrated X_point_value or  array of window bandwidth .</span>
<span class="sd">    :rtype: array_like </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">window_width</span> <span class="o">=</span> <span class="n">number_of_points</span> <span class="o">*</span> <span class="n">dipole_length</span> 
    
    <span class="n">xx_points_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dipole_length</span><span class="o">/</span><span class="mi">2</span> <span class="p">,</span> <span class="n">window_width</span> <span class="p">,</span> <span class="n">dipole_length</span> <span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">see_extraband</span><span class="p">(</span> <span class="n">apply_on_half</span> <span class="o">=</span><span class="kc">False</span><span class="p">):</span> 
        <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        Function to see data of the large bande integrated hanning. if apply_on_half </span>
<span class="sd">        is set to True &lt; it will show the data on band &lt;= half windowith i.e. thin </span>
<span class="sd">        center point xk.</span>
<span class="sd">        </span>
<span class="sd">        :param apply_on_half: half band of hanning filter.</span>
<span class="sd">        :type apply_on_half: bool  </span>

<span class="sd">        :returns: windowed hanning band</span>
<span class="sd">        :rtype: array_like(ndarray,1) </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hv</span><span class="o">=</span><span class="p">[]</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">apply_on_half</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">xv</span>  <span class="ow">in</span>  <span class="n">xx_points_array</span><span class="p">:</span>
                <span class="n">hann_xv</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="mi">1</span><span class="o">/</span> <span class="n">window_width</span> <span class="o">*</span> <span class="p">(</span> <span class="p">(</span><span class="n">xv</span> <span class="o">+</span> <span class="n">dipole_length</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>  <span class="o">+</span> <span class="p">(</span><span class="n">window_width</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>  <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">xv</span><span class="o">+</span> <span class="n">dipole_length</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span><span class="n">window_width</span><span class="p">)))</span> <span class="o">-</span> \
                        <span class="mi">1</span><span class="o">/</span> <span class="n">window_width</span> <span class="o">*</span> <span class="p">(</span> <span class="p">(</span><span class="n">xv</span> <span class="o">-</span> <span class="n">dipole_length</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>  <span class="o">+</span> <span class="p">(</span><span class="n">window_width</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>  <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">xv</span> <span class="o">-</span> <span class="n">dipole_length</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span><span class="n">window_width</span><span class="p">))))</span>
                <span class="n">hv</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hann_xv</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">apply_on_half</span> <span class="p">:</span> 
            <span class="k">for</span> <span class="n">xv</span>  <span class="ow">in</span>  <span class="n">xx_points_array</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">xv</span>  <span class="o">&lt;=</span> <span class="n">window_width</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span> 
                    <span class="n">hann_xv</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="mi">1</span><span class="o">/</span> <span class="n">window_width</span> <span class="o">*</span> <span class="p">(</span> <span class="p">(</span><span class="n">xv</span> <span class="o">+</span> <span class="n">dipole_length</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>  <span class="o">+</span> <span class="p">(</span><span class="n">window_width</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>  <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">xv</span><span class="o">+</span> <span class="n">dipole_length</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span><span class="n">window_width</span><span class="p">)))</span> <span class="o">-</span> \
                        <span class="mi">1</span><span class="o">/</span> <span class="n">window_width</span> <span class="o">*</span> <span class="p">(</span> <span class="p">(</span><span class="n">xv</span> <span class="o">-</span> <span class="n">dipole_length</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>  <span class="o">+</span> <span class="p">(</span><span class="n">window_width</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>  <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">xv</span> <span class="o">-</span> <span class="n">dipole_length</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span><span class="n">window_width</span><span class="p">))))</span>
                <span class="k">else</span> <span class="p">:</span><span class="n">hann_xv</span><span class="o">=</span><span class="mi">0</span> 
                <span class="n">hv</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hann_xv</span><span class="p">)</span>
                
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hv</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="p">(</span><span class="n">x_point_value</span> <span class="o">-</span> <span class="n">dipole_length</span><span class="o">/</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">x_point_value</span> <span class="o">+</span><span class="n">dipole_length</span><span class="o">/</span><span class="mi">2</span> <span class="o">&gt;</span> <span class="n">window_width</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">CSex</span><span class="o">.</span><span class="n">pyCSAMTError_processing</span><span class="p">(</span><span class="s1">&#39;Hanning x point value is outside the window.&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">bandwidth_values</span> <span class="ow">is</span> <span class="kc">True</span> <span class="p">:</span> 
        <span class="k">if</span> <span class="n">on_half</span> <span class="p">:</span><span class="k">return</span> <span class="n">see_extraband</span><span class="p">(</span><span class="n">apply_on_half</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">on_half</span> <span class="p">:</span><span class="k">return</span>  <span class="n">see_extraband</span><span class="p">(</span><span class="n">apply_on_half</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span> <span class="p">:</span>
        <span class="k">if</span> <span class="n">x_point_value</span> <span class="o">&lt;=</span> <span class="n">window_width</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">hann_xp</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="mi">1</span><span class="o">/</span> <span class="n">window_width</span> <span class="o">*</span> <span class="p">(</span> <span class="p">(</span><span class="n">x_point_value</span> <span class="o">+</span> <span class="n">dipole_length</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>  <span class="o">+</span> <span class="p">(</span><span class="n">window_width</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>  <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">x_point_value</span> <span class="o">+</span> <span class="n">dipole_length</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span><span class="n">window_width</span><span class="p">)))</span> <span class="o">-</span> \
                        <span class="mi">1</span><span class="o">/</span> <span class="n">window_width</span> <span class="o">*</span> <span class="p">(</span> <span class="p">(</span><span class="n">x_point_value</span> <span class="o">-</span> <span class="n">dipole_length</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>  <span class="o">+</span> <span class="p">(</span><span class="n">window_width</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>  <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">x_point_value</span> <span class="o">-</span> <span class="n">dipole_length</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span><span class="n">window_width</span><span class="p">))))</span>
            
        <span class="k">else</span> <span class="p">:</span> <span class="n">hann_xp</span> <span class="o">=</span> <span class="mi">0</span>
        
    <span class="k">return</span>  <span class="n">hann_xp</span></div>

<div class="viewcode-block" id="wbetaX2"><a class="viewcode-back" href="../../../../processing.html#pycsamt.ff.processing.zcalculator.wbetaX2">[docs]</a><span class="k">def</span> <span class="nf">wbetaX2</span> <span class="p">(</span><span class="n">Xpos</span><span class="p">,</span> <span class="n">dipole_length</span><span class="o">=</span><span class="mf">50.</span><span class="p">,</span> <span class="n">number_of_points</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span> <span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    weight Beta is  computed following the paper of </span>
<span class="sd">    Torres-verdfn, C., and F. X. Bostick, 1992, Principles of spatial surface electric field </span>
<span class="sd">    filtering in magnetotelluricsâ¯- Electromagnetic array profiling ( EMAP )- Geophysics, 57(4), 25â34. </span>
<span class="sd">        </span>
<span class="sd">    :param Xpos: reference position on the field </span>
<span class="sd">    :type Xpos: str </span>
<span class="sd">    </span>
<span class="sd">    :param dipole_length: length of dipole measurement</span>
<span class="sd">    :type dipole_length: float </span>
<span class="sd">    </span>
<span class="sd">    :param number_of_points:  point to stand filters , window width </span>
<span class="sd">    :type number_of_points: int </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">window_width</span> <span class="o">=</span> <span class="n">dipole_length</span> <span class="o">*</span> <span class="n">number_of_points</span> 
    <span class="n">xk</span> <span class="o">=</span> <span class="n">window_width</span><span class="o">/</span><span class="mi">2</span>
    

    <span class="c1"># if np.abs(xp - xk) &lt;= window_width /2 : </span>
    <span class="n">beta_xpos</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="o">/</span><span class="n">window_width</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">Xpos</span> <span class="o">+</span> <span class="n">dipole_length</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">xk</span><span class="p">)</span> <span class="o">+</span><span class="p">(</span><span class="n">window_width</span><span class="o">/</span> <span class="mi">2</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span>\
               <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">Xpos</span> <span class="o">+</span> <span class="n">dipole_length</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span><span class="n">xk</span> <span class="p">)</span><span class="o">/</span><span class="n">window_width</span><span class="p">))))</span><span class="o">-</span>\
        <span class="p">((</span><span class="mi">1</span><span class="o">/</span><span class="n">window_width</span><span class="p">)</span><span class="o">*</span> <span class="p">((</span><span class="n">Xpos</span> <span class="o">-</span> <span class="n">dipole_length</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">xk</span><span class="p">)</span> <span class="o">+</span><span class="p">(</span><span class="n">window_width</span><span class="o">/</span> <span class="mi">2</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span>\
         <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">Xpos</span> <span class="o">-</span> <span class="n">dipole_length</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span><span class="n">xk</span><span class="p">)</span><span class="o">/</span><span class="n">window_width</span><span class="p">))))</span>
            
        <span class="c1"># elif np.abs(xp - xk) &gt; window_width/2 : beta_xpos = 0.</span>
        
        <span class="c1"># beta_range.append(beta_xpos) </span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Xpos</span><span class="o">-</span><span class="n">dipole_length</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">Xpos</span> <span class="o">+</span> <span class="n">dipole_length</span><span class="o">/</span><span class="mi">2</span><span class="p">])</span> <span class="p">,</span> <span class="n">beta_xpos</span> </div>

<div class="viewcode-block" id="compute_sigmas_e_h_and_sigma_rho"><a class="viewcode-back" href="../../../../processing.html#pycsamt.ff.processing.zcalculator.compute_sigmas_e_h_and_sigma_rho">[docs]</a><span class="k">def</span> <span class="nf">compute_sigmas_e_h_and_sigma_rho</span><span class="p">(</span><span class="n">pc_emag</span> <span class="p">,</span> <span class="n">pc_hmag</span><span class="p">,</span> <span class="n">pc_app_rho</span><span class="p">,</span> <span class="n">app_rho</span><span class="p">,</span> <span class="n">emag</span><span class="p">,</span> <span class="n">hmag</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    function to compute Standard Deviation for E-field (sigma_e), </span>
<span class="sd">    Standard Deviation for H-Field (sigma_h) , </span>
<span class="sd">    &amp; Standard Deviation for Component RHO (sigma_rho)</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">        * pc_emag : float  </span>
<span class="sd">                Statistical variation of magnitude values from averaged data blocks.</span>
<span class="sd">                Standard Deviation/Average Emag (%)</span>
<span class="sd">        * pc_hmag :float </span>
<span class="sd">                Statistical variation of magnitude values from averaged data blocks.</span>
<span class="sd">                Standard Deviation / Average Hmag (%)</span>
<span class="sd">        * pc_app_rho: float </span>
<span class="sd">                Statistical variation of magnitude values from averaged data blocks.</span>
<span class="sd">                Standard Deviation / Average Rho (%)</span>
<span class="sd">                 </span>
<span class="sd">        * app_rho :float </span>
<span class="sd">                resistivity calculated from averaged component (ohm.m)</span>
<span class="sd">        * Emag : float</span>
<span class="sd">                average E - field magnitude(microVolt/Km *amp )</span>
<span class="sd">        * Hmag : float </span>
<span class="sd">                average H - field magnitude(pTesta/amp) or (milliGammas/Amp)</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">        sigma_rho : float </span>
<span class="sd">             srhoC (Standard Deviation for Component RHO)</span>
<span class="sd">        c_var_Rho : float </span>
<span class="sd">            C-varrhoC(  Coefficient of Variation for Component RHO)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Standard Deviation for E-field (se) in (%) 1micoV/m*amp= 1mV/Km*amp</span>
    <span class="n">emag</span> <span class="o">/=</span><span class="mf">1e3</span> <span class="c1"># convert microvolt to millivolt </span>
    <span class="c1"># sigma_e, sigma_h, sigma_rho   = emag *(pc_emag/100), hmag * (pc_hmag /100) ,\</span>
    <span class="c1">#     pc_app_rho/100 * app_rho</span>
    
    <span class="n">sigma_e</span> <span class="p">,</span> <span class="n">sigma_h</span><span class="p">,</span> <span class="n">sigma_rho</span>   <span class="o">=</span>  <span class="n">pc_emag</span><span class="o">/</span><span class="mi">100</span><span class="p">,</span> <span class="n">pc_hmag</span> <span class="o">/</span><span class="mi">100</span> <span class="p">,</span> <span class="n">pc_app_rho</span><span class="o">/</span><span class="mi">100</span>

   
    <span class="k">return</span>  <span class="n">sigma_e</span> <span class="p">,</span> <span class="n">sigma_h</span><span class="p">,</span> <span class="n">sigma_rho</span> </div>
    
<div class="viewcode-block" id="compute_weight_factor_betaj"><a class="viewcode-back" href="../../../../processing.html#pycsamt.ff.processing.zcalculator.compute_weight_factor_betaj">[docs]</a><span class="k">def</span> <span class="nf">compute_weight_factor_betaj</span><span class="p">(</span><span class="n">Xpos</span> <span class="p">,</span> <span class="n">dipole_length</span><span class="o">=</span><span class="mf">50.</span> <span class="p">,</span> <span class="n">number_of_points</span> <span class="o">=</span><span class="mf">5.</span> <span class="p">,</span> 
                                <span class="n">window_width</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    weight Beta is  computed following the paper of Torres-verdfn, C., and F. X. Bostick, 1992,</span>
<span class="sd">     Principles of spatial surface electric field filtering in magnetotelluricsâ¯- Electromagnetic </span>
<span class="sd">    array profiling ( EMAP )- Geophysics, 57(4), 25â34. </span>
<span class="sd">        </span>
<span class="sd">    :param Xpos: reference position on the field </span>
<span class="sd">    :type Xpos: str </span>
<span class="sd">    </span>
<span class="sd">    :param dipole_length: length of dipole measurement</span>
<span class="sd">    :type dipole_length: float </span>
<span class="sd">    </span>
<span class="sd">    :param number_of_points:  point to stand filters , windowed width </span>
<span class="sd">    :type number_of_points: int </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#figureout the center ot dipole_lenght  and  compute the window width </span>
    <span class="k">if</span> <span class="n">window_width</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span> 
        <span class="n">window_width</span> <span class="o">=</span> <span class="n">dipole_length</span> <span class="o">*</span> <span class="n">number_of_points</span>  <span class="c1">#+  dipole_length # for extrema </span>
    
    <span class="n">xk</span> <span class="o">=</span> <span class="n">window_width</span><span class="o">/</span><span class="mi">2</span>
    
    <span class="c1"># declare limit of integrating hanning </span>
    
    <span class="n">xsup_lim</span> <span class="o">=</span> <span class="n">Xpos</span> <span class="o">+</span> <span class="n">dipole_length</span><span class="o">/</span><span class="mi">2</span> 
    <span class="n">xinf_lim</span> <span class="o">=</span> <span class="n">Xpos</span> <span class="o">-</span> <span class="n">dipole_length</span> <span class="o">/</span><span class="mi">2</span> 
    
    <span class="n">X</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">window_width</span><span class="p">,</span> <span class="n">dipole_length</span><span class="p">)</span> 

    <span class="n">betapos</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span> <span class="n">window_width</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">xsup_lim</span> <span class="o">-</span> <span class="n">xk</span> <span class="o">+</span> <span class="p">(</span><span class="n">window_width</span> <span class="o">/</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span> <span class="o">*</span>\
                                 <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span> <span class="mi">2</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span><span class="p">(</span><span class="n">xsup_lim</span> <span class="o">-</span> <span class="n">xk</span><span class="p">)</span><span class="o">/</span> <span class="n">window_width</span> <span class="p">))</span> <span class="o">-</span> <span class="p">(</span>
                                <span class="n">xinf_lim</span> <span class="o">-</span> <span class="n">xk</span> <span class="o">+</span> <span class="n">window_width</span> <span class="o">/</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span>\
                                 <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span> <span class="mi">2</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span><span class="p">(</span><span class="n">xinf_lim</span> <span class="o">-</span> <span class="n">xk</span><span class="p">)</span><span class="o">/</span> <span class="n">window_width</span> <span class="p">)))</span> 
            
    <span class="k">return</span> <span class="n">betapos</span><span class="p">,</span> <span class="n">window_width</span><span class="p">,</span> <span class="n">X</span> </div>

<div class="viewcode-block" id="compute_FLMA"><a class="viewcode-back" href="../../../../processing.html#pycsamt.ff.processing.zcalculator.compute_FLMA">[docs]</a><span class="k">def</span> <span class="nf">compute_FLMA</span> <span class="p">(</span> <span class="n">z_array</span> <span class="o">=</span><span class="kc">None</span>  <span class="p">,</span> <span class="n">weighted_window</span><span class="o">=</span><span class="kc">None</span> <span class="p">,</span>
                  <span class="n">dipole_length</span> <span class="o">=</span> <span class="mf">50.</span> <span class="p">,</span> <span class="n">number_of_points</span> <span class="o">=</span><span class="mf">5.</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Use a fixed-length-moving-average filter to estimate average apparent</span>
<span class="sd">    resistivities at a single static-correction-reference frequency</span>
<span class="sd">    </span>
<span class="sd">    :param z_array:  array of uncorrected impedance values.</span>
<span class="sd">    :type z_array: arry_like, complex</span>
<span class="sd">    </span>
<span class="sd">    :param dipole_length: length of dipole on survey</span>
<span class="sd">    :type dipole_length: float </span>
<span class="sd">    </span>
<span class="sd">    :param number_of_points: survey point or number point to apply.</span>
<span class="sd">    :type number_of_points: int </span>
<span class="sd">    </span>
<span class="sd">    :param weighted_window: bandwidth of hanning window filter lengths,</span>
<span class="sd">                           skin_depth arrays at each station.</span>
<span class="sd">    :type weighted_window: array_like </span>
<span class="sd"> </span>
<span class="sd">    :param app_rho: array of apparent resistivities in ohm.m , if not provided </span>
<span class="sd">                    will use impedance zrho to compute app_rho with reference_frequency </span>
<span class="sd">    :type app_rho: array_like </span>
<span class="sd">    </span>
<span class="sd">    :returns: windowed hanning , filtered window.</span>
<span class="sd">    :rtype: array_like </span>
<span class="sd">    </span>
<span class="sd">    :Example:</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; from pycsamt.ff.core.processing import zcalculator as Zcc</span>
<span class="sd">        &gt;&gt;&gt; z1= np.array([2.46073791 +3.00162006j ,</span>
<span class="sd">        ...             9.74193019 +1.82209497j,</span>
<span class="sd">        ...             15.68879141 + 12.91164264j ,</span>
<span class="sd">        ...             5.84384925 +3.6899018j, </span>
<span class="sd">        ...             2.4430065  +0.57175607j])</span>
<span class="sd">        &gt;&gt;&gt; flma= compute_FLMA(z_array=z1, dipole_length=50. ,</span>
<span class="sd">                               number_of_points=4)</span>
<span class="sd">        &gt;&gt;&gt; print(flma)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#reference_freq= kwargs.pop(&#39;reference_freq&#39;, 8192.)</span>
    
    <span class="k">if</span> <span class="n">z_array</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span> 
        <span class="k">raise</span> <span class="n">CSex</span><span class="o">.</span><span class="n">pyCSAMTError_Z</span><span class="p">(</span><span class="s1">&#39;NoneType Impedance can not be computed.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">weighted_window</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span> 
        <span class="k">if</span> <span class="n">dipole_length</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">number_of_points</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span>
            <span class="k">raise</span> <span class="n">CSex</span><span class="o">.</span><span class="n">pyCSAMTError_inputarguments</span><span class="p">(</span><span class="s1">&#39;Please check &#39;</span>
                <span class="s1">&#39;your Inputs values ! NoneType values of dipole length &#39;</span>
                <span class="s1">&#39; or number_of_stations can not be computed.!&#39;</span><span class="p">)</span>
        <span class="k">try</span> <span class="p">:</span> 
            <span class="n">dipole_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="n">dipole_length</span><span class="p">)</span> 
            <span class="n">number_of_points</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">number_of_points</span><span class="p">)</span>
            
        <span class="k">except</span> <span class="p">:</span>
            <span class="k">raise</span> <span class="n">CSex</span><span class="o">.</span><span class="n">pyCSAMTError_float</span><span class="p">(</span>
                <span class="s1">&#39;Dipole length, number of points must be a float, and &#39;</span>
                    <span class="s1">&#39; int  number respectively.!&#39;</span><span class="p">)</span>

        <span class="n">weighted_window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dipole_length</span> <span class="o">*</span> <span class="n">number_of_points</span> <span class="p">,</span> 
                                    <span class="n">dipole_length</span><span class="p">)</span>
       
    <span class="c1"># compute weight factor Bj </span>
    <span class="n">wk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">compute_weight_factor_betaj</span><span class="p">(</span><span class="n">Xpos</span> <span class="p">,</span> <span class="n">dipole_length</span><span class="o">=</span><span class="n">dipole_length</span> <span class="p">,</span> 
                                <span class="n">number_of_points</span> <span class="o">=</span><span class="n">number_of_points</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> 
          <span class="k">for</span> <span class="n">Xpos</span> <span class="ow">in</span> <span class="n">weighted_window</span><span class="p">])</span>
    
    <span class="c1">#seek the center point  index xc_pk  </span>

    <span class="n">xc_pk</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">wk</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span><span class="mi">2</span><span class="p">)</span>   <span class="c1"># weight array size is odd </span>
       
    
    <span class="n">cFLMA</span> <span class="p">,</span> <span class="n">cut_off</span> <span class="o">=</span> <span class="p">[],</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># take a minimum </span>

    <span class="kn">import</span> <span class="nn">copy</span> 
    <span class="n">tem_wk</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">wk</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">kk</span> <span class="p">,</span> <span class="n">zz</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">z_array</span><span class="p">):</span> 
        <span class="k">if</span> <span class="n">kk</span> <span class="o">&lt;</span> <span class="n">xc_pk</span> <span class="p">:</span> 
            <span class="n">cut_off</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># cut off to shrink one index  </span>
            <span class="n">tem_wk</span> <span class="p">[:</span><span class="n">xc_pk</span> <span class="o">-</span><span class="n">cut_off</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span> <span class="c1"># where wk 0 outside of the Hanning window</span>
            <span class="n">tem_z</span><span class="o">=</span> <span class="n">z_array</span><span class="p">[:</span><span class="n">kk</span> <span class="o">+</span> <span class="n">xc_pk</span> <span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># keep main array </span>
            <span class="c1"># buid array with number of 0 outside the window </span>
            <span class="n">add0</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wk</span><span class="p">)</span><span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">tem_z</span><span class="p">)</span>  
            <span class="c1"># build array as the same dim with hanning window centered a k position</span>
            <span class="n">tem_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="n">add0</span><span class="p">),</span> <span class="n">tem_z</span><span class="p">))</span>
            <span class="n">zz_new</span><span class="o">=</span> <span class="n">tem_z</span> <span class="o">*</span> <span class="n">tem_wk</span> <span class="c1"># compute value </span>
            <span class="n">cFLMA</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">zz_new</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
            
            <span class="n">tem_wk</span> <span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">wk</span><span class="p">)</span> <span class="c1"># copy once again for next loop if exist </span>
            
        <span class="k">elif</span> <span class="n">xc_pk</span> <span class="o">&lt;=</span> <span class="n">kk</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wk</span><span class="p">)</span> <span class="o">%</span><span class="mi">2</span> <span class="o">!=</span><span class="mi">0</span><span class="p">:</span> <span class="c1"># if window weight len is odd </span>
                <span class="k">if</span>  <span class="n">kk</span> <span class="o">&lt;</span> <span class="n">z_array</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">xc_pk</span><span class="p">:</span>
                    <span class="n">zz_new</span><span class="o">=</span> <span class="n">z_array</span><span class="p">[</span><span class="n">kk</span> <span class="o">-</span> <span class="n">xc_pk</span><span class="p">:</span> <span class="n">kk</span> <span class="o">+</span> <span class="n">xc_pk</span> <span class="o">+</span><span class="mi">1</span>  <span class="p">]</span> <span class="o">*</span> <span class="n">wk</span> <span class="c1"># when center point is even </span>
                <span class="k">elif</span>  <span class="n">kk</span> <span class="o">&gt;=</span> <span class="n">z_array</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">xc_pk</span><span class="p">:</span>
                    <span class="n">tem_z</span> <span class="o">=</span> <span class="n">z_array</span><span class="p">[</span><span class="n">kk</span><span class="o">-</span><span class="n">xc_pk</span><span class="p">:]</span> 
                    <span class="n">add0</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wk</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">tem_z</span><span class="p">)</span>  
                    <span class="n">tem_wk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">tem_z</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="n">add0</span><span class="p">)))</span>
                    <span class="n">zz_new</span> <span class="o">=</span><span class="n">tem_wk</span> <span class="o">*</span> <span class="n">wk</span>

            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">wk</span><span class="p">)</span> <span class="o">%</span><span class="mi">2</span> <span class="o">==</span><span class="mi">0</span><span class="p">:</span><span class="c1"># when window length is even.</span>
                <span class="k">if</span> <span class="n">kk</span> <span class="o">&lt;=</span> <span class="n">z_array</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">xc_pk</span><span class="p">:</span>
                    <span class="n">zz_new</span><span class="o">=</span> <span class="n">z_array</span><span class="p">[</span><span class="n">kk</span> <span class="o">-</span> <span class="n">xc_pk</span>  <span class="p">:</span> <span class="n">kk</span> <span class="o">+</span> <span class="n">xc_pk</span><span class="p">]</span> <span class="o">*</span> <span class="n">wk</span>
      
                <span class="k">elif</span>  <span class="n">kk</span> <span class="o">&gt;</span> <span class="n">z_array</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">xc_pk</span><span class="p">:</span>
                    <span class="n">tem_z</span> <span class="o">=</span> <span class="n">z_array</span><span class="p">[</span><span class="n">kk</span><span class="o">-</span><span class="n">xc_pk</span><span class="p">:]</span> 
                    <span class="n">add0</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wk</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">tem_z</span><span class="p">)</span>  
                    <span class="n">tem_wk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">tem_z</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="n">add0</span><span class="p">)))</span>
                    <span class="n">zz_new</span> <span class="o">=</span><span class="n">tem_wk</span> <span class="o">*</span> <span class="n">wk</span>    
                    
            <span class="n">cFLMA</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">zz_new</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>    
            
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;** </span><span class="si">{0:&lt;27}</span><span class="s1"> </span><span class="si">{1}</span><span class="s1"> </span><span class="si">{2}</span><span class="s1"> m.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;Filter&#39;s width&quot;</span><span class="p">,</span>
                                <span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">number_of_points</span><span class="p">)</span><span class="o">*</span> <span class="n">dipole_length</span><span class="p">))</span>   
             
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cFLMA</span><span class="p">)</span>    </div>

<div class="viewcode-block" id="compute_TMA"><a class="viewcode-back" href="../../../../processing.html#pycsamt.ff.processing.zcalculator.compute_TMA">[docs]</a><span class="k">def</span> <span class="nf">compute_TMA</span> <span class="p">(</span><span class="n">data_array</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">number_of_TMApoints</span><span class="o">=</span><span class="mf">5.</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    function to compute a trimmed-moving-average filter </span>
<span class="sd">    to estimate average apparent resistivities.</span>

<span class="sd">    :param data_array:  content of value to be trimmed </span>
<span class="sd">    :type data_array: array_like(ndarray,1) </span>
<span class="sd">    </span>
<span class="sd">    :param number_of_TMA points:  number of filter points .</span>
<span class="sd">    :type number_of_TMA points: int </span>
<span class="sd">    </span>
<span class="sd">    :returns:  value corrected with TMA  </span>
<span class="sd">    :rtype: array_like (ndarray, 1)</span>
<span class="sd">    </span>
<span class="sd">    :Example:</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; from pycsamt.ff.core.processing import zcalculator as Zcc</span>
<span class="sd">        &gt;&gt;&gt; z2 = np.array([2.46073791 , 3.00162006 ,</span>
<span class="sd">        ...     9.74193019 ])# 1.82209497,</span>
<span class="sd">        ...     # 15.68879141 ,  12.91164264 ,</span>
<span class="sd">        ...     # 5.84384925 , 3.6899018, </span>
<span class="sd">        ...     # 2.4430065  ,0.57175607])</span>
<span class="sd">        &gt;&gt;&gt; tma= Zcc.compute_TMA(data_array=z2,</span>
<span class="sd">        ...                     number_of_TMApoints= 7)</span>
<span class="sd">        ... print(tma)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">data_array</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span>
        <span class="k">raise</span> <span class="n">CSex</span><span class="o">.</span><span class="n">pyCSAMTError_processing</span><span class="p">(</span>
            <span class="s1">&#39;NoneType arguments can not be computed!.&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">data_array</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="s1">&#39;int&#39;</span><span class="p">]:</span> 
        <span class="k">try</span> <span class="p">:</span><span class="n">data_array</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">dd</span><span class="p">)</span> <span class="k">for</span> <span class="n">dd</span> <span class="ow">in</span> <span class="n">data_array</span><span class="p">])</span>
        <span class="k">except</span> <span class="p">:</span> 
            <span class="k">raise</span> <span class="n">CSex</span><span class="o">.</span><span class="n">pyCSAMTError_float</span><span class="p">(</span>
                <span class="s1">&#39;Data must be on array_like float number.!&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">number_of_TMApoints</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span> <span class="p">:</span>
        <span class="k">try</span> <span class="p">:</span> 
            <span class="n">number_of_TMApoints</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">number_of_TMApoints</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">:</span> 
            <span class="k">raise</span> <span class="n">CSex</span><span class="o">.</span><span class="n">pyCSAMTError_parameter_number</span><span class="p">(</span>
                <span class="s1">&#39;TMA filter point must be integer.&#39;</span><span class="p">)</span>
    
    <span class="n">roll_TMA</span> <span class="o">=</span><span class="p">[]</span>
    <span class="c1"># let compute TMA for one points, 1 poinst will return the data array</span>
    <span class="c1"># Ascertqin number of TMA point and Data _array</span>
    
    <span class="k">if</span> <span class="n">number_of_TMApoints</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_array</span><span class="p">)</span> <span class="p">:</span> 
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Number of TMA points = </span><span class="si">{}</span><span class="s2">  is too large !&quot;</span><span class="o">.</span>
                      <span class="nb">format</span><span class="p">(</span><span class="n">number_of_TMApoints</span><span class="p">))</span>
        <span class="n">number_of_TMApoints</span> <span class="o">=</span><span class="mi">5</span> <span class="c1"># reset temporray to 5.</span>
        
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_array</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span> <span class="c1">#find the TMA point accessible for computation</span>
        <span class="c1"># window width </span>
        <span class="n">number_of_TMApoints</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_array</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_array</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
            
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot; Number of sites explored are too short !&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;--&gt; Investigation sites too short !&quot;</span><span class="p">)</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;** </span><span class="si">{0:&lt;27}</span><span class="s1"> </span><span class="si">{1}</span><span class="s1"> </span><span class="si">{2}</span><span class="s1"> pts.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;Filter width  &#39;</span><span class="p">,</span>
                                <span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">number_of_TMApoints</span><span class="p">)))</span> 
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_array</span><span class="p">)</span> <span class="o">==</span><span class="mi">1</span> <span class="p">:</span>  <span class="k">return</span> <span class="n">data_array</span> 
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_array</span><span class="p">)</span> <span class="o">==</span><span class="mi">2</span> <span class="p">:</span> <span class="c1"># take the mean of both value </span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">data_array</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_array</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_array</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span> <span class="c1"># loop the window and take mean value at each time</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;--&gt; ! Less number of TMA points  for higher frequencies mitigation.!&quot;</span><span class="p">)</span>
                  
            <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_array</span><span class="p">)):</span> <span class="c1"># add add overall mean to the last value </span>
                <span class="k">if</span> <span class="n">kk</span> <span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">data_array</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">tma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">data_array</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span>
                                    <span class="n">data_array</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                    <span class="n">roll_TMA</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">tma</span><span class="p">))</span> 
                <span class="k">else</span> <span class="p">:</span> 
                    <span class="n">roll_TMA</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data_array</span><span class="p">[</span><span class="n">kk</span><span class="p">:</span><span class="n">kk</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;** </span><span class="si">{0:&lt;27}</span><span class="s1"> </span><span class="si">{1}</span><span class="s1"> </span><span class="si">{2}</span><span class="s1"> pts.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;Filter width  &#39;</span><span class="p">,</span>
                                <span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">number_of_TMApoints</span><span class="p">)))</span>     
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">roll_TMA</span><span class="p">)</span>
        
     
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_array</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">5</span> <span class="ow">and</span> <span class="n">number_of_TMApoints</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span> 

        <span class="k">if</span> <span class="n">number_of_TMApoints</span> <span class="o">&lt;=</span> <span class="mi">3</span> <span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Number of points provided to compute TMA are not enough &quot;</span>
                          <span class="s2">&quot;for higher frequencies reduction.TMA points less than three (3)  &quot;</span>
                          <span class="s2">&quot; are not consistent to correct data.&quot;</span>
                          <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;--&gt;  Number of points are not enough for higher frequencies attenuation.&quot;</span>
                  <span class="s2">&quot;For consistency, provide TMA points more than three.&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_array</span><span class="p">)</span><span class="o">==</span> <span class="mi">5</span> <span class="p">:</span> <span class="n">mesf</span> <span class="o">=</span><span class="s2">&quot;equal to&quot;</span>
        <span class="k">else</span> <span class="p">:</span> <span class="n">mesf</span> <span class="o">=</span> <span class="s2">&quot;more than&quot;</span>
        
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Number of sites explored is estimated &quot;</span>
                      <span class="s2">&quot;to </span><span class="si">{}</span><span class="s2">, then  number of TMA points is resetting &quot;</span>
                      <span class="s2">&quot;to 5 as default value.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_array</span><span class="p">)))</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;--&gt; Number of explored sites is </span><span class="si">{0}</span><span class="s2">  five(5).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mesf</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;--&gt; TMA points was resseting  to 5.&quot;</span><span class="p">)</span>
        
        <span class="n">number_of_TMApoints</span><span class="o">=</span><span class="mi">5</span>
        
    
    <span class="n">xk_cp</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trunc</span><span class="p">(</span><span class="n">number_of_TMApoints</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span> <span class="c1"># centered point</span>
    
    <span class="n">cut_off</span><span class="o">=-</span><span class="mi">1</span>          <span class="c1">#starting point </span>
    <span class="k">for</span> <span class="n">kk</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data_array</span><span class="p">):</span> 
        <span class="k">if</span> <span class="n">kk</span> <span class="o">&lt;</span> <span class="n">xk_cp</span> <span class="p">:</span> 
            <span class="n">cut_off</span> <span class="o">+=</span><span class="mi">1</span> 
            <span class="n">tma</span><span class="o">=</span> <span class="n">data_array</span><span class="p">[</span><span class="n">kk</span><span class="o">-</span><span class="n">cut_off</span><span class="p">:</span> <span class="n">kk</span><span class="o">+</span> <span class="n">xk_cp</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            
        <span class="k">elif</span> <span class="n">xk_cp</span> <span class="o">&lt;=</span> <span class="n">kk</span> <span class="o">&lt;=</span> <span class="n">data_array</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">xk_cp</span><span class="p">:</span>
            <span class="n">tma</span> <span class="o">=</span> <span class="n">data_array</span><span class="p">[</span><span class="n">kk</span><span class="o">-</span> <span class="n">xk_cp</span><span class="p">:</span><span class="n">kk</span> <span class="o">+</span> <span class="n">xk_cp</span> <span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># for Python index </span>
        
        <span class="k">elif</span> <span class="n">kk</span> <span class="o">&gt;</span> <span class="n">data_array</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">xk_cp</span><span class="p">:</span>
            <span class="n">tma</span> <span class="o">=</span> <span class="n">data_array</span><span class="p">[</span><span class="n">kk</span><span class="o">-</span><span class="n">xk_cp</span><span class="p">:]</span>

        <span class="n">get_TMA_value</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">tma</span><span class="p">,</span> 
                       <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tma</span><span class="o">.</span><span class="n">argmin</span><span class="p">(),</span> <span class="n">tma</span><span class="o">.</span><span class="n">argmax</span><span class="p">())</span>
                        <span class="p">)</span>
        <span class="c1">#tma = np.delete(tma, np.argmax(rho_tem), axis = 0)</span>
        <span class="n">roll_TMA</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">get_TMA_value</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
        
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;** </span><span class="si">{0:&lt;27}</span><span class="s1"> </span><span class="si">{1}</span><span class="s1"> </span><span class="si">{2}</span><span class="s1"> pts.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;Filter width  &#39;</span><span class="p">,</span>
                                <span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">number_of_TMApoints</span><span class="p">)))</span>     
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">roll_TMA</span><span class="p">)</span>   </div>

<div class="viewcode-block" id="compute_trimming_moving_average"><a class="viewcode-back" href="../../../../processing.html#pycsamt.ff.processing.zcalculator.compute_trimming_moving_average">[docs]</a><span class="nd">@deprecated</span><span class="p">(</span><span class="s1">&#39;Function too  expensive, redirected to `compute_TMA` more faster.&#39;</span><span class="p">)</span>    
<span class="nd">@redirect_cls_or_func</span><span class="p">(</span><span class="n">compute_TMA</span><span class="p">,</span> <span class="s2">&quot;short and faster than the func below&quot;</span><span class="p">)</span>    
<span class="k">def</span> <span class="nf">compute_trimming_moving_average</span> <span class="p">(</span><span class="n">data_array</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">number_of_TMApoints</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    function to compute a trimmed-moving-average filter</span>
<span class="sd">    to estimate average apparent resistivities.</span>

<span class="sd">    :param data_array:  content of value to be trimmed </span>
<span class="sd">    :type data_array: array_like(ndarray,1) </span>
<span class="sd">    </span>
<span class="sd">    :param number_of_TMA points:  number of filter points .</span>
<span class="sd">    :type number_of_TMA points: int </span>
<span class="sd">    </span>
<span class="sd">    :returns:  value corrected with TMA  </span>
<span class="sd">    :rtype: array_like (ndarray, 1)</span>
<span class="sd">          </span>
<span class="sd">    :Example:</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; from pycsamt.ff.core.processing import zcalculator as Zcc</span>
<span class="sd">        &gt;&gt;&gt; z2 = np.array([2.46073791 , 3.00162006 ,</span>
<span class="sd">        ...     9.74193019 ])# 1.82209497,</span>
<span class="sd">        ...     # 15.68879141 ,  12.91164264 ,</span>
<span class="sd">        ...     # 5.84384925 , 3.6899018, </span>
<span class="sd">        ...     # 2.4430065  ,0.57175607])</span>
<span class="sd">        &gt;&gt;&gt;  tma= Zcc.compute_trimming_moving_average(data_array=z2,</span>
<span class="sd">        ...                                          number_of_TMApoints= 4)</span>
<span class="sd">        &gt;&gt;&gt; print(tma)</span>
<span class="sd">        &gt;&gt;&gt; print(z2.shape)</span>
<span class="sd">        &gt;&gt;&gt; print(tma.shape)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">data_array</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">number_of_TMApoints</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span>
        <span class="k">raise</span> <span class="n">CSex</span><span class="o">.</span><span class="n">pyCSAMTError_processing</span><span class="p">(</span><span class="s1">&#39;NoneType arguments can not be computed!.&#39;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">data_array</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="s1">&#39;int&#39;</span><span class="p">]:</span> 
        <span class="k">try</span> <span class="p">:</span><span class="n">data_array</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">dd</span><span class="p">)</span> <span class="k">for</span> <span class="n">dd</span> <span class="ow">in</span> <span class="n">data_array</span><span class="p">])</span>
        <span class="k">except</span> <span class="p">:</span> <span class="k">raise</span> <span class="n">CSex</span><span class="o">.</span><span class="n">pyCSAMTError_AvgData</span><span class="p">(</span><span class="s1">&#39;Data must be on array_like float number.!&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">number_of_TMApoints</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span> <span class="p">:</span>
        <span class="k">try</span> <span class="p">:</span> <span class="n">number_of_TMApoints</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">number_of_TMApoints</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">:</span> <span class="k">raise</span> <span class="n">CSex</span><span class="o">.</span><span class="n">pyCSAMTError_parameter_number</span><span class="p">(</span><span class="s1">&#39;TMA filter point must be integer.&#39;</span><span class="p">)</span>
    
    <span class="n">roll_TMA</span><span class="p">,</span><span class="n">window</span>  <span class="o">=</span><span class="p">[],</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trunc</span><span class="p">(</span><span class="n">number_of_TMApoints</span><span class="o">/</span><span class="mi">2</span><span class="p">)),</span>

    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data_array</span><span class="p">):</span> 
        <span class="k">if</span> <span class="n">ii</span> <span class="o">&lt;</span> <span class="n">window</span><span class="p">:</span>
            <span class="n">get_TMA_value</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">data_array</span><span class="p">[</span><span class="n">ii</span><span class="p">:</span><span class="n">number_of_TMApoints</span><span class="o">+</span><span class="n">ii</span><span class="p">],</span> 
                                     <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">data_array</span><span class="p">[</span><span class="n">ii</span><span class="p">:</span><span class="n">number_of_TMApoints</span><span class="o">+</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">argmin</span><span class="p">(),</span> 
                                     <span class="n">data_array</span><span class="p">[</span><span class="n">ii</span><span class="p">:</span><span class="n">number_of_TMApoints</span><span class="o">+</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">argmax</span><span class="p">()]))</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">roll_TMA</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">get_TMA_value</span><span class="p">)</span>
            
        <span class="k">elif</span> <span class="n">ii</span> <span class="o">==</span> <span class="n">window</span> <span class="ow">or</span> <span class="n">ii</span> <span class="o">&lt;</span> <span class="n">data_array</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">window</span> <span class="p">:</span>
            <span class="k">if</span> <span class="n">ii</span> <span class="o">==</span> <span class="n">data_array</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="p">(</span><span class="n">window</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">:</span>
                <span class="n">get_TMA_value</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">data_array</span><span class="p">[</span><span class="n">ii</span><span class="o">-</span><span class="n">window</span><span class="p">:],</span>
                                         <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">data_array</span><span class="p">[</span><span class="n">ii</span><span class="o">-</span><span class="n">window</span><span class="p">:]</span><span class="o">.</span><span class="n">argmin</span><span class="p">(),</span>
                                                                                                               <span class="n">data_array</span><span class="p">[</span><span class="n">ii</span><span class="o">-</span><span class="n">window</span><span class="p">:]</span><span class="o">.</span><span class="n">argmax</span><span class="p">()]))</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> 
            <span class="k">else</span> <span class="p">:</span><span class="n">get_TMA_value</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">data_array</span><span class="p">[</span><span class="n">ii</span><span class="o">-</span><span class="n">window</span><span class="p">:</span><span class="n">ii</span><span class="o">+</span><span class="n">window</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
                                           <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">data_array</span><span class="p">[</span><span class="n">ii</span><span class="o">-</span><span class="n">window</span><span class="p">:</span><span class="n">ii</span><span class="o">+</span><span class="n">window</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">argmin</span><span class="p">(),</span> 
                                           <span class="n">data_array</span><span class="p">[</span><span class="n">ii</span><span class="o">-</span><span class="n">window</span><span class="p">:</span><span class="n">ii</span><span class="o">+</span><span class="n">window</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">argmax</span><span class="p">()]))</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">roll_TMA</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">get_TMA_value</span><span class="p">)</span>
            
        <span class="k">elif</span> <span class="n">ii</span> <span class="o">&gt;=</span><span class="n">data_array</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">window</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="n">data_array</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">get_TMA_value</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">data_array</span><span class="p">[</span><span class="n">ii</span><span class="o">-</span><span class="n">number_of_TMApoints</span><span class="o">-</span><span class="mi">1</span><span class="p">:],</span>
                                         <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">data_array</span><span class="p">[</span><span class="n">ii</span><span class="o">-</span><span class="n">number_of_TMApoints</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">argmin</span><span class="p">(),</span> 
                                         <span class="n">data_array</span><span class="p">[</span><span class="n">ii</span><span class="o">-</span><span class="n">number_of_TMApoints</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">argmax</span><span class="p">()]))</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                
            <span class="k">else</span> <span class="p">:</span><span class="n">get_TMA_value</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">data_array</span><span class="p">[</span><span class="n">ii</span><span class="o">-</span><span class="n">number_of_TMApoints</span><span class="p">:],</span>
                                           <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">data_array</span><span class="p">[</span><span class="n">ii</span><span class="o">-</span><span class="n">number_of_TMApoints</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">argmin</span><span class="p">(),</span> 
                                           <span class="n">data_array</span><span class="p">[</span><span class="n">ii</span><span class="o">-</span><span class="n">number_of_TMApoints</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">argmax</span><span class="p">()]))</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>  
            <span class="n">roll_TMA</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">get_TMA_value</span><span class="p">)</span> 
            
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">roll_TMA</span><span class="p">)</span>  </div>
           
<div class="viewcode-block" id="compute_AMA"><a class="viewcode-back" href="../../../../processing.html#pycsamt.ff.processing.zcalculator.compute_AMA">[docs]</a><span class="k">def</span> <span class="nf">compute_AMA</span><span class="p">(</span><span class="n">reference_freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">z_array</span> <span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                 <span class="n">number_of_skin_depth</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">dipole_length</span> <span class="o">=</span> <span class="mf">50.</span><span class="p">,</span> 
                  <span class="o">**</span><span class="n">kwargs</span>  <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Use an adaptive-moving-average filter to estimate average apparent</span>
<span class="sd">    resistivities at a single static-correction-reference frequency. Adaptive</span>
<span class="sd">    filtering is based on ideas presented inTorres-Verdin and Bostick, 1992,</span>
<span class="sd">    Principles of spatial surface electric field filtering in magnetotellurics</span>
<span class="sd">    -electromagnetic array profiling (EMAP), Geophysics, v57, p603-622.</span>
<span class="sd">    </span>
<span class="sd">    :param reference_frequency: frequency with clean data in Hertz </span>
<span class="sd">    :type reference_frequency: float </span>
<span class="sd">    </span>
<span class="sd">    :param z_array:  array of uncorrected impedance values.</span>
<span class="sd">    :type z_array: arry_like, complex</span>
<span class="sd">    </span>
<span class="sd">    :param dipole_length: length of dipole on survey</span>
<span class="sd">    :type dipole_length: float </span>
<span class="sd">    </span>
<span class="sd">    :param number_of_skin_depth: arbitrary real constant, can be changed </span>
<span class="sd">                to any value between 1 and 10 skin depths, by experiency, </span>
<span class="sd">                value shoulb be 1&lt;= c &lt;= 4</span>
<span class="sd">    :type number_of_skin_depth: int , default is 1.</span>
<span class="sd">    </span>
<span class="sd">    :param weighted_window: bandwidth of hanning window filter lengths,</span>
<span class="sd">                           skin_depth arrays at each station.</span>
<span class="sd">    :type weighted_window: array_like </span>
<span class="sd"> </span>
<span class="sd">    :param app_rho: array of apparent resistivities in ohm.m , if not provided </span>
<span class="sd">                    will use impedance zrho to compute app_rho with reference_frequency </span>
<span class="sd">    :type app_rho: array_like </span>
<span class="sd">    </span>
<span class="sd">    :returns: windowed hanning , filtered window.</span>
<span class="sd">    :rtype: array_like </span>
<span class="sd">    </span>
<span class="sd">    .. note:: If resistivities array is provided, provided also uncorrected phase</span>
<span class="sd">            array  to compute `impedance array`.</span>
<span class="sd">    </span>
<span class="sd">    :Example:</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; from pycsamt.ff.core.processing import zcalculator as Zcc</span>
<span class="sd">        &gt;&gt;&gt; z1= np.array([2.46073791 +3.00162006j ,</span>
<span class="sd">        ...     9.74193019 +1.82209497j,</span>
<span class="sd">        ...     15.68879141 + 12.91164264j ,</span>
<span class="sd">        ...     5.84384925 +3.6899018j, </span>
<span class="sd">        ...     2.4430065  +0.57175607j])</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; reference_frequency = 8192.</span>
<span class="sd">        &gt;&gt;&gt; znew= compute_AMA(reference_frequency=8192.,</span>
<span class="sd">        ...                   number_of_skin_depth= 1., dipole_length =50.,</span>
<span class="sd">        ...                   z_array=z1)</span>
<span class="sd">        ... print(znew)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">reference_freq</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span> 
        <span class="k">raise</span> <span class="n">CSex</span><span class="o">.</span><span class="n">pyCSAMTError_frequency</span><span class="p">(</span><span class="s1">&#39;Please add your reference frequency!&#39;</span><span class="p">)</span>
        
    <span class="n">mu0</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">1e-7</span> 
    <span class="n">omega_reffreq</span>  <span class="o">=</span> <span class="mi">2</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span>  <span class="n">reference_freq</span>  
    
    <span class="n">resistivities</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;app_rho&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">phase</span> <span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;phase&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">adaptative_value</span> <span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;scale&#39;</span><span class="p">,</span> <span class="mf">10.</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">resistivities</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span> 
        <span class="k">if</span>  <span class="n">z_array</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;`Impedance` is None. could not compute&#39;</span>
                          <span class="s1">&#39; `apparent resistivities`&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">CSex</span><span class="o">.</span><span class="n">pyCSAMTError_processing</span><span class="p">(</span><span class="s1">&#39;`Impedance`  is None.&#39;</span>
                <span class="s1">&#39;Could not compute `resistivities`.&#39;</span>
                <span class="s1">&#39; Please provided at least an `impedance array`.&#39;</span><span class="p">)</span>
    
        <span class="n">resistivities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z_array</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">mu0</span> <span class="o">*</span> <span class="n">omega_reffreq</span> <span class="p">)</span>
        
    <span class="k">elif</span> <span class="n">resistivities</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">z_array</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span>
        
        <span class="k">if</span> <span class="n">phase</span> <span class="ow">is</span> <span class="kc">None</span>  <span class="ow">and</span> <span class="n">reference_freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Could not compute `impedance` without phase values&#39;</span>
                          <span class="s1">&#39; and reference frequency!&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">CSex</span><span class="o">.</span><span class="n">pyCSAMTError_processing</span><span class="p">(</span>
                <span class="s1">&#39;None Type could not be computed. &#39;</span>
                <span class="s1">&#39;Please provided phase values |reference frequency&#39;</span><span class="p">)</span>
            
        <span class="n">z_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">resistivities</span> <span class="o">*</span> <span class="n">omega_reffreq</span> <span class="o">*</span> <span class="n">mu0</span> <span class="p">)</span> <span class="o">*</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phase</span><span class="p">)</span><span class="o">+</span>  <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span> <span class="n">phase</span><span class="p">)</span> <span class="p">)</span> 
    
    <span class="c1"># compute skin depths base of uncorrected apparent resistivities</span>
    <span class="n">skin_depths</span> <span class="o">=</span> <span class="mf">503.</span> <span class="o">*</span>  <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">resistivities</span><span class="o">/</span><span class="n">reference_freq</span><span class="p">)</span>

    <span class="c1"># window_width = number_of_skin_depth * skin_depth</span>
    <span class="k">def</span> <span class="nf">adapted_skindepth</span> <span class="p">(</span><span class="n">skin_window</span><span class="p">,</span> <span class="n">scale_value</span><span class="o">=</span><span class="mf">10.</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adapted windo width and ans scale value to adapt value to be </span>
<span class="sd">        close to dipole length </span>
<span class="sd">        </span>
<span class="sd">        :param skin_window: array of skin depth 1D botstick penetration </span>
<span class="sd">                or window width </span>
<span class="sd">        :type skin_window: array_like </span>
<span class="sd">        </span>
<span class="sd">        :return: window width scaled and adapted </span>
<span class="sd">        :rtype: array_like </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Adjusted each filter  iteratively at each station</span>
        <span class="n">window_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="n">func</span><span class="o">.</span><span class="n">round_dipole_length</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">round_value</span><span class="o">=</span><span class="n">scale_value</span><span class="p">)</span> <span class="c1"># round dipole </span>
                                 <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">skin_window</span> <span class="p">])</span>
        <span class="c1">#adjusting filter width to with ten to ten range </span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span>  <span class="n">ww</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">window_width</span><span class="p">):</span> 
            <span class="k">if</span>  <span class="n">ii</span> <span class="o">==</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">ii</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">window_width</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ww</span> <span class="o">&lt;</span> <span class="n">dipole_length</span><span class="p">:</span>
                    <span class="n">window_width</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">=</span><span class="n">func</span><span class="o">.</span><span class="n">round_dipole_length</span><span class="p">(</span>
                        <span class="n">dipole_length</span><span class="p">,</span> <span class="n">round_value</span><span class="o">=</span><span class="n">scale_value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ww</span> <span class="o">&lt;</span> <span class="n">dipole_length</span><span class="p">:</span>
                <span class="n">window_width</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">=</span><span class="n">func</span><span class="o">.</span><span class="n">round_dipole_length</span><span class="p">(</span>
                    <span class="n">window_width</span><span class="p">[</span><span class="n">ii</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">ii</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="n">round_value</span> <span class="o">=</span><span class="n">scale_value</span><span class="p">)</span>

        <span class="k">return</span>  <span class="n">window_width</span>
    
    <span class="k">def</span> <span class="nf">compute_filter_length</span><span class="p">(</span><span class="n">skindepth</span><span class="p">,</span> <span class="n">ref_freq</span><span class="p">,</span> 
                              <span class="n">dipole_length</span><span class="o">=</span><span class="n">dipole_length</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param skindepth: Bostick skin depth calculated with</span>
<span class="sd">                    apparent ressistivities at each station </span>
<span class="sd">        :type skin_depth: array_like, </span>
<span class="sd">        </span>
<span class="sd">        :param ref_freq: frequency at clean data at each station </span>
<span class="sd">        :type ref_freq: float</span>
<span class="sd">        </span>
<span class="sd">        :param dipole_length: dipole length of the survey in meters </span>
<span class="sd">        :type dipole_length: float, default is 50.</span>
<span class="sd">        </span>
<span class="sd">        :return: weight factor beta j at the station </span>
<span class="sd">        :type: array_like </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">npoints</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">skindepth</span><span class="o">/</span><span class="n">dipole_length</span><span class="p">)</span> 
        <span class="c1"># adjusted width  and recompute  and adapthed width </span>
        <span class="n">npoints_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dipole_length</span> <span class="o">*</span> <span class="n">npoints</span><span class="p">,</span> <span class="n">dipole_length</span><span class="p">)</span> 
                                    
        
        <span class="n">bj</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">compute_weight_factor_betaj</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">dipole_length</span><span class="o">=</span><span class="n">dipole_length</span><span class="p">,</span> 
                                                  <span class="n">number_of_points</span><span class="o">=</span><span class="n">npoints</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                      <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span>  <span class="n">npoints_array</span><span class="p">])</span>
  
        <span class="k">return</span> <span class="n">bj</span><span class="p">,</span> <span class="n">bj</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    
    <span class="c1"># collect list of each factor of all  station </span>
    <span class="n">skin_depths</span><span class="o">=</span> <span class="n">adapted_skindepth</span><span class="p">(</span><span class="n">skin_window</span><span class="o">=</span><span class="n">skin_depths</span><span class="p">,</span>
                                   <span class="n">scale_value</span><span class="o">=</span><span class="n">adaptative_value</span><span class="p">)</span>

    <span class="n">weight_factors</span><span class="o">=</span> <span class="p">[</span><span class="n">compute_filter_length</span><span class="p">(</span><span class="n">skindepth</span> <span class="o">=</span> <span class="n">skin</span><span class="p">,</span> <span class="n">ref_freq</span><span class="o">=</span><span class="n">reference_freq</span><span class="p">,</span> 
                              <span class="n">dipole_length</span><span class="o">=</span><span class="n">dipole_length</span> <span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">skin</span> <span class="ow">in</span> <span class="n">skin_depths</span><span class="p">]</span>
    
    <span class="c1"># compute new impedance with base impedance and  list of weight factors </span>
    <span class="n">zxy_impedancef</span> <span class="o">=</span> <span class="n">compute_zxy_xk_omega</span><span class="p">(</span><span class="n">z_imp</span><span class="o">=</span><span class="n">z_array</span><span class="p">,</span> <span class="n">coeffs_bj</span><span class="o">=</span> <span class="n">weight_factors</span><span class="p">)</span>
    
    <span class="c1"># recompute new apparent resistivity </span>
    <span class="n">resistivities</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span> <span class="n">zxy_impedancef</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">mu0</span> <span class="o">*</span> <span class="n">omega_reffreq</span> <span class="p">)</span>
    
    <span class="c1"># now recompute new window width that and multiply with arbiraty constant c</span>
    <span class="n">z_bostick_depth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">zxy_impedancef</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">omega_reffreq</span> <span class="o">*</span> <span class="n">mu0</span><span class="p">)</span>
    
    <span class="n">z_bostick_depth</span><span class="o">=</span> <span class="n">adapted_skindepth</span><span class="p">(</span><span class="n">skin_window</span><span class="o">=</span><span class="n">z_bostick_depth</span><span class="p">,</span>
                                    <span class="n">scale_value</span><span class="o">=</span><span class="n">adaptative_value</span><span class="p">)</span>
    
    <span class="c1"># adaptative window width with number of skin depth </span>
    <span class="n">w_window_width</span> <span class="o">=</span> <span class="n">number_of_skin_depth</span> <span class="o">*</span> <span class="n">z_bostick_depth</span> 
    
    <span class="c1"># recompute again impedance so to get adaptative impedance </span>
    <span class="n">n_weight_factors</span><span class="o">=</span> <span class="p">[</span><span class="n">compute_filter_length</span><span class="p">(</span><span class="n">skindepth</span> <span class="o">=</span> <span class="n">skin</span><span class="p">,</span> <span class="n">ref_freq</span><span class="o">=</span><span class="n">reference_freq</span><span class="p">,</span> 
                              <span class="n">dipole_length</span><span class="o">=</span><span class="n">dipole_length</span> <span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">skin</span> <span class="ow">in</span> <span class="n">w_window_width</span><span class="p">]</span>
    
    <span class="c1">#-----------------------text will FLMA computation --------</span>
    <span class="c1"># npoints= int(w_window_width.mean()/dipole_length)</span>
    <span class="c1"># cAMA= compute_FLMA(z_array=zxy_impedancef, dipole_length=dipole_length, </span>
    <span class="c1">#                     number_of_points= npoints)</span>
    <span class="c1">#------------------------------------------------------------</span>
    <span class="n">cAMA</span> <span class="o">=</span> <span class="n">compute_zxy_xk_omega</span><span class="p">(</span><span class="n">z_imp</span><span class="o">=</span><span class="n">z_array</span><span class="p">,</span> <span class="n">coeffs_bj</span><span class="o">=</span> <span class="n">n_weight_factors</span><span class="p">)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;** </span><span class="si">{0:&lt;27}</span><span class="s1"> </span><span class="si">{1}</span><span class="s1"> </span><span class="si">{2}</span><span class="s1"> m.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;Filter&#39;s width&quot;</span><span class="p">,</span>
                                <span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">w_window_width</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span><span class="mi">2</span><span class="p">)))</span>    

    <span class="k">return</span> <span class="n">cAMA</span>  </div>

<div class="viewcode-block" id="compute_zxy_xk_omega"><a class="viewcode-back" href="../../../../processing.html#pycsamt.ff.processing.zcalculator.compute_zxy_xk_omega">[docs]</a><span class="k">def</span> <span class="nf">compute_zxy_xk_omega</span><span class="p">(</span><span class="n">z_imp</span><span class="p">,</span> <span class="n">coeffs_bj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute adaptative impedance with variable length Hanning window</span>
<span class="sd">    :param z_imp: impedance value to be filtered </span>
<span class="sd">    :type z_imp: complex </span>
<span class="sd">    </span>
<span class="sd">    :param coeff_bj: list coefficients of weighted window at each stations</span>
<span class="sd">    :type coeffs_bj : list </span>
<span class="sd">    </span>
<span class="sd">    :return: array of  new impedance filtered </span>
<span class="sd">    :rtype: complex </span>
<span class="sd">    </span>
<span class="sd">    :Example: </span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; from pycsamt.ff.processing import z_calculator as Zcc </span>
<span class="sd">        &gt;&gt;&gt; z1= np.array([2.46073791 +3.00162006j ,</span>
<span class="sd">        ...     9.74193019 +1.82209497j,</span>
<span class="sd">        ...     15.68879141 + 12.91164264j ,</span>
<span class="sd">        ...     5.84384925 +3.6899018j, </span>
<span class="sd">        ...     2.4430065  +0.57175607j])</span>
<span class="sd">        &gt;&gt;&gt; weight_betaj = [array([0.18169011, 0.81830989]), </span>
<span class="sd">        ...                array([0.02492092, 0.25, 0.47507908, 0.25]),</span>
<span class="sd">        ...                array([0.00224272, 0.02771308, 0.09220631, 0.16554531, 0.21341394,</span>
<span class="sd">        ...                0.21341394, 0.16554531, 0.09220631, 0.02771308]),</span>
<span class="sd">        ...                 array([0.05766889, 0.47116556, 0.47116556]),</span>
<span class="sd">        ...                 array([1.])]</span>
<span class="sd">        &gt;&gt;&gt; Zcc.compute_zxy_xk_omega(coeffs_bj=weight_betaj , z_imp=z1)</span>
<span class="sd">        ... [2.01364616+2.45625537j 9.16556955+4.84395488j 6.83942027+4.21606008j</span>
<span class="sd">        ...     4.80923612+2.75254645j 2.4430065 +0.57175607j]   </span>
<span class="sd">                      </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">znew_f</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">kk</span><span class="p">,</span> <span class="n">zz</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">z_imp</span><span class="p">):</span>
        <span class="n">wlen</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">coeffs_bj</span><span class="p">[</span><span class="n">kk</span><span class="p">])</span> 
        <span class="n">xk_cp</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">wlen</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">try</span> <span class="p">:</span>
            <span class="k">if</span> <span class="n">wlen</span><span class="o">%</span><span class="mi">2</span> <span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">ss</span><span class="o">=</span><span class="n">z_imp</span><span class="p">[</span><span class="n">kk</span><span class="o">-</span> <span class="n">xk_cp</span><span class="p">:</span><span class="n">kk</span><span class="o">+</span> <span class="n">xk_cp</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">coeffs_bj</span><span class="p">[</span><span class="n">kk</span><span class="p">]</span> <span class="c1"># for Python index </span>
            <span class="k">elif</span> <span class="n">wlen</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span><span class="mi">0</span> <span class="p">:</span>
                 <span class="n">ss</span><span class="o">=</span><span class="n">z_imp</span><span class="p">[</span><span class="n">kk</span><span class="o">-</span> <span class="n">xk_cp</span><span class="p">:</span><span class="n">kk</span><span class="o">+</span> <span class="n">xk_cp</span><span class="p">]</span> <span class="o">*</span> <span class="n">coeffs_bj</span><span class="p">[</span><span class="n">kk</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="c1"># check back lengh and forelength so to fill outside window with wk=0 </span>
            <span class="n">b0</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coeffs_bj</span><span class="p">[</span><span class="n">kk</span><span class="p">][:</span><span class="n">xk_cp</span><span class="p">])</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">z_imp</span><span class="p">[:</span><span class="n">kk</span><span class="p">])</span> <span class="c1"># control the pad backward</span>
            <span class="n">f0</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coeffs_bj</span><span class="p">[</span><span class="n">kk</span><span class="p">][</span><span class="n">xk_cp</span><span class="p">:])</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">z_imp</span><span class="p">[</span><span class="n">kk</span><span class="p">:])</span> <span class="c1"># control the pad forward </span>
            <span class="k">if</span> <span class="n">b0</span> <span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>               <span class="c1"># if pad doesnt not meet </span>
                <span class="n">bnew</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="n">b0</span><span class="p">),</span><span class="n">z_imp</span><span class="p">[:</span><span class="n">kk</span><span class="p">]))</span> <span class="c1"># add 0 outside </span>
            <span class="k">else</span> <span class="p">:</span><span class="n">bnew</span> <span class="o">=</span> <span class="n">z_imp</span><span class="p">[</span><span class="n">kk</span><span class="o">-</span><span class="n">xk_cp</span><span class="p">:</span><span class="n">kk</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">f0</span> <span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">fnew</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">z_imp</span><span class="p">[</span><span class="n">kk</span><span class="p">:],</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="n">f0</span><span class="p">)))</span><span class="c1">#add 0 outside the window</span>
            <span class="k">else</span> <span class="p">:</span>
                <span class="k">if</span> <span class="n">wlen</span> <span class="o">%</span><span class="mi">2</span> <span class="o">==</span><span class="mi">0</span> <span class="p">:</span> <span class="n">fnew</span><span class="o">=</span><span class="n">z_imp</span><span class="p">[</span><span class="n">kk</span><span class="p">:</span> <span class="n">kk</span> <span class="o">+</span> <span class="n">xk_cp</span><span class="p">]</span> 
                <span class="k">else</span> <span class="p">:</span> <span class="n">fnew</span><span class="o">=</span><span class="n">z_imp</span><span class="p">[</span><span class="n">kk</span><span class="p">:</span> <span class="n">kk</span> <span class="o">+</span> <span class="n">xk_cp</span> <span class="o">+</span><span class="mi">1</span><span class="p">]</span> 
    
            <span class="n">ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">bnew</span><span class="p">,</span> <span class="n">fnew</span><span class="p">))</span><span class="o">*</span> <span class="n">coeffs_bj</span><span class="p">[</span><span class="n">kk</span><span class="p">]</span>
    
        <span class="n">znew_f</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ss</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
                
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">znew_f</span><span class="p">)</span></div>

                          
<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s1">&#39;__main__&#39;</span><span class="p">:</span> 
    
    <span class="n">z1</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">2.46073791</span> <span class="o">+</span><span class="mf">3.00162006</span><span class="n">j</span> <span class="p">,</span>
         <span class="mf">9.74193019</span> <span class="o">+</span><span class="mf">1.82209497</span><span class="n">j</span><span class="p">,</span>
         <span class="mf">15.68879141</span> <span class="o">+</span> <span class="mf">12.91164264</span><span class="n">j</span> <span class="p">,</span>
         <span class="mf">5.84384925</span> <span class="o">+</span><span class="mf">3.6899018</span><span class="n">j</span><span class="p">,</span> 
         <span class="mf">2.4430065</span>  <span class="o">+</span><span class="mf">0.57175607</span><span class="n">j</span><span class="p">])</span>
    
    <span class="n">reference_frequency</span> <span class="o">=</span> <span class="mf">8192.</span>
    <span class="n">resistivities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mf">1e-7</span> <span class="o">*</span> <span class="mi">2</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">reference_frequency</span> <span class="p">)</span>
    <span class="n">dipole_length</span> <span class="o">=</span><span class="mi">50</span>
    <span class="n">znew</span><span class="o">=</span> <span class="n">compute_AMA</span><span class="p">(</span><span class="n">reference_freq</span><span class="o">=</span><span class="n">reference_frequency</span><span class="p">,</span>
                       <span class="n">number_of_skin_depth</span><span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">dipole_length</span> <span class="o">=</span><span class="mf">50.</span><span class="p">,</span>
                       <span class="n">z_array</span><span class="o">=</span><span class="n">z1</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">resistivities</span><span class="p">)</span>
    <span class="n">new_resistivities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">znew</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mf">1e-7</span> <span class="o">*</span> <span class="mi">2</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">reference_frequency</span> <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">new_resistivities</span><span class="p">)</span>
  
    
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">pyCSAMT v1.0.03 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2021, Kouadio K. Laurent.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.4.0.
    </div>
  </body>
</html>