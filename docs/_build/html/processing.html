
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Package Processing &#8212; pyCSAMT v1.0.03 documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Package Modeling" href="modeling.html" />
    <link rel="prev" title="Package CSAMT" href="csamt.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="modeling.html" title="Package Modeling"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="csamt.html" title="Package CSAMT"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">pyCSAMT v1.0.03 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="package-processing">
<h1>Package Processing<a class="headerlink" href="#package-processing" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-pycsamt.ff.processing.callffunc">
<span id="module-dispatcher"></span><h2><strong>Module Dispatcher</strong><a class="headerlink" href="#module-pycsamt.ff.processing.callffunc" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>This file is part of pyCSAMT.</p>
<p>pyCSAMT is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.</p>
<p>pyCSAMT is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.</p>
<p>You should have received a copy of the GNU Lesser General Public License
along with pyCSAMT.  If not, see &lt;<a class="reference external" href="https://www.gnu.org/licenses/">https://www.gnu.org/licenses/</a>&gt;.</p>
</div></blockquote>
<hr class="docutils" />
<p>Created on Thu Nov 26 20:55:39 2020</p>
<p>&#64;author: &#64;Daniel03</p>
<dl class="function">
<dt id="pycsamt.ff.processing.callffunc.agso_data">
<code class="sig-prename descclassname">pycsamt.ff.processing.callffunc.</code><code class="sig-name descname">agso_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/callffunc.html#agso_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.callffunc.agso_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Geological data codes processing</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version function: </span>will later deprecated</p>
</div>
</dd></dl>

<dl class="function">
<dt id="pycsamt.ff.processing.callffunc.dipole_center_position">
<code class="sig-prename descclassname">pycsamt.ff.processing.callffunc.</code><code class="sig-name descname">dipole_center_position</code><span class="sig-paren">(</span><em class="sig-param">dipole_position=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/callffunc.html#dipole_center_position"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.callffunc.dipole_center_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Generaly positions are taken at each electrode of dipole to that to easy correct data  for ploting and for
noise correction , we adjust coordinate by taking the center position that means ,
the number of points will be substract to one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dipole_position</strong> (<em>array_like</em>) – postion array at each electrodes.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>centered position value  array</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pycsamt.ff.processing.callffunc.get_array_from_reffreq">
<code class="sig-prename descclassname">pycsamt.ff.processing.callffunc.</code><code class="sig-name descname">get_array_from_reffreq</code><span class="sig-paren">(</span><em class="sig-param">array_loc</em>, <em class="sig-param">freq_array</em>, <em class="sig-param">reffreq_value</em>, <em class="sig-param">stnNames=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/callffunc.html#get_array_from_reffreq"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.callffunc.get_array_from_reffreq" title="Permalink to this definition">¶</a></dt>
<dd><p>Get array value at special frequency
:param * array_loc: dictionnary of stations , array_value e.g: S00:(ndarray,1) rho_values
:type * array_loc: dict ,
:param * freq_array: frequency array for CSAMT survey
:type * freq_array: (ndarray,1)
:param * reffreq_value: the value of frequency user want to get the value
:type * reffreq_value: int or float
:param * stnNames: list of stations names .
:type * stnNames: list</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>array_like</dt><dd><p>an array of all station with reffreq_value .
e.g reffreq_value =1024. it return all value of the array at 1024Hz frequency .</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pycsamt.ff.processing.callffunc.get_matrix_from_dict">
<code class="sig-prename descclassname">pycsamt.ff.processing.callffunc.</code><code class="sig-name descname">get_matrix_from_dict</code><span class="sig-paren">(</span><em class="sig-param">dict_array</em>, <em class="sig-param">flip_freq=False</em>, <em class="sig-param">freq_array=None</em>, <em class="sig-param">transpose=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/callffunc.html#get_matrix_from_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.callffunc.get_matrix_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to collect dictionnary  station data with values as array
and build matrix along the line, The rowlines is assumed to be frequency
and colums as stations names. If <cite>freq_array</cite> is provided , <cite>flip_freq</cite> is
not usefull.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dict_array</strong><span class="classifier">dict</span></dt><dd><p>stations dictionnary array, keys are stations names and values are
stations values on array_like.</p>
</dd>
<dt><strong>transpose</strong><span class="classifier">bool, optional</span></dt><dd><p>transpose  matrix , if true wwill transpose data and
stations should be read as rowlines and frequency as columns.
The default is False.</p>
</dd>
<dt><strong>freq_array</strong><span class="classifier">array , optional</span></dt><dd><p>array of frequency, if provided will check if frequency are range from
highest to lowest .Defalut is True</p>
</dd>
<dt><strong>flip_freq :bool, optional</strong></dt><dd><dl class="simple">
<dt>set to false if you want frequency to be lowest to highest otherwise</dt><dd><p>frequency are sorted Highest to lowest. Default is False</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray(len(stations,), len(frequency))</dt><dd><p>matrix of dictionnary values</p>
</dd>
<dt>bool,</dt><dd><p>flip_freq, ascertain if frequency array is flipped or not.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pycsamt.ff.processing.callffunc.plot_reference_frequency">
<code class="sig-prename descclassname">pycsamt.ff.processing.callffunc.</code><code class="sig-name descname">plot_reference_frequency</code><span class="sig-paren">(</span><em class="sig-param">reference_array</em>, <em class="sig-param">frequency_array</em>, <em class="sig-param">data_array</em>, <em class="sig-param">station_names=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/callffunc.html#plot_reference_frequency"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.callffunc.plot_reference_frequency" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to plot reference frequency</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_array</strong><span class="classifier">array_like,</span></dt><dd><p>array_of average_impedance Z_avg.</p>
</dd>
<dt><strong>frequency_array: array_like</strong></dt><dd><p>array of frequency on sites</p>
</dd>
<dt><strong>data_array</strong><span class="classifier">ndarray,</span></dt><dd><p>nadarray of sounding curve, ndarray(len(frequency), len(number_ofstaions).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>viewer</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pycsamt.ff.processing.callffunc.relocate_on_dict_arrays">
<code class="sig-prename descclassname">pycsamt.ff.processing.callffunc.</code><code class="sig-name descname">relocate_on_dict_arrays</code><span class="sig-paren">(</span><em class="sig-param">data_array</em>, <em class="sig-param">number_of_frequency</em>, <em class="sig-param">station_names=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/callffunc.html#relocate_on_dict_arrays"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.callffunc.relocate_on_dict_arrays" title="Permalink to this definition">¶</a></dt>
<dd><p>Put data arrays on dictionnary where keys is each station and value the array of that station.
if station_names is None , program will create name of station. if station_names is given ,
function will sorted stations names . please make sure to provide correctly station according
the disposal you want .</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>number_of_frequency</strong> (<em>array_like</em>) – array of frequency during survey</p></li>
<li><p><strong>station_names</strong> (<em>list of array_like</em>) – list of station</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>infos at data stations</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pycsamt.ff.processing.callffunc.set_stratum_on_dict">
<code class="sig-prename descclassname">pycsamt.ff.processing.callffunc.</code><code class="sig-name descname">set_stratum_on_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/callffunc.html#set_stratum_on_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.callffunc.set_stratum_on_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Process to put geocodes_strata and geocodes_structures into dictionnaries
better way to go on metaclasses merely. Thus each keys of dictionary will be
its own object.</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl>
<dt><strong>strata_dict</strong><span class="classifier">dict</span></dt><dd><blockquote>
<div><p>Disctionnary of geostrata</p>
</div></blockquote>
<dl class="simple">
<dt>structures_dict<span class="classifier">dict</span></dt><dd><p>Dictionnary of geostructures.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pycsamt.ff.processing.callffunc.straighten_cac2CSfile">
<code class="sig-prename descclassname">pycsamt.ff.processing.callffunc.</code><code class="sig-name descname">straighten_cac2CSfile</code><span class="sig-paren">(</span><em class="sig-param">data_array</em>, <em class="sig-param">component_column_section=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/callffunc.html#straighten_cac2CSfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.callffunc.straighten_cac2CSfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Sometimes head_sections of file _F2(CAC2CSAMT) provided is little
different colunms section name  according to different version .
it ‘s better to filter  and to check before returning the
correct informations we need.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>* data_array</strong><span class="classifier">ndarray</span></dt><dd><blockquote>
<div><p>data from AVG astatic file</p>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>component_column_section<span class="classifier">list</span></dt><dd><p>astactic file column comps provided</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt>array_we_need :ndarray</dt><dd><blockquote>
<div><p>same infos present in the plainty /1 Avg file</p>
</div></blockquote>
<dl class="simple">
<dt>array_other_comp<span class="classifier">pd.Core.DataFrame</span></dt><dd><p>infos include through Astatic softwares
very usefull therefore we keep it .</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pycsamt.ff.processing.callffunc.truncated_data">
<code class="sig-prename descclassname">pycsamt.ff.processing.callffunc.</code><code class="sig-name descname">truncated_data</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">number_of_reccurence</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/callffunc.html#truncated_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.callffunc.truncated_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to truncate all data according to number of frequency.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>* data</strong><span class="classifier">list, or nd.array</span></dt><dd><blockquote>
<div><p>data must be truncate.</p>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>number_of_freq<span class="classifier">int</span></dt><dd><p>number of frequency imaged.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>list</dt><dd><p>loc_list , data truncated on list.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pycsamt.ff.processing.callffunc.zstar_array_to_nan">
<code class="sig-prename descclassname">pycsamt.ff.processing.callffunc.</code><code class="sig-name descname">zstar_array_to_nan</code><span class="sig-paren">(</span><em class="sig-param">zstar_array</em>, <em class="sig-param">nan_value=nan</em>, <em class="sig-param">keep_str=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/callffunc.html#zstar_array_to_nan"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.callffunc.zstar_array_to_nan" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>* zstar_array</strong><span class="classifier">ndarray</span></dt><dd><blockquote>
<div><p>array contain unfloat converter value. the unconverter value can be a ‘*’</p>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>nan_value<span class="classifier">float or np.nan type</span></dt><dd><p>the nan_value could be any value either int, float or str.
The <em>default</em> is np.nan.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>keep_str<span class="classifier">bool, optional</span></dt><dd><p>keep the str item on your array. f keep_str is set to
false and the type nan_value is str , the program will force ‘<a href="#id5"><span class="problematic" id="id6">keep_str_</span></a>’  to True
to allow converter .
The <em>default</em> is False.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray</dt><dd><p>zstrar_array converted .</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-pycsamt.ff.processing.corr">
<span id="module-shifting"></span><h2><strong>Module Shifting</strong><a class="headerlink" href="#module-pycsamt.ff.processing.corr" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>This file is part of pyCSAMT.</p>
<p>pyCSAMT is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.</p>
<p>pyCSAMT is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.</p>
<p>You should have received a copy of the GNU Lesser General Public License
along with pyCSAMT.  If not, see &lt;<a class="reference external" href="https://www.gnu.org/licenses/">https://www.gnu.org/licenses/</a>&gt;.</p>
</div></blockquote>
<hr class="docutils" />
<p>Created on Sat Dec 12 13:55:47 2020</p>
<p>&#64;author: &#64;Daniel03</p>
<dl class="function">
<dt id="pycsamt.ff.processing.corr.interp_to_reference_freq">
<code class="sig-prename descclassname">pycsamt.ff.processing.corr.</code><code class="sig-name descname">interp_to_reference_freq</code><span class="sig-paren">(</span><em class="sig-param">freq_array</em>, <em class="sig-param">rho_array</em>, <em class="sig-param">reference_freq</em>, <em class="sig-param">plot=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/corr.html#interp_to_reference_freq"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.corr.interp_to_reference_freq" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate frequencies to the reference frequencies.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>freq_array</strong> (<em>array_like</em>) – frequency array</p></li>
<li><p><strong>reference_freq</strong> (<em>float</em>) – frequency at clean data</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="pycsamt.ff.processing.corr.shifting">
<em class="property">class </em><code class="sig-prename descclassname">pycsamt.ff.processing.corr.</code><code class="sig-name descname">shifting</code><span class="sig-paren">(</span><em class="sig-param">data_fn=None</em>, <em class="sig-param">freq_array=None</em>, <em class="sig-param">res_array=None</em>, <em class="sig-param">phase_array=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/corr.html#shifting"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.corr.shifting" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><dl class="simple">
<dt>processing class<span class="classifier">shifting processing workflow</span></dt><dd><p>coorection  class deal with  AVG Zonge station file “<a href="#id1"><span class="problematic" id="id2">*</span></a>.stn” or SEG-EDI file.</p>
</dd>
</dl>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>app_rho</strong></dt><dd></dd>
<dt><strong>frequency</strong></dt><dd></dd>
<dt><strong>phase</strong></dt><dd></dd>
<dt><strong>referencefreq</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#pycsamt.ff.processing.corr.shifting.AMA" title="pycsamt.ff.processing.corr.shifting.AMA"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AMA</span></code></a>([data_fn, dipole_length, …])</p></td>
<td><p>Adapative moving average <cite>AMA</cite> to correct apparent resistivities.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pycsamt.ff.processing.corr.shifting.FLMA" title="pycsamt.ff.processing.corr.shifting.FLMA"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FLMA</span></code></a>([data_fn, dipole_length, …])</p></td>
<td><p>Fixed length-dipole moving average <cite>FLMA</cite> to correct apparent resistivities.The FLMA filter estimates static-corrected apparent resistivities at a single reference frequency by calculating a profile of average impedances along the length of the line.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pycsamt.ff.processing.corr.shifting.TMA" title="pycsamt.ff.processing.corr.shifting.TMA"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TMA</span></code></a>([data_fn, reference_freq, …])</p></td>
<td><p>Corrected apparent resistivities with Trimmed-moving-average filter(TMA) filter.TMA estimates average apparent resistivities at a single static-correction-reference frequency.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pycsamt.ff.processing.corr.shifting.compute_fixed_and_adaptative_moving_average" title="pycsamt.ff.processing.corr.shifting.compute_fixed_and_adaptative_moving_average"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_fixed_and_adaptative_moving_average</span></code></a>(…)</p></td>
<td><p>Can use this fonction  to compute at the same time FLMA and AMA by setting only the <cite>filter func</cite> argument .</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pycsamt.ff.processing.corr.shifting.read_processing_file" title="pycsamt.ff.processing.corr.shifting.read_processing_file"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_processing_file</span></code></a>([data_fn, profile_fn, …])</p></td>
<td><p>Mehod read processing files and load attributes for use.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pycsamt.ff.processing.corr.shifting.write_corrected_edi" title="pycsamt.ff.processing.corr.shifting.write_corrected_edi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">write_corrected_edi</span></code></a>([data_fn, …])</p></td>
<td><p>Method to rewrite  edifiles with  corrected resistivities by applying filters either  <em>tma</em> (triming moving average) or <em>flma</em> fixed-length dipole moving average.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pycsamt.ff.processing.corr.shifting.AMA">
<code class="sig-name descname">AMA</code><span class="sig-paren">(</span><em class="sig-param">data_fn=None</em>, <em class="sig-param">dipole_length=50.0</em>, <em class="sig-param">number_of_skin_depth=3.0</em>, <em class="sig-param">freq_array=None</em>, <em class="sig-param">reference_freq=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/corr.html#shifting.AMA"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.corr.shifting.AMA" title="Permalink to this definition">¶</a></dt>
<dd><p>Adapative moving average <cite>AMA</cite> to correct apparent resistivities.
AMA filter estimates static-corrected apparent resistivities
at a single reference frequency by calculating a profile of average</p>
<blockquote>
<div><p>impedances along the length of the line. Sounding curves are then</p>
</div></blockquote>
<p>shifted so that they intersect the averaged profile. The highest
frequency with clean data should be selected as the static-correction
reference frequency.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>number_of_skin_depths</strong> – skin depth for filter length</p>
</dd>
</dl>
<p>:type number_of_skin_depths : int, float, default is 3.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>resistivities corrected with ama filter</p>
</dd>
</dl>
<p>:rtype:dict ,</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>for other parameters explanations
see  the docstring of <cite>FlMA</cite></p>
</div>
<ol class="arabic simple">
<li><p>read from edipath or jpath</p></li>
</ol>
<dl class="field-list">
<dt class="field-odd">Example</dt>
<dd class="field-odd"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pycsamt.ff.processing.corr</span> <span class="kn">import</span> <span class="n">shifting</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edipath</span> <span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;pyCSAMT&#39;</span><span class="p">],</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;edi&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corr_obj</span><span class="o">=</span> <span class="n">shifting</span><span class="p">(</span><span class="n">data_fn</span> <span class="o">=</span><span class="n">edipath</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corrapp</span>  <span class="o">=</span> <span class="n">corr_obj</span><span class="o">.</span><span class="n">AMA</span><span class="p">(</span><span class="n">number_of_points</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span>
<span class="gp">... </span>                            <span class="n">reference_freq</span><span class="o">=</span><span class="mf">1024.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corr_obj</span><span class="o">.</span><span class="n">_rj</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corrapp</span>
</pre></div>
</div>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>read Zonge avg file</p></li>
</ol>
<dl class="field-list">
<dt class="field-odd">Example</dt>
<dd class="field-odd"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pycsamt.ff.processing.corr</span> <span class="kn">import</span> <span class="n">shifting</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">avg_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;pyCSAMT&#39;</span><span class="p">],</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;avg&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span> <span class="n">csamt_obj</span> <span class="o">=</span><span class="n">CSAMT</span><span class="p">(</span><span class="n">data_fn</span> <span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">avg_path</span><span class="p">,</span> <span class="s1">&#39;K2.AVG&#39;</span><span class="p">),</span>
<span class="gp">... </span>                 <span class="n">profile_fn</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">avg_path</span><span class="p">,</span> <span class="s1">&#39;K2.stn&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corr_obj</span><span class="o">=</span> <span class="n">shifting</span><span class="p">(</span><span class="n">data_fn</span> <span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">avg_path</span><span class="p">,</span> <span class="s1">&#39;K2.AVG&#39;</span><span class="p">),</span>
<span class="gp">... </span>                    <span class="n">profile_fn</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">avg_path</span><span class="p">,</span> <span class="s1">&#39;K2.stn&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corrapp</span>  <span class="o">=</span> <span class="n">corr_obj</span><span class="o">.</span><span class="n">AMA</span><span class="p">(</span><span class="n">number_of_points</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">reference_freq</span><span class="o">=</span><span class="mf">8000.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">corr_obj</span><span class="o">.</span><span class="n">_rj</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">corrapp</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pycsamt.ff.processing.corr.shifting.FLMA">
<code class="sig-name descname">FLMA</code><span class="sig-paren">(</span><em class="sig-param">data_fn=None</em>, <em class="sig-param">dipole_length=50.0</em>, <em class="sig-param">number_of_dipole=5.0</em>, <em class="sig-param">reference_freq=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/corr.html#shifting.FLMA"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.corr.shifting.FLMA" title="Permalink to this definition">¶</a></dt>
<dd><p>Fixed length-dipole moving average <cite>FLMA</cite> to correct apparent
resistivities.The FLMA filter estimates static-corrected apparent
resistivities at a single reference frequency by calculating a profile
of average impedances along the length of the line. Sounding curves
are then shifted so that they intersect the averaged profile.
The highest frequency with clean data should be selected as the
static-correction reference frequency.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_fn</strong> (<em>str</em>) – full path to data file , could be[AVG|EDI|J]</p></li>
<li><p><strong>dipole_length</strong> (<em>float</em><em>, </em><em>default is 50.</em>) – value of dipole length in meters</p></li>
<li><p><strong>number_of_dipole</strong> – number of dipole to cover hanning window width</p></li>
</ul>
</dd>
</dl>
<p>:type number_of_dipole : int, float, default is 5.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reference_freq</strong> (<em>int</em><em>, </em><em>float</em>) – reference frequency at clean data , if not provided
reference will be compute automaticcally</p></li>
<li><p><strong>freq_array</strong> (<em>array_like</em>) – array of survey frequency of the field</p></li>
<li><p><strong>res_dict_arrays</strong> (<em>ndarray_array</em><em>, </em><em>dict</em><em> , </em><em>optional</em>) – resistivity array of data collected on the field,
could be a ndarray of resistivites at each frequency of each sites
or a dictionnary of array</p></li>
<li><p><strong>phase_dict_arrays</strong> (<em>ndarray</em><em>, </em><em>optional</em>) – phase values of data at each stations
could be an ndarray of phase with ndarray(len(freq),
len(nstaions)) or dictionnary of phase values at each stations.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>rho corrected at each survey sites</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dict</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>skin depth param is not to used for <cite>FLMA</cite> filter application.
It is not necessary to provide when apply for <cite>FLMA</cite> filter.</p>
</div>
</dd>
</dl>
<ol class="arabic simple">
<li><p>read from edipath or jpath</p></li>
</ol>
<dl class="field-list">
<dt class="field-odd">Example</dt>
<dd class="field-odd"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pycsamt.ff.processing.corr</span> <span class="kn">import</span> <span class="n">shifting</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edipath</span> <span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;pyCSAMT&#39;</span><span class="p">],</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;edi&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corr_obj</span><span class="o">=</span> <span class="n">shifting</span><span class="p">(</span><span class="n">data_fn</span> <span class="o">=</span><span class="n">edipath</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corrapp</span>  <span class="o">=</span> <span class="n">corr_obj</span><span class="o">.</span><span class="n">FLMA</span><span class="p">(</span><span class="n">number_of_dipole</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span>
<span class="gp">... </span>                            <span class="n">reference_freq</span><span class="o">=</span><span class="mf">1024.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corr_obj</span><span class="o">.</span><span class="n">_rj</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corrapp</span>
</pre></div>
</div>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>read Zonge avg file</p></li>
</ol>
<dl class="field-list">
<dt class="field-odd">Example</dt>
<dd class="field-odd"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pycsamt.ff.processing.corr</span> <span class="kn">import</span> <span class="n">shifting</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">avg_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;pyCSAMT&#39;</span><span class="p">],</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;avg&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span> <span class="n">csamt_obj</span> <span class="o">=</span><span class="n">CSAMT</span><span class="p">(</span><span class="n">data_fn</span> <span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">avg_path</span><span class="p">,</span> <span class="s1">&#39;K2.AVG&#39;</span><span class="p">),</span>
<span class="gp">... </span>                 <span class="n">profile_fn</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">avg_path</span><span class="p">,</span> <span class="s1">&#39;K2.stn&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corr_obj</span><span class="o">=</span> <span class="n">shifting</span><span class="p">(</span><span class="n">data_fn</span> <span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">avg_path</span><span class="p">,</span> <span class="s1">&#39;K2.AVG&#39;</span><span class="p">),</span>
<span class="gp">... </span>                    <span class="n">profile_fn</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">avg_path</span><span class="p">,</span> <span class="s1">&#39;K2.stn&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corrapp</span>  <span class="o">=</span> <span class="n">corr_obj</span><span class="o">.</span><span class="n">FLMA</span><span class="p">(</span><span class="n">number_of_dipole</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">reference_freq</span><span class="o">=</span><span class="mf">8000.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">corr_obj</span><span class="o">.</span><span class="n">_rj</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">corrapp</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pycsamt.ff.processing.corr.shifting.TMA">
<code class="sig-name descname">TMA</code><span class="sig-paren">(</span><em class="sig-param">data_fn=None</em>, <em class="sig-param">reference_freq=None</em>, <em class="sig-param">number_of_TMA_points=5.0</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/corr.html#shifting.TMA"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.corr.shifting.TMA" title="Permalink to this definition">¶</a></dt>
<dd><p>Corrected apparent resistivities with Trimmed-moving-average filter(TMA)
filter.TMA estimates average apparent resistivities at a
single static-correction-reference frequency.
if reference frequency is not provided , will find automatically.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>* data_fn</strong><span class="classifier">str</span></dt><dd><blockquote>
<div><p>path to avg file or edi file .</p>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>freq_array<span class="classifier">array_like (ndarray,1)</span></dt><dd><p>frequency array of at normalization frequency (reference value)
of all stations. station j to n .( units =  Hz )</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>res_array<span class="classifier">dict of array_like (ndarra,1)</span></dt><dd><p>dict of array of app.resistivity at reffreq. from station j to n.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>phase_array<span class="classifier">dict of array_lie(ndarray,1), dict of array of phase at reffreq.</span></dt><dd><p>from station j to n. (unit=rad)value of frequency with clean data . (unit=Hz)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>stnVSrho_loc<span class="classifier">dict</span></dt><dd><p>set of dictionnary of all app.resistivity data from station j to n . (optional)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>num_of_TMA_point  :int</dt><dd><p>window to apply filter .</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>dict</dt><dd><p>rho_corrected , value corrected with TMA filter  from station j to n.</p>
</dd>
</dl>
<ol class="arabic simple">
<li><p>corrected data from [AVG]
..</p></li>
</ol>
<dl class="field-list">
<dt class="field-odd">Example</dt>
<dd class="field-odd"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pycsamt.ff.processing.corr</span> <span class="kn">import</span> <span class="n">Shifting</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span>  <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">&quot;pyCSAMT&quot;</span><span class="p">],</span>
<span class="gp">... </span>        <span class="s1">&#39;pycsamt&#39;</span><span class="p">,</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="n">LCS01</span><span class="o">.</span><span class="n">AVG</span><span class="p">)</span>
<span class="gp">... </span><span class="n">static_cor</span> <span class="o">=</span><span class="n">shifting</span><span class="p">()</span><span class="o">.</span><span class="n">TMA</span> <span class="p">(</span><span class="n">data_fn</span><span class="o">=</span><span class="n">path</span><span class="p">,</span>
<span class="gp">... </span>                           <span class="n">reference_freq</span><span class="o">=</span><span class="mf">1024.</span><span class="p">,</span><span class="n">number_of_TMA_points</span> <span class="o">=</span><span class="mi">5</span> <span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><dl class="simple">
<dt>corrected from edifiles [EDI]</dt><dd></dd>
</dl>
</li>
</ol>
<dl class="field-list">
<dt class="field-odd">Example</dt>
<dd class="field-odd"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pycsamt.ff.core.cs</span> <span class="kn">import</span> <span class="n">CSAMT</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pycsamt.ff.processing.corr</span> <span class="kn">import</span> <span class="n">Shifting</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edipath</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;C:/Users\Administrator\Desktop      est\edirewrite&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">csamt_obj</span> <span class="o">=</span><span class="n">CSAMT</span><span class="p">(</span><span class="n">edipath</span> <span class="o">=</span><span class="n">edipath</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">static_cor</span> <span class="o">=</span><span class="n">shifting</span><span class="p">()</span><span class="o">.</span><span class="n">TMA</span><span class="p">(</span> <span class="n">reference_freq</span> <span class="o">=</span><span class="mf">256.</span> <span class="p">,</span>
<span class="gp">... </span>                              <span class="n">freq_array</span> <span class="o">=</span> <span class="n">csamt_obj</span><span class="o">.</span><span class="n">freq</span> <span class="p">,</span>
<span class="gp">... </span>                              <span class="n">res_array</span> <span class="o">=</span> <span class="n">csamt_obj</span><span class="o">.</span><span class="n">resistivity</span> <span class="p">,</span>
<span class="gp">... </span>                           <span class="n">phase_array</span> <span class="o">=</span><span class="n">csamt_obj</span><span class="o">.</span><span class="n">phase</span> <span class="p">,</span>
<span class="gp">... </span>                           <span class="n">number_of_TMA_points</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">... </span><span class="nb">print</span><span class="p">(</span><span class="n">static_cor</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pycsamt.ff.processing.corr.shifting.compute_fixed_and_adaptative_moving_average">
<code class="sig-name descname">compute_fixed_and_adaptative_moving_average</code><span class="sig-paren">(</span><em class="sig-param">filterfunc</em>, <em class="sig-param">data_fn=None</em>, <em class="sig-param">profile_fn=None</em>, <em class="sig-param">dipole_length=50.0</em>, <em class="sig-param">reference_freq=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/corr.html#shifting.compute_fixed_and_adaptative_moving_average"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.corr.shifting.compute_fixed_and_adaptative_moving_average" title="Permalink to this definition">¶</a></dt>
<dd><p>Can use this fonction  to compute at the same time FLMA and AMA by
setting only the <cite>filter func</cite> argument . If the function is used
set the param <cite>filterfunc</cite> to the filter we need. Avoid repetition
in the code Later.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filterfunc</strong> (<em>obj</em>) – filter fonction , can be <span class="xref std std-ref">filter-AMA</span> or
<span class="xref std std-ref">filter-FLMA</span></p></li>
<li><p><strong>data_fn</strong> (<em>str</em>) – full path to data file , could be[AVG|EDI|J]</p></li>
<li><p><strong>dipole_length</strong> (<em>float</em><em>, </em><em>default is 50.</em>) – value of dipole length in meters</p></li>
<li><p><strong>number_of_skin_depths</strong> – skin depth for filter length</p></li>
</ul>
</dd>
</dl>
<p>:type number_of_skin_depths : int, float, default is 5.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>reference_freq</strong> (<em>int</em><em>, </em><em>float</em>) – reference frequency at clean data , if not provided
reference will be compute automaticcally</p>
</dd>
</dl>
<ol class="arabic simple">
<li><p>compute fixed length dipole moving average FLMA</p></li>
</ol>
<dl class="field-list">
<dt class="field-odd">Example</dt>
<dd class="field-odd"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pycsamt.ff.processing.corr</span> <span class="kn">import</span> <span class="n">shifting</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edipath</span> <span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;pyCSAMT&#39;</span><span class="p">],</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;edi&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corr_obj</span><span class="o">=</span> <span class="n">shifting</span><span class="p">(</span><span class="n">data_fn</span> <span class="o">=</span><span class="n">edipath</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_flma_obj</span>  <span class="o">=</span> <span class="n">corr_obj</span><span class="o">.</span><span class="n">compute_fixed_and_adaptative_moving_average</span><span class="p">(</span>
<span class="go">    filterfunc=Zcc.compute_FLMA,  number_of_points=7,</span>
<span class="gp">... </span>                            <span class="n">reference_freq</span><span class="o">=</span><span class="mf">8192.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corr_obj</span><span class="o">.</span><span class="n">_rj</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_flma_obj</span>
</pre></div>
</div>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>compute adaptative moving-average AMA</p></li>
</ol>
<dl class="field-list">
<dt class="field-odd">Example</dt>
<dd class="field-odd"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pycsamt.ff.processing.corr</span> <span class="kn">import</span> <span class="n">shifting</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edipath</span> <span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;pyCSAMT&#39;</span><span class="p">],</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;edi&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corr_obj</span><span class="o">=</span> <span class="n">shifting</span><span class="p">(</span><span class="n">data_fn</span> <span class="o">=</span><span class="n">edipath</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_ama_obj</span>   <span class="o">=</span> <span class="n">corr_obj</span><span class="o">.</span><span class="n">compute_fixed_and_adaptative_moving_average</span><span class="p">(</span>
<span class="go">    filterfunc=Zcc.compute_FLMA,  number_of_skin_depth=7,</span>
<span class="gp">... </span>                            <span class="n">reference_freq</span><span class="o">=</span><span class="mf">8192.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corr_obj</span><span class="o">.</span><span class="n">_rj</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_ama_obj</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pycsamt.ff.processing.corr.shifting.read_processing_file">
<code class="sig-name descname">read_processing_file</code><span class="sig-paren">(</span><em class="sig-param">data_fn=None</em>, <em class="sig-param">profile_fn=None</em>, <em class="sig-param">reference_freq=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/corr.html#shifting.read_processing_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.corr.shifting.read_processing_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Mehod read processing files and load attributes for use.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_fn</strong> (<em>str</em>) – full path to data file ,  coulb be <cite>avg</cite> of
Zonge International Engineering  or <cite>edi</cite>  of Society of Exploration
Geophysics or <cite>j|dat</cite> format of AG.Jones MT.</p></li>
<li><p><strong>profile_fn</strong> (<em>str</em>) – full path to station profile file. It’s compulsory
to provide this file when read avgfile.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pycsamt.ff.processing.corr.shifting.write_corrected_edi">
<code class="sig-name descname">write_corrected_edi</code><span class="sig-paren">(</span><em class="sig-param">data_fn=None</em>, <em class="sig-param">reference_frequency=None</em>, <em class="sig-param">FILTER='tma'</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/corr.html#shifting.write_corrected_edi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.corr.shifting.write_corrected_edi" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to rewrite  edifiles with  corrected resistivities
by applying filters either  <em>tma</em> (triming moving average) or
<em>flma</em> fixed-length dipole moving average. <cite>ama</cite> adaptative moving
average is not available yet for Electromagnetic Array Profilin(EMAP).
To apply filter for MT data , set <cite>FILTER</cite> arguments to <cite>ss</cite>  for
static shift removal and  <cite>dist</cite> for  distortion removal. It’s possible
to apply EMPA filters MT data by setting <cite>datatype</cite> argument to “mt”.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_fn</strong> (<em>str</em>) – full path to edifiles</p></li>
<li><p><strong>FILTER</strong> (<em>str</em><em>, </em><em>default is`tma`</em>) – type of filter to write, can be <cite>tma</cite> or <cite>flma</cite>  for EMAP
data or <cite>ss</cite> (remove static schift) or <cite>dist</cite>
(remove distortion)for MT data . <em>Default</em> is <cite>tma</cite> assume
data provided are EMAP data.</p></li>
</ul>
</dd>
<dt class="field-even">Reference_frequency</dt>
<dd class="field-even"><p>refrequency at clean data, optional when apply for
filter <cite>ss</cite> and <cite>dist</cite>.</p>
</dd>
</dl>
<p>Holds others parameters:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 14%" />
<col style="width: 56%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Params</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>filename</p></td>
<td><p>str</p></td>
<td><p>name of output edifiles</p></td>
</tr>
<tr class="row-odd"><td><p>number_of_points</p></td>
<td><p>int</p></td>
<td><p>weighted window. <em>Default</em> is 7.
if one edifile is provided , change
weigthed point to 1.</p></td>
</tr>
<tr class="row-even"><td><p>dipole_length</p></td>
<td><p>float</p></td>
<td><p>length of dipole. <em>Default</em> is 50.m</p></td>
</tr>
<tr class="row-odd"><td><p>reduce_res_factor_x</p></td>
<td><p>float</p></td>
<td><p>static shift factor to be applied to x
components (ie z[:, 0, :]).  This is
assumed to be in resistivity scale</p></td>
</tr>
<tr class="row-even"><td><p>reduce_res_factor_y</p></td>
<td><p>float</p></td>
<td><p>static shift factor to be applied to y
components (ie z[:, 1, :]).  This is
assumed to be in resistivity scale</p></td>
</tr>
<tr class="row-odd"><td><p>distortion_tensor</p></td>
<td><p>ndarray</p></td>
<td><p>real distortion tensor as a 2x2,
np.ndarray(2, 2, dtype=real)</p></td>
</tr>
<tr class="row-even"><td><p>distortion_err_tensor</p></td>
<td><p>ndarray</p></td>
<td><p>real distortion tensor error as a 2x2
np.ndarray(2, 2, dtype=real)</p></td>
</tr>
<tr class="row-odd"><td><p>datatype</p></td>
<td><p>str</p></td>
<td><p>type of data provided . Could be <cite>mt</cite>
or  <cite>emap</cite>. Detect automatically
if <cite>None</cite>.</p></td>
</tr>
<tr class="row-even"><td><p>savepath</p></td>
<td><p>str</p></td>
<td><p>full path to save outputfile.</p></td>
</tr>
</tbody>
</table>
<ol class="arabic simple">
<li><p>corrected single edifile</p></li>
</ol>
<dl class="field-list">
<dt class="field-odd">Example</dt>
<dd class="field-odd"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pycsamt.ff.processing</span> <span class="kn">import</span> <span class="n">shifting</span>
<span class="gp">&gt;&gt;&gt; </span> <span class="n">edifile</span> <span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;pyCSAMT&#39;</span><span class="p">],</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span>
<span class="gp">... </span>                          <span class="s1">&#39;edi&#39;</span><span class="p">,</span> <span class="s1">&#39;new_csa000.edi&#39;</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corr_obj</span><span class="o">=</span> <span class="n">shifting</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corr_obj</span><span class="o">.</span><span class="n">write_corrected_edi</span><span class="p">(</span><span class="n">data_fn</span> <span class="o">=</span> <span class="n">edifile</span><span class="p">,</span> <span class="n">number_of_points</span> <span class="o">=</span><span class="mf">1.</span><span class="p">,</span>
<span class="gp">... </span>                            <span class="n">dipole_length</span> <span class="o">=</span><span class="mf">50.</span><span class="p">,</span> <span class="n">FILTER</span><span class="o">=</span><span class="s1">&#39;ss&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>corrected multi edifiles EMAP</p></li>
</ol>
<dl class="field-list">
<dt class="field-odd">Example</dt>
<dd class="field-odd"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pycsamt.ff.processing</span> <span class="kn">import</span> <span class="n">shifting</span>
<span class="gp">&gt;&gt;&gt; </span> <span class="n">edipath</span> <span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;pyCSAMT&#39;</span><span class="p">],</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;edi&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corr_obj</span><span class="o">=</span> <span class="n">shifting</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corr_obj</span><span class="o">.</span><span class="n">write_corrected_edi</span><span class="p">(</span><span class="n">data_fn</span> <span class="o">=</span> <span class="n">edipath</span><span class="p">,</span>
<span class="gp">... </span>                            <span class="n">number_of_points</span> <span class="o">=</span><span class="mf">7.</span><span class="p">,</span>
<span class="gp">... </span>                            <span class="n">dipole_length</span> <span class="o">=</span><span class="mf">50.</span><span class="p">,</span>
<span class="gp">... </span>                               <span class="n">FILTER</span><span class="o">=</span><span class="s1">&#39;flma&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pycsamt.ff.processing.zcalculator">
<span id="module-zcalculator"></span><h2><strong>Module ZCalculator</strong><a class="headerlink" href="#module-pycsamt.ff.processing.zcalculator" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>This file is part of pyCSAMT.</p>
<p>pyCSAMT is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.</p>
<p>pyCSAMT is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.</p>
<p>You should have received a copy of the GNU Lesser General Public License
along with pyCSAMT.  If not, see &lt;<a class="reference external" href="https://www.gnu.org/licenses/">https://www.gnu.org/licenses/</a>&gt;.</p>
</div></blockquote>
<hr class="docutils" />
<p>Created on Thu Dec  3 16:44:29 2020</p>
<p>&#64;author: &#64;Daniel03</p>
<dl class="function">
<dt id="pycsamt.ff.processing.zcalculator.comp_phz">
<code class="sig-prename descclassname">pycsamt.ff.processing.zcalculator.</code><code class="sig-name descname">comp_phz</code><span class="sig-paren">(</span><em class="sig-param">comphz_array</em>, <em class="sig-param">units='deg'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/zcalculator.html#comp_phz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.zcalculator.comp_phz" title="Permalink to this definition">¶</a></dt>
<dd><p>PHZc are from each data block, units in rad</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>comphz_array</strong> (<em>float</em>) – average parameters phase for data blocs.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>component phase averaged.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>component phase averaged.</p>
</dd>
<dt class="field-even">Example</dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span>  <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">&quot;pyCSAMT&quot;</span><span class="p">],</span>
<span class="gp">... </span>             <span class="s1">&#39;csamtpy&#39;</span><span class="p">,</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;K1.AVG&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pycsamt.core</span> <span class="kn">import</span> <span class="n">avg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phs_obj</span> <span class="o">=</span><span class="n">avg</span><span class="o">.</span><span class="n">Phase</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phs_obj</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;S00&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">value</span><span class="p">,</span> <span class="n">ss</span> <span class="o">=</span> <span class="n">comp_phz</span><span class="p">(</span><span class="n">comphz_array</span><span class="o">=</span><span class="n">phs_obj</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
<span class="gp">... </span>           <span class="s1">&#39;S00&#39;</span><span class="p">],</span> <span class="n">to_degree</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">... </span><span class="nb">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pycsamt.ff.processing.zcalculator.comp_rho">
<code class="sig-prename descclassname">pycsamt.ff.processing.zcalculator.</code><code class="sig-name descname">comp_rho</code><span class="sig-paren">(</span><em class="sig-param">mag_E_field</em>, <em class="sig-param">mag_H_field</em>, <em class="sig-param">freq_array</em>, <em class="sig-param">A_spacing</em>, <em class="sig-param">Txcurr</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/zcalculator.html#comp_rho"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.zcalculator.comp_rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to compute component average
unit in in ohm.m</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mag_E_field</strong> (<em>np.ndarray</em><em>(</em><em>ndarray</em><em>,</em><em>1</em><em>)</em>) – magnitude of E-filed , averaged</p></li>
<li><p><strong>mag_H_field</strong> (<em>np.ndarray</em><em>(</em><em>ndarray</em><em>,</em><em>1</em><em>)</em>) – magnitude of H-Field ,  averaged</p></li>
<li><p><strong>freq_array</strong> (<em>np.ndarray</em><em>(</em><em>ndarray</em><em>,</em><em>1</em><em>)</em>) – frequency of station field</p></li>
<li><p><strong>A_spacing</strong> (<em>np.float</em>) – step_between station</p></li>
<li><p><strong>Txcurr</strong> (<em>np.float</em><em>,</em>) – distance of coil in meter</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>comp_rho , component averaged rho.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pycsamt.ff.processing.zcalculator.compute_AMA">
<code class="sig-prename descclassname">pycsamt.ff.processing.zcalculator.</code><code class="sig-name descname">compute_AMA</code><span class="sig-paren">(</span><em class="sig-param">reference_freq=None</em>, <em class="sig-param">z_array=None</em>, <em class="sig-param">number_of_skin_depth=1.0</em>, <em class="sig-param">dipole_length=50.0</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/zcalculator.html#compute_AMA"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.zcalculator.compute_AMA" title="Permalink to this definition">¶</a></dt>
<dd><p>Use an adaptive-moving-average filter to estimate average apparent
resistivities at a single static-correction-reference frequency. Adaptive
filtering is based on ideas presented inTorres-Verdin and Bostick, 1992,
Principles of spatial surface electric field filtering in magnetotellurics
-electromagnetic array profiling (EMAP), Geophysics, v57, p603-622.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reference_frequency</strong> (<em>float</em>) – frequency with clean data in Hertz</p></li>
<li><p><strong>z_array</strong> (<em>arry_like</em><em>, </em><em>complex</em>) – array of uncorrected impedance values.</p></li>
<li><p><strong>dipole_length</strong> (<em>float</em>) – length of dipole on survey</p></li>
<li><p><strong>number_of_skin_depth</strong> (<em>int</em><em> , </em><em>default is 1.</em>) – arbitrary real constant, can be changed
to any value between 1 and 10 skin depths, by experiency,
value shoulb be 1&lt;= c &lt;= 4</p></li>
<li><p><strong>weighted_window</strong> (<em>array_like</em>) – bandwidth of hanning window filter lengths,
skin_depth arrays at each station.</p></li>
<li><p><strong>app_rho</strong> (<em>array_like</em>) – array of apparent resistivities in ohm.m , if not provided
will use impedance zrho to compute app_rho with reference_frequency</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>windowed hanning , filtered window.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If resistivities array is provided, provided also uncorrected phase
array  to compute <cite>impedance array</cite>.</p>
</div>
<dl class="field-list">
<dt class="field-odd">Example</dt>
<dd class="field-odd"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pycsamt.ff.core.processing</span> <span class="kn">import</span> <span class="n">zcalculator</span> <span class="k">as</span> <span class="n">Zcc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z1</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">2.46073791</span> <span class="o">+</span><span class="mf">3.00162006</span><span class="n">j</span> <span class="p">,</span>
<span class="gp">... </span>    <span class="mf">9.74193019</span> <span class="o">+</span><span class="mf">1.82209497</span><span class="n">j</span><span class="p">,</span>
<span class="gp">... </span>    <span class="mf">15.68879141</span> <span class="o">+</span> <span class="mf">12.91164264</span><span class="n">j</span> <span class="p">,</span>
<span class="gp">... </span>    <span class="mf">5.84384925</span> <span class="o">+</span><span class="mf">3.6899018</span><span class="n">j</span><span class="p">,</span>
<span class="gp">... </span>    <span class="mf">2.4430065</span>  <span class="o">+</span><span class="mf">0.57175607</span><span class="n">j</span><span class="p">])</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reference_frequency</span> <span class="o">=</span> <span class="mf">8192.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">znew</span><span class="o">=</span> <span class="n">compute_AMA</span><span class="p">(</span><span class="n">reference_frequency</span><span class="o">=</span><span class="mf">8192.</span><span class="p">,</span>
<span class="gp">... </span>                  <span class="n">number_of_skin_depth</span><span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">dipole_length</span> <span class="o">=</span><span class="mf">50.</span><span class="p">,</span>
<span class="gp">... </span>                  <span class="n">z_array</span><span class="o">=</span><span class="n">z1</span><span class="p">)</span>
<span class="gp">... </span><span class="nb">print</span><span class="p">(</span><span class="n">znew</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pycsamt.ff.processing.zcalculator.compute_FLMA">
<code class="sig-prename descclassname">pycsamt.ff.processing.zcalculator.</code><code class="sig-name descname">compute_FLMA</code><span class="sig-paren">(</span><em class="sig-param">z_array=None</em>, <em class="sig-param">weighted_window=None</em>, <em class="sig-param">dipole_length=50.0</em>, <em class="sig-param">number_of_points=5.0</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/zcalculator.html#compute_FLMA"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.zcalculator.compute_FLMA" title="Permalink to this definition">¶</a></dt>
<dd><p>Use a fixed-length-moving-average filter to estimate average apparent
resistivities at a single static-correction-reference frequency</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>z_array</strong> (<em>arry_like</em><em>, </em><em>complex</em>) – array of uncorrected impedance values.</p></li>
<li><p><strong>dipole_length</strong> (<em>float</em>) – length of dipole on survey</p></li>
<li><p><strong>number_of_points</strong> (<em>int</em>) – survey point or number point to apply.</p></li>
<li><p><strong>weighted_window</strong> (<em>array_like</em>) – bandwidth of hanning window filter lengths,
skin_depth arrays at each station.</p></li>
<li><p><strong>app_rho</strong> (<em>array_like</em>) – array of apparent resistivities in ohm.m , if not provided
will use impedance zrho to compute app_rho with reference_frequency</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>windowed hanning , filtered window.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
<dt class="field-even">Example</dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pycsamt.ff.core.processing</span> <span class="kn">import</span> <span class="n">zcalculator</span> <span class="k">as</span> <span class="n">Zcc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z1</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">2.46073791</span> <span class="o">+</span><span class="mf">3.00162006</span><span class="n">j</span> <span class="p">,</span>
<span class="gp">... </span>            <span class="mf">9.74193019</span> <span class="o">+</span><span class="mf">1.82209497</span><span class="n">j</span><span class="p">,</span>
<span class="gp">... </span>            <span class="mf">15.68879141</span> <span class="o">+</span> <span class="mf">12.91164264</span><span class="n">j</span> <span class="p">,</span>
<span class="gp">... </span>            <span class="mf">5.84384925</span> <span class="o">+</span><span class="mf">3.6899018</span><span class="n">j</span><span class="p">,</span>
<span class="gp">... </span>            <span class="mf">2.4430065</span>  <span class="o">+</span><span class="mf">0.57175607</span><span class="n">j</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flma</span><span class="o">=</span> <span class="n">compute_FLMA</span><span class="p">(</span><span class="n">z_array</span><span class="o">=</span><span class="n">z1</span><span class="p">,</span> <span class="n">dipole_length</span><span class="o">=</span><span class="mf">50.</span> <span class="p">,</span>
<span class="go">                       number_of_points=4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">flma</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pycsamt.ff.processing.zcalculator.compute_TMA">
<code class="sig-prename descclassname">pycsamt.ff.processing.zcalculator.</code><code class="sig-name descname">compute_TMA</code><span class="sig-paren">(</span><em class="sig-param">data_array=None</em>, <em class="sig-param">number_of_TMApoints=5.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/zcalculator.html#compute_TMA"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.zcalculator.compute_TMA" title="Permalink to this definition">¶</a></dt>
<dd><p>function to compute a trimmed-moving-average filter
to estimate average apparent resistivities.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_array</strong> (<em>array_like</em><em>(</em><em>ndarray</em><em>,</em><em>1</em><em>)</em>) – content of value to be trimmed</p></li>
<li><p><strong>points</strong> (<em>number_of_TMA</em>) – number of filter points .</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>value corrected with TMA</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array_like (ndarray, 1)</p>
</dd>
<dt class="field-even">Example</dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pycsamt.ff.core.processing</span> <span class="kn">import</span> <span class="n">zcalculator</span> <span class="k">as</span> <span class="n">Zcc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">2.46073791</span> <span class="p">,</span> <span class="mf">3.00162006</span> <span class="p">,</span>
<span class="gp">... </span>    <span class="mf">9.74193019</span> <span class="p">])</span><span class="c1"># 1.82209497,</span>
<span class="gp">... </span>    <span class="c1"># 15.68879141 ,  12.91164264 ,</span>
<span class="gp">... </span>    <span class="c1"># 5.84384925 , 3.6899018,</span>
<span class="gp">... </span>    <span class="c1"># 2.4430065  ,0.57175607])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tma</span><span class="o">=</span> <span class="n">Zcc</span><span class="o">.</span><span class="n">compute_TMA</span><span class="p">(</span><span class="n">data_array</span><span class="o">=</span><span class="n">z2</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="n">number_of_TMApoints</span><span class="o">=</span> <span class="mi">7</span><span class="p">)</span>
<span class="gp">... </span><span class="nb">print</span><span class="p">(</span><span class="n">tma</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pycsamt.ff.processing.zcalculator.compute_adaptative_moving_average">
<code class="sig-prename descclassname">pycsamt.ff.processing.zcalculator.</code><code class="sig-name descname">compute_adaptative_moving_average</code><span class="sig-paren">(</span><em class="sig-param">z_array=None</em>, <em class="sig-param">weighted_window=None</em>, <em class="sig-param">dipole_length=None</em>, <em class="sig-param">number_of_points=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/zcalculator.html#compute_adaptative_moving_average"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.zcalculator.compute_adaptative_moving_average" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition note">
<p class="admonition-title">Note</p>
<p>see <cite>compute_AMA</cite> !</p>
</div>
</dd></dl>

<dl class="function">
<dt id="pycsamt.ff.processing.zcalculator.compute_components_Z_Phz">
<code class="sig-prename descclassname">pycsamt.ff.processing.zcalculator.</code><code class="sig-name descname">compute_components_Z_Phz</code><span class="sig-paren">(</span><em class="sig-param">magn_E_field</em>, <em class="sig-param">magn_H_field</em>, <em class="sig-param">phz_E_field</em>, <em class="sig-param">phz_H_field</em>, <em class="sig-param">freq_value</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/zcalculator.html#compute_components_Z_Phz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.zcalculator.compute_components_Z_Phz" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to compute all components  derived from Impedance Z.
user can  enter specifik units in kwargs arguments . program will compute and converts value
automatically.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>* magn_E_field</strong><span class="classifier">np.ndarray</span></dt><dd><blockquote>
<div><p><a href="#id7"><span class="problematic" id="id8">E_</span></a>.field magnitude (ndarray,1) in  microV/KM*A</p>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>magn_H_field<span class="classifier">np.ndarray</span></dt><dd><p><a href="#id9"><span class="problematic" id="id10">H_</span></a>.field magnitude (ndarray,1)in  mGammas/A or picoTesla/A</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>phz_E_field<span class="classifier">np.ndarray</span></dt><dd><p>E_field phase (ndarray, 1) in  mrad</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>phz_H_field<span class="classifier">np.ndarray</span></dt><dd><p>H_field phase (ndarray,1) in  mrad.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>freq_value<span class="classifier">np.ndarray</span></dt><dd><p>Frequency at which data was measured(ndarray,1)in  Hz</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>kwargs<span class="classifier">str</span></dt><dd><p>units conversion.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt>rho: ndarray</dt><dd><blockquote>
<div><p>Cagnard resistivity calculation. ohm.m</p>
</div></blockquote>
<dl class="simple">
<dt>phz: ndarray</dt><dd><p>Impedance phase value.</p>
</dd>
<dt>Zij: ndarray</dt><dd><p>Impedance Tensor value.</p>
</dd>
<dt>Zreal: ndarray</dt><dd><p>Value of Real part of impedance Tensor.</p>
</dd>
<dt>Zimag: float</dt><dd><p>Value of Imaginary part of impedance Tensor.</p>
</dd>
<dt>Zreal_imag: ndarray , complex</dt><dd><p>Complex value of impedance Tensor.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list">
<dt class="field-odd">Example</dt>
<dd class="field-odd"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pycsamt.core</span> <span class="kn">import</span> <span class="n">avg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span>  <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">&quot;pyCSAMT&quot;</span><span class="p">],</span>
<span class="gp">... </span>             <span class="n">data</span><span class="s1">&#39;, &#39;</span><span class="n">avg</span><span class="s1">&#39;, &#39;</span><span class="n">K1</span><span class="o">.</span><span class="n">AVG</span><span class="s1">&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">emag_ob</span> <span class="o">=</span> <span class="n">avg</span><span class="o">.</span><span class="n">Emag</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hmag_obj</span> <span class="o">=</span> <span class="n">avg</span><span class="o">.</span><span class="n">Hmag</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ephz_obj</span> <span class="o">=</span> <span class="n">avg</span><span class="o">.</span><span class="n">Ephz</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hphz_obj</span> <span class="o">=</span> <span class="n">avg</span><span class="o">.</span><span class="n">Hphz</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq_obj</span> <span class="o">=</span><span class="n">avg</span><span class="o">.</span><span class="n">Frequency</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">station_name</span> <span class="o">=</span><span class="s1">&#39;S00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span><span class="p">,</span> <span class="n">phz</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">real</span><span class="p">,</span> <span class="n">imag</span><span class="p">,</span> <span class="n">comp</span> <span class="o">=</span><span class="n">compute_components_Z_Phz</span><span class="p">(</span>
<span class="gp">... </span>   <span class="n">magn_E_field</span><span class="o">=</span><span class="n">emag_ob</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">station_name</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="n">magn_H_field</span> <span class="o">=</span><span class="n">hmag_obj</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">station_name</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="n">phz_E_field</span> <span class="o">=</span><span class="n">ephz_obj</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">station_name</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="n">phz_H_field</span><span class="o">=</span><span class="n">hphz_obj</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">station_name</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="n">freq_value</span><span class="o">=</span><span class="n">freq_obj</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">station_name</span><span class="p">])</span>
<span class="gp">... </span><span class="n">rho</span>
</pre></div>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><dl class="simple">
<dt>CSex.pyCSAMTError_z(),</dt><dd><p>Exceptions if units entered by the user doesnt match or are messy.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pycsamt.ff.processing.zcalculator.compute_sigmas_e_h_and_sigma_rho">
<code class="sig-prename descclassname">pycsamt.ff.processing.zcalculator.</code><code class="sig-name descname">compute_sigmas_e_h_and_sigma_rho</code><span class="sig-paren">(</span><em class="sig-param">pc_emag</em>, <em class="sig-param">pc_hmag</em>, <em class="sig-param">pc_app_rho</em>, <em class="sig-param">app_rho</em>, <em class="sig-param">emag</em>, <em class="sig-param">hmag</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/zcalculator.html#compute_sigmas_e_h_and_sigma_rho"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.zcalculator.compute_sigmas_e_h_and_sigma_rho" title="Permalink to this definition">¶</a></dt>
<dd><p>function to compute Standard Deviation for E-field (sigma_e),
Standard Deviation for H-Field (sigma_h) ,
&amp; Standard Deviation for Component RHO (sigma_rho)</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>* pc_emag</strong><span class="classifier">float</span></dt><dd><blockquote>
<div><p>Statistical variation of magnitude values from averaged data blocks.
Standard Deviation/Average Emag (%)</p>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>pc_hmag :float</dt><dd><p>Statistical variation of magnitude values from averaged data blocks.
Standard Deviation / Average Hmag (%)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>pc_app_rho: float</dt><dd><p>Statistical variation of magnitude values from averaged data blocks.
Standard Deviation / Average Rho (%)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>app_rho :float</dt><dd><p>resistivity calculated from averaged component (ohm.m)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Emag<span class="classifier">float</span></dt><dd><p>average E - field magnitude(microVolt/Km <a href="#id3"><span class="problematic" id="id4">*</span></a>amp )</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Hmag<span class="classifier">float</span></dt><dd><p>average H - field magnitude(pTesta/amp) or (milliGammas/Amp)</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>sigma_rho</strong><span class="classifier">float</span></dt><dd><blockquote>
<div><p>srhoC (Standard Deviation for Component RHO)</p>
</div></blockquote>
<dl class="simple">
<dt>c_var_Rho<span class="classifier">float</span></dt><dd><p>C-varrhoC(  Coefficient of Variation for Component RHO)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pycsamt.ff.processing.zcalculator.compute_trimming_moving_average">
<code class="sig-prename descclassname">pycsamt.ff.processing.zcalculator.</code><code class="sig-name descname">compute_trimming_moving_average</code><span class="sig-paren">(</span><em class="sig-param">data_array=None</em>, <em class="sig-param">number_of_TMApoints=5.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/zcalculator.html#compute_trimming_moving_average"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.zcalculator.compute_trimming_moving_average" title="Permalink to this definition">¶</a></dt>
<dd><p>function to compute a trimmed-moving-average filter
to estimate average apparent resistivities.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_array</strong> (<em>array_like</em><em>(</em><em>ndarray</em><em>,</em><em>1</em><em>)</em>) – content of value to be trimmed</p></li>
<li><p><strong>points</strong> (<em>number_of_TMA</em>) – number of filter points .</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>value corrected with TMA</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array_like (ndarray, 1)</p>
</dd>
<dt class="field-even">Example</dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pycsamt.ff.core.processing</span> <span class="kn">import</span> <span class="n">zcalculator</span> <span class="k">as</span> <span class="n">Zcc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">2.46073791</span> <span class="p">,</span> <span class="mf">3.00162006</span> <span class="p">,</span>
<span class="gp">... </span>    <span class="mf">9.74193019</span> <span class="p">])</span><span class="c1"># 1.82209497,</span>
<span class="gp">... </span>    <span class="c1"># 15.68879141 ,  12.91164264 ,</span>
<span class="gp">... </span>    <span class="c1"># 5.84384925 , 3.6899018,</span>
<span class="gp">... </span>    <span class="c1"># 2.4430065  ,0.57175607])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tma</span><span class="o">=</span> <span class="n">Zcc</span><span class="o">.</span><span class="n">compute_TMA</span><span class="p">(</span><span class="n">data_array</span><span class="o">=</span><span class="n">z2</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="n">number_of_TMApoints</span><span class="o">=</span> <span class="mi">7</span><span class="p">)</span>
<span class="gp">... </span><span class="nb">print</span><span class="p">(</span><span class="n">tma</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pycsamt.ff.processing.zcalculator.compute_weight_factor_betaj">
<code class="sig-prename descclassname">pycsamt.ff.processing.zcalculator.</code><code class="sig-name descname">compute_weight_factor_betaj</code><span class="sig-paren">(</span><em class="sig-param">Xpos</em>, <em class="sig-param">dipole_length=50.0</em>, <em class="sig-param">number_of_points=5.0</em>, <em class="sig-param">window_width=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/zcalculator.html#compute_weight_factor_betaj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.zcalculator.compute_weight_factor_betaj" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>weight Beta is  computed following the paper of Torres-verdfn, C., and F. X. Bostick, 1992,</dt><dd><p>Principles of spatial surface electric field filtering in magnetotellurics - Electromagnetic</p>
</dd>
</dl>
<p>array profiling ( EMAP )- Geophysics, 57(4), 25–34.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xpos</strong> (<em>str</em>) – reference position on the field</p></li>
<li><p><strong>dipole_length</strong> (<em>float</em>) – length of dipole measurement</p></li>
<li><p><strong>number_of_points</strong> (<em>int</em>) – point to stand filters , windowed width</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pycsamt.ff.processing.zcalculator.compute_zxy_xk_omega">
<code class="sig-prename descclassname">pycsamt.ff.processing.zcalculator.</code><code class="sig-name descname">compute_zxy_xk_omega</code><span class="sig-paren">(</span><em class="sig-param">z_imp</em>, <em class="sig-param">coeffs_bj</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/zcalculator.html#compute_zxy_xk_omega"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.zcalculator.compute_zxy_xk_omega" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute adaptative impedance with variable length Hanning window
:param z_imp: impedance value to be filtered
:type z_imp: complex</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>coeff_bj</strong> – list coefficients of weighted window at each stations</p>
</dd>
</dl>
<p>:type coeffs_bj : list</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>array of  new impedance filtered</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>complex</p>
</dd>
<dt class="field-odd">Example</dt>
<dd class="field-odd"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pycsamt.ff.processing</span> <span class="kn">import</span> <span class="n">z_calculator</span> <span class="k">as</span> <span class="n">Zcc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z1</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">2.46073791</span> <span class="o">+</span><span class="mf">3.00162006</span><span class="n">j</span> <span class="p">,</span>
<span class="gp">... </span>    <span class="mf">9.74193019</span> <span class="o">+</span><span class="mf">1.82209497</span><span class="n">j</span><span class="p">,</span>
<span class="gp">... </span>    <span class="mf">15.68879141</span> <span class="o">+</span> <span class="mf">12.91164264</span><span class="n">j</span> <span class="p">,</span>
<span class="gp">... </span>    <span class="mf">5.84384925</span> <span class="o">+</span><span class="mf">3.6899018</span><span class="n">j</span><span class="p">,</span>
<span class="gp">... </span>    <span class="mf">2.4430065</span>  <span class="o">+</span><span class="mf">0.57175607</span><span class="n">j</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weight_betaj</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span><span class="p">([</span><span class="mf">0.18169011</span><span class="p">,</span> <span class="mf">0.81830989</span><span class="p">]),</span>
<span class="gp">... </span>               <span class="n">array</span><span class="p">([</span><span class="mf">0.02492092</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.47507908</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">]),</span>
<span class="gp">... </span>               <span class="n">array</span><span class="p">([</span><span class="mf">0.00224272</span><span class="p">,</span> <span class="mf">0.02771308</span><span class="p">,</span> <span class="mf">0.09220631</span><span class="p">,</span> <span class="mf">0.16554531</span><span class="p">,</span> <span class="mf">0.21341394</span><span class="p">,</span>
<span class="gp">... </span>               <span class="mf">0.21341394</span><span class="p">,</span> <span class="mf">0.16554531</span><span class="p">,</span> <span class="mf">0.09220631</span><span class="p">,</span> <span class="mf">0.02771308</span><span class="p">]),</span>
<span class="gp">... </span>                <span class="n">array</span><span class="p">([</span><span class="mf">0.05766889</span><span class="p">,</span> <span class="mf">0.47116556</span><span class="p">,</span> <span class="mf">0.47116556</span><span class="p">]),</span>
<span class="gp">... </span>                <span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">])]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Zcc</span><span class="o">.</span><span class="n">compute_zxy_xk_omega</span><span class="p">(</span><span class="n">coeffs_bj</span><span class="o">=</span><span class="n">weight_betaj</span> <span class="p">,</span> <span class="n">z_imp</span><span class="o">=</span><span class="n">z1</span><span class="p">)</span>
<span class="gp">... </span><span class="p">[</span><span class="mf">2.01364616</span><span class="o">+</span><span class="mf">2.45625537</span><span class="n">j</span> <span class="mf">9.16556955</span><span class="o">+</span><span class="mf">4.84395488</span><span class="n">j</span> <span class="mf">6.83942027</span><span class="o">+</span><span class="mf">4.21606008</span><span class="n">j</span>
<span class="gp">... </span>    <span class="mf">4.80923612</span><span class="o">+</span><span class="mf">2.75254645</span><span class="n">j</span> <span class="mf">2.4430065</span> <span class="o">+</span><span class="mf">0.57175607</span><span class="n">j</span><span class="p">]</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pycsamt.ff.processing.zcalculator.find_reference_frequency">
<code class="sig-prename descclassname">pycsamt.ff.processing.zcalculator.</code><code class="sig-name descname">find_reference_frequency</code><span class="sig-paren">(</span><em class="sig-param">freq_array=None</em>, <em class="sig-param">reffreq_value=None</em>, <em class="sig-param">sharp=False</em>, <em class="sig-param">etching=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/zcalculator.html#find_reference_frequency"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.zcalculator.find_reference_frequency" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to find and interpolate reference value if it is not present on the frequency range.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>freq_array</strong> (<em>array_like</em>) – array_like frequency range</p></li>
<li><p><strong>reffreq_value</strong> (<em>float</em><em> or </em><em>int</em>) – reference frequency value</p></li>
<li><p><strong>sharp</strong> (<em>bool</em>) – if set to True , it forces the program to find mainly
a value closest inside the  frequency range.</p></li>
<li><p><strong>etching</strong> (<em>bool</em>) – bool , if set to True , it will print in your stdout.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>reference frequency</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pycsamt.ff.processing.zcalculator.get_data_from_reference_frequency">
<code class="sig-prename descclassname">pycsamt.ff.processing.zcalculator.</code><code class="sig-name descname">get_data_from_reference_frequency</code><span class="sig-paren">(</span><em class="sig-param">array_loc</em>, <em class="sig-param">freq_array</em>, <em class="sig-param">reffreq_value</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/zcalculator.html#get_data_from_reference_frequency"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.zcalculator.get_data_from_reference_frequency" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to get reference frequency  without call especially stations array.
The function is profitable but . It’s less expensive However if something wrong happened
by using the first step to get a reference array , it will try the traditionnally function
to get it. If none value is found , an Error will
occurs.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>array_loc</strong> (<em>dict</em>) – assume to be a dictionnary of stations_data_values.</p></li>
<li><p><strong>freq_array</strong> (<em>array_like</em>) – frequency array</p></li>
<li><p><strong>reffreq_value</strong> (<em>float</em><em> or </em><em>int</em>) – reffrence value, If the reference value is not in frequency array ,
function will force to interpolate value and find the correlative array.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>an array of reference value at specific index</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
<dt class="field-even">Example</dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">get_data_from_reference_frequency</span><span class="p">(</span><span class="n">array_loc</span><span class="o">=</span><span class="n">rho</span><span class="p">,</span><span class="n">freq_array</span><span class="o">=</span><span class="n">freq_array</span><span class="p">,</span>
<span class="gp">... </span>                                     <span class="n">reffreq_value</span><span class="o">=</span><span class="mf">1023.</span><span class="p">)</span>
<span class="gp">... </span><span class="n">Input</span> <span class="n">reference</span> <span class="n">frequency</span> <span class="n">has</span> <span class="n">been</span> <span class="n">interpolated</span> <span class="n">to</span> <span class="o">&lt;</span> <span class="mf">1024.0</span> <span class="o">&gt;</span> <span class="n">Hz</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pycsamt.ff.processing.zcalculator.get_reffreq_index">
<code class="sig-prename descclassname">pycsamt.ff.processing.zcalculator.</code><code class="sig-name descname">get_reffreq_index</code><span class="sig-paren">(</span><em class="sig-param">freq_array</em>, <em class="sig-param">reffreq_value</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/zcalculator.html#get_reffreq_index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.zcalculator.get_reffreq_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the index of reference index. From this index ,All array will filter data at this reffreq
value .
:param freq_array: array of frequency values
:type freq_array: array_like</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>reffreq_value</strong> (<em>float</em><em>, </em><em>int</em>) – value of frequency at clean data</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pycsamt.ff.processing.zcalculator.hanning">
<code class="sig-prename descclassname">pycsamt.ff.processing.zcalculator.</code><code class="sig-name descname">hanning</code><span class="sig-paren">(</span><em class="sig-param">dipole_length=50.0</em>, <em class="sig-param">number_of_points=7</em>, <em class="sig-param">large_band=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/zcalculator.html#hanning"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.zcalculator.hanning" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to compute hanning window .</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dipole_length</strong> (<em>float</em>) – the length of dipole , xk is centered between dipole</p></li>
<li><p><strong>number_of_points</strong> (<em>int</em>) – number of filter points</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>windowed hanning</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pycsamt.ff.processing.zcalculator.hanning_x">
<code class="sig-prename descclassname">pycsamt.ff.processing.zcalculator.</code><code class="sig-name descname">hanning_x</code><span class="sig-paren">(</span><em class="sig-param">x_point_value</em>, <em class="sig-param">dipole_length=50.0</em>, <em class="sig-param">number_of_points=7</em>, <em class="sig-param">bandwidth_values=False</em>, <em class="sig-param">on_half=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/zcalculator.html#hanning_x"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.zcalculator.hanning_x" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to compute point on window width .  Use discrete computing . Function show the value
at center point of window assume that the point is center locate on the window width .
It intergrates  value between dipole length. User can use see_extraband to see the values
on the total bandwith. If half is False the value of greater than center point will be
computed and not be 0 as the normal definition of Hanning window filter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_point_value</strong> (<em>float</em>) – value  to intergrate.</p></li>
<li><p><strong>dipole_length</strong> (<em>float</em>) – length of dipole on survey</p></li>
<li><p><strong>number_of_point</strong> (<em>int</em>) – survey point or number point to apply.</p></li>
<li><p><strong>bandwidth_values</strong> – see all value on the bandwith , value greater than x_center
point will be computed .</p></li>
</ul>
</dd>
</dl>
<p>:type bandwidth_values:bool</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>on_half</strong> (<em>bool</em>) – value on the bandwith; value greater that x_center point = 0.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>hannx  integrated X_point_value or  array of window bandwidth .</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pycsamt.ff.processing.zcalculator.hanning_xk">
<code class="sig-prename descclassname">pycsamt.ff.processing.zcalculator.</code><code class="sig-name descname">hanning_xk</code><span class="sig-paren">(</span><em class="sig-param">dipole_length=50.0</em>, <em class="sig-param">number_of_points=7</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/zcalculator.html#hanning_xk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.zcalculator.hanning_xk" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>compute _hanning window on a wtdth of number of point :</dt><dd><p>integrate value on all the window_bandwidth discrete and continue.
if value is greater than Hald of the width  value == 0 .</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dipole_length</strong> (<em>float</em>) – length of dipole</p></li>
<li><p><strong>number_of_points</strong> (<em>int</em>) – value of points or survey stations .</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>han_xk , continue value on half bandwidth x0– xk (center point)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>windowed hanning, discrete _value ,SUM(han(x0, xk))</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pycsamt.ff.processing.zcalculator.interpolate_sets">
<code class="sig-prename descclassname">pycsamt.ff.processing.zcalculator.</code><code class="sig-name descname">interpolate_sets</code><span class="sig-paren">(</span><em class="sig-param">array_to</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">array_size=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/zcalculator.html#interpolate_sets"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.zcalculator.interpolate_sets" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to interpolate data contain of multiple nan values.</p>
</dd></dl>

<dl class="function">
<dt id="pycsamt.ff.processing.zcalculator.mag_avg">
<code class="sig-prename descclassname">pycsamt.ff.processing.zcalculator.</code><code class="sig-name descname">mag_avg</code><span class="sig-paren">(</span><em class="sig-param">mag_array</em>, <em class="sig-param">A_spacing</em>, <em class="sig-param">Txcur</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/zcalculator.html#mag_avg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.zcalculator.mag_avg" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>RAW, E-, or H-field magnitude values)for each frequency</dt><dd><p>units : mV/Km*</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mag_array</strong> (<em>np.array</em><em> (</em><em>ndarray</em><em>, </em><em>1</em><em>)</em><em>,</em>) – magnnitude value for each data block</p></li>
<li><p><strong>a_spacing</strong> (<em>float</em>) – dipole length</p></li>
<li><p><strong>txcur</strong> – curv coil, transmitter length</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>averaged data of magnitude data Block</p>
</dd>
<dt class="field-odd">Rtype mag_avg</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pycsamt.ff.processing.zcalculator.param_phz">
<code class="sig-prename descclassname">pycsamt.ff.processing.zcalculator.</code><code class="sig-name descname">param_phz</code><span class="sig-paren">(</span><em class="sig-param">pphz_array</em>, <em class="sig-param">to_degree=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/zcalculator.html#param_phz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.zcalculator.param_phz" title="Permalink to this definition">¶</a></dt>
<dd><p>PHZn are from each data block ,  units in  mrad</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pphz_array</strong> (<em>array_like</em>) – average parameters phase for data blocs.</p></li>
<li><p><strong>to_degree</strong> (<em>bool</em>) – ascertain convertion to degree</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pycsamt.ff.processing.zcalculator.param_rho">
<code class="sig-prename descclassname">pycsamt.ff.processing.zcalculator.</code><code class="sig-name descname">param_rho</code><span class="sig-paren">(</span><em class="sig-param">rho_array</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/zcalculator.html#param_rho"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.zcalculator.param_rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Parameter Average RHO (RHOp), RHO are from each data block, unit ( ohm.m)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>rho_array</strong> (<em>array_like</em>) – array of resistivity values</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pycsamt.ff.processing.zcalculator.perforce_reference_freq">
<code class="sig-prename descclassname">pycsamt.ff.processing.zcalculator.</code><code class="sig-name descname">perforce_reference_freq</code><span class="sig-paren">(</span><em class="sig-param">dataset</em>, <em class="sig-param">frequency_array=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/zcalculator.html#perforce_reference_freq"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.zcalculator.perforce_reference_freq" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to get automatically the reference frequency. If user doesnt provide the value ,
function will find automatically value .</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>array_like</em>) – array of avg DATA,  ndim&gt;1</p></li>
<li><p><strong>frequency_array</strong> (<em>array_like</em>) – array of frequency</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>reffreq_value float , reference frequency value</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>uncover_index,  index of reference value on frequency array</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>nan_ratio , the ratio or the prevalence of nan in the data_set</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pycsamt.ff.processing.zcalculator.phz_avg">
<code class="sig-prename descclassname">pycsamt.ff.processing.zcalculator.</code><code class="sig-name descname">phz_avg</code><span class="sig-paren">(</span><em class="sig-param">phz_array</em>, <em class="sig-param">to_degree</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/zcalculator.html#phz_avg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.zcalculator.phz_avg" title="Permalink to this definition">¶</a></dt>
<dd><p>E-, H-field, or Impedance Phase values unit in  mrad</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>phz_array</strong> (<em>array_like</em>) – array of phase values in mrad</p></li>
<li><p><strong>to_degree</strong> (<em>bool</em>) – ascertain convertion to degree</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pycsamt.ff.processing.zcalculator.rhophi2z">
<code class="sig-prename descclassname">pycsamt.ff.processing.zcalculator.</code><code class="sig-name descname">rhophi2z</code><span class="sig-paren">(</span><em class="sig-param">phase</em>, <em class="sig-param">freq</em>, <em class="sig-param">resistivity=None</em>, <em class="sig-param">z_array=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/zcalculator.html#rhophi2z"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.zcalculator.rhophi2z" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to compute z , real part and imag part .</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>phase</strong> (<em>ndarray</em>) – phase angles array in radians</p></li>
<li><p><strong>freq</strong> (<em>array_like</em>) – frequencies array in Hz</p></li>
<li><p><strong>resistivity</strong> (<em>array_like</em>) – rho array in ohm.m</p></li>
<li><p><strong>z_array</strong> (<em>array_like</em>) – impedance z array in V/m</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>z_abs , absolute value of zz</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>z_real, real part of complex number</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>z_imag, imaginary part of zz</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>complex</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>zz, array of z_abs, z_imag, z_real</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pycsamt.ff.processing.zcalculator.wbetaX2">
<code class="sig-prename descclassname">pycsamt.ff.processing.zcalculator.</code><code class="sig-name descname">wbetaX2</code><span class="sig-paren">(</span><em class="sig-param">Xpos</em>, <em class="sig-param">dipole_length=50.0</em>, <em class="sig-param">number_of_points=5</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/zcalculator.html#wbetaX2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.zcalculator.wbetaX2" title="Permalink to this definition">¶</a></dt>
<dd><p>weight Beta is  computed following the paper of
Torres-verdfn, C., and F. X. Bostick, 1992, Principles of spatial surface electric field
filtering in magnetotellurics - Electromagnetic array profiling ( EMAP )- Geophysics, 57(4), 25–34.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xpos</strong> (<em>str</em>) – reference position on the field</p></li>
<li><p><strong>dipole_length</strong> (<em>float</em>) – length of dipole measurement</p></li>
<li><p><strong>number_of_points</strong> (<em>int</em>) – point to stand filters , window width</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pycsamt.ff.processing.zcalculator.weight_beta">
<code class="sig-prename descclassname">pycsamt.ff.processing.zcalculator.</code><code class="sig-name descname">weight_beta</code><span class="sig-paren">(</span><em class="sig-param">dipole_length=50.0</em>, <em class="sig-param">number_of_points=7</em>, <em class="sig-param">window_width=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/zcalculator.html#weight_beta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.zcalculator.weight_beta" title="Permalink to this definition">¶</a></dt>
<dd><p>WeightBeta function is  weight Hanning window . if window width is not provide  , function
will compute the width of window.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Torres-Verdin and Bostick, 1992, Principles of spatial surface electric field filtering in
magnetotellurics: electromagnetic array profiling (EMAP), Geophysics, v57, p603-622.
…</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dipole_length</strong> (<em>float</em>) – length of dipole in meter (m)</p></li>
<li><p><strong>number_of_points</strong> (<em>int</em>) – number of station points to filter</p></li>
<li><p><strong>window_width</strong> (<em>float</em>) – the width of window filter</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>beta_array at each station</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pycsamt.ff.processing.zcalculator.z_error2r_phi_error">
<code class="sig-prename descclassname">pycsamt.ff.processing.zcalculator.</code><code class="sig-name descname">z_error2r_phi_error</code><span class="sig-paren">(</span><em class="sig-param">z_real</em>, <em class="sig-param">z_imag</em>, <em class="sig-param">error</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycsamt/ff/processing/zcalculator.html#z_error2r_phi_error"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycsamt.ff.processing.zcalculator.z_error2r_phi_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Error estimation from rectangular to polar coordinates.
By standard error propagation, relative error in resistivity is
2*relative error in z amplitude.
Uncertainty in phase (in degrees) is computed by defining a circle around
the z vector in the complex plane. The uncertainty is the absolute angle
between the vector to (x,y) and the vector between the origin and the
tangent to the circle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>z_real</strong> (<em>float</em>) – real component of z (real number or array)</p></li>
<li><p><strong>z_imag</strong> (<em>complex</em>) – imaginary component of z (real number or array)</p></li>
<li><p><strong>error</strong> (<em>float</em>) – absolute error in z (real number or array)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>containers of relative error in resistivity, absolute error in phase</p>
</dd>
<dt class="field-odd">Rtupe</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Package Processing</a><ul>
<li><a class="reference internal" href="#module-pycsamt.ff.processing.callffunc"><strong>Module Dispatcher</strong></a></li>
<li><a class="reference internal" href="#module-pycsamt.ff.processing.corr"><strong>Module Shifting</strong></a></li>
<li><a class="reference internal" href="#module-pycsamt.ff.processing.zcalculator"><strong>Module ZCalculator</strong></a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="csamt.html"
                        title="previous chapter">Package CSAMT</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="modeling.html"
                        title="next chapter">Package Modeling</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/processing.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="modeling.html" title="Package Modeling"
             >next</a> |</li>
        <li class="right" >
          <a href="csamt.html" title="Package CSAMT"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">pyCSAMT v1.0.03 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2021, Kouadio K. Laurent.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.4.0.
    </div>
  </body>
</html>