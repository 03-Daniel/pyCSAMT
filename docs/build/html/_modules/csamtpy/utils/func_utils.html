
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>csamtpy.utils.func_utils &#8212; pyCSAMT v1.0.01 documentation</title>
    <link rel="stylesheet" href="../../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">pyCSAMT v1.0.01 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for csamtpy.utils.func_utils</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">===============================================================================</span>
<span class="sd">    Copyright Â© 2021  Kouadio K.Laurent</span>
<span class="sd">    </span>
<span class="sd">    This file is part of pyCSAMT.</span>
<span class="sd">    </span>
<span class="sd">    pyCSAMT is free software: you can redistribute it and/or modify</span>
<span class="sd">    it under the terms of the GNU Lesser General Public License as published by</span>
<span class="sd">    the Free Software Foundation, either version 3 of the License, or</span>
<span class="sd">    (at your option) any later version.</span>
<span class="sd">    </span>
<span class="sd">    pyCSAMT is distributed in the hope that it will be useful,</span>
<span class="sd">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="sd">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="sd">    GNU Lesser General Public License for more details.</span>
<span class="sd">    </span>
<span class="sd">    You should have received a copy of the GNU Lesser General Public License</span>
<span class="sd">    along with pyCSAMT.  If not, see &lt;https://www.gnu.org/licenses/&gt;.</span>

<span class="sd">===============================================================================  </span>

<span class="sd">     .helpers functions </span>
<span class="sd">     </span>
<span class="sd">Created on Sun Sep 13 09:24:00 2020</span>

<span class="sd">@author: KouaoLaurent alias @Daniel03</span>

<span class="sd">    functions :</span>
<span class="sd">        * averageData **</span>
<span class="sd">        * concat_array_from_list **</span>
<span class="sd">        * sort_array_data **</span>
<span class="sd">        * transfer_array_ (deprecated)</span>
<span class="sd">        * interpol_scipy **</span>
<span class="sd">        * _set_depth_to_coeff **</span>
<span class="sd">        * broke_array_to_ **</span>
<span class="sd">        *  _OlDFUNCNOUSEsearch_fill_data (deprecated)</span>
<span class="sd">        * _search_ToFill_Data **</span>
<span class="sd">        * straighten_out_list ** </span>
<span class="sd">        * take_firstValue_offDepth **</span>
<span class="sd">        * dump_comma **</span>
<span class="sd">        * build_wellData **</span>
<span class="sd">        * compute_azimuth **</span>
<span class="sd">        * build_geochemistry_sample **</span>
<span class="sd">        * _nonelist_checker ** </span>
<span class="sd">        * _order_well **</span>
<span class="sd">        * intell_index **</span>
<span class="sd">        * _nonevalue_checker **</span>
<span class="sd">        * _clean_space ***</span>
<span class="sd">        *_cross_eraser ***</span>
<span class="sd">        * _remove_str_word **</span>
<span class="sd">        * stn_check_split_type **</span>
<span class="sd">        * minimum_parser_to_write_edi **</span>
<span class="sd">        </span>
<span class="sd">               </span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1">####################### import modules #######################</span>

<span class="kn">import</span> <span class="nn">os</span> 
<span class="kn">import</span> <span class="nn">shutil</span> 
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">import</span>  <span class="nn">csamtpy.utils.gis_tools</span> <span class="k">as</span> <span class="nn">gis</span>
<span class="kn">from</span> <span class="nn">csamtpy.utils.decorator</span> <span class="kn">import</span> <span class="n">deprecated</span> 

<span class="c1"># import deprecated</span>
<span class="c1"># set logger #</span>
<span class="kn">from</span> <span class="nn">csamtpy.utils._csamtpylog</span> <span class="kn">import</span> <span class="n">csamtpylog</span>
<span class="n">_logger</span> <span class="o">=</span> <span class="n">csamtpylog</span><span class="o">.</span><span class="n">get_csamtpy_logger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="c1"># _logger.setLevel(logging.DEBUG)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">scipy</span>

    <span class="n">scipy_version</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">ss</span><span class="p">)</span> <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">scipy</span><span class="o">.</span><span class="n">__version__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">scipy_version</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">scipy_version</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">14</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Note: need scipy version 0.14.0 or higher or interpolation &#39;</span>
                          <span class="s1">&#39;might not work.&#39;</span><span class="p">,</span> <span class="ne">ImportWarning</span><span class="p">)</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Note: need scipy version 0.14.0 or higher or interpolation &#39;</span>
                            <span class="s1">&#39;might not work.&#39;</span><span class="p">)</span>
    <span class="kn">import</span> <span class="nn">scipy.interpolate</span> <span class="k">as</span> <span class="nn">spi</span>

    <span class="n">interp_import</span> <span class="o">=</span> <span class="kc">True</span>

<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Could not find scipy.interpolate, cannot use method interpolate&#39;</span>
                  <span class="s1">&#39;check installation you can get scipy from scipy.org.&#39;</span><span class="p">)</span>
    <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Could not find scipy.interpolate, cannot use method interpolate&#39;</span>
                    <span class="s1">&#39;check installation you can get scipy from scipy.org.&#39;</span><span class="p">)</span>
    <span class="n">interp_import</span> <span class="o">=</span> <span class="kc">False</span>

<span class="c1">###################### end import module ################################### </span>


<div class="viewcode-block" id="averageData"><a class="viewcode-back" href="../../../utils.html#csamtpy.utils.func_utils.averageData">[docs]</a><span class="k">def</span> <span class="nf">averageData</span><span class="p">(</span><span class="n">np_array</span><span class="p">,</span> <span class="n">filter_order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> 
                <span class="n">axis_average</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">astype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">):</span> <span class="c1">#array_of_average_array=0</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    parameters  :</span>
<span class="sd">    -----------</span>
<span class="sd">        *np_array * : numpy array </span>
<span class="sd">            must be an array data </span>
<span class="sd">        *filter_order * : int </span>
<span class="sd">            must be the index of the column you want to sort </span>
<span class="sd">            </span>
<span class="sd">        * axis average * : int , </span>
<span class="sd">            axis you want to see data averaged, also , it is the concatenate axis  </span>
<span class="sd">            default is axis=0 </span>
<span class="sd">        </span>
<span class="sd">        * astype* : str , </span>
<span class="sd">            is the ndarray dtype array .</span>
<span class="sd">            change to have an outup arry dtype , you want .</span>
<span class="sd">    </span>
<span class="sd">    return : </span>
<span class="sd">    --------</span>
<span class="sd">        numpy array </span>
<span class="sd">            Data averaged array</span>
<span class="sd">    </span>
<span class="sd">    Example :</span>
<span class="sd">        if __name__==&quot;__main__&quot;:</span>
<span class="sd">        &gt;&gt;&gt;list8=[[4,2,0.1],[8,2,0.7],[10,1,0.18],[4,3,0.1],</span>
<span class="sd">                       [7,2,1.2],[10,3,0.5],[10,1,0.5],[8.2,0,1.9],</span>
<span class="sd">                       [10,7,0.5],[10,1,0.5],</span>
<span class="sd">                       [2,0,1.4],[5,4,0.5],[10,2,0.7],[7,2,1.078],</span>
<span class="sd">                       [10,2,3.5],[10,8,1.9]]</span>

<span class="sd">        np_test=np.array(list8)</span>
<span class="sd">        ss=averageData(np_array=np_test,filter_order=1,</span>
<span class="sd">                       axis_average=0, astype=&quot;int&quot;)</span>
<span class="sd">        print(ss)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">idx</span><span class="p">,</span><span class="n">sep_counts</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
    <span class="n">global_list</span><span class="o">=</span><span class="p">[]</span>
    <span class="c1">#Filter the array </span>
    <span class="n">np_array</span><span class="o">=</span><span class="n">np_array</span><span class="p">[</span><span class="n">np_array</span><span class="p">[:,</span><span class="n">filter_order</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s2">&quot;mergesort&quot;</span><span class="p">)]</span>
    <span class="c1">#returns the differents value on the filtersort index of array :</span>
    <span class="n">values</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np_array</span><span class="p">[:,</span><span class="n">filter_order</span><span class="p">],</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># append array with numpy :(values.shape)</span>
    <span class="c1">#             # new_array=np.append(new_array,rowline,axis=0)</span>
    <span class="k">for</span> <span class="n">rowline</span> <span class="ow">in</span> <span class="n">np_array</span> <span class="p">:</span>
        
        <span class="k">if</span> <span class="n">rowline</span><span class="p">[</span><span class="n">filter_order</span><span class="p">]</span> <span class="o">==</span><span class="n">values</span><span class="o">.</span><span class="n">max</span><span class="p">():</span>
            <span class="n">new_array</span><span class="o">=</span><span class="n">np_array</span><span class="p">[</span><span class="n">sep_counts</span><span class="p">:,:]</span>
            <span class="n">temp_array</span><span class="o">=</span><span class="n">new_array</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis_average</span><span class="p">)</span>
            <span class="n">temp_array</span><span class="o">=</span><span class="n">temp_array</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">temp_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">global_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp_array</span><span class="p">)</span>
            <span class="k">break</span>        
        <span class="k">elif</span> <span class="n">rowline</span><span class="p">[</span><span class="n">filter_order</span><span class="p">]</span> <span class="o">!=</span><span class="n">np_array</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">filter_order</span><span class="p">]:</span>
            <span class="n">new_array</span><span class="o">=</span><span class="n">np_array</span><span class="p">[</span><span class="n">sep_counts</span><span class="p">:</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">,:]</span>
            
            <span class="n">temp_array</span><span class="o">=</span><span class="n">new_array</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis_average</span><span class="p">)</span>
            <span class="n">temp_array</span><span class="o">=</span><span class="n">temp_array</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">temp_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">global_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp_array</span><span class="p">)</span>
            <span class="n">sep_counts</span><span class="o">=</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span>

            
        <span class="n">idx</span><span class="o">=</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span>
    
    <span class="n">np_out_put</span><span class="o">=</span><span class="n">concat_array_from_list</span><span class="p">(</span><span class="n">list_of_array</span><span class="o">=</span><span class="n">global_list</span><span class="p">,</span>
                                      <span class="n">concat_axis</span><span class="o">=</span><span class="n">axis_average</span><span class="p">)</span> 
    <span class="n">np_out_put</span><span class="o">=</span><span class="n">np_out_put</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">astype</span><span class="p">)</span>       

    <span class="k">return</span> <span class="n">np_out_put</span></div>


<div class="viewcode-block" id="concat_array_from_list"><a class="viewcode-back" href="../../../utils.html#csamtpy.utils.func_utils.concat_array_from_list">[docs]</a><span class="k">def</span> <span class="nf">concat_array_from_list</span><span class="p">(</span><span class="n">list_of_array</span><span class="p">,</span> <span class="n">concat_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    small function to concatenate a list with array contents </span>
<span class="sd">    </span>
<span class="sd">    parameters :</span>
<span class="sd">    -----------</span>
<span class="sd">    </span>
<span class="sd">    * list_of_array : list </span>
<span class="sd">        contains a list for array data. the concatenation is possible </span>
<span class="sd">        if an index array have the same size </span>
<span class="sd">        </span>
<span class="sd">    return : </span>
<span class="sd">    -------</span>
<span class="sd">        array </span>
<span class="sd">            numpy concatenated data </span>
<span class="sd">        </span>
<span class="sd">    e.g.:</span>
<span class="sd">        if __name__==&quot;__main__&quot;:</span>
<span class="sd">            np.random.seed(0)</span>
<span class="sd">            # ass=np.random.randn(10)</span>
<span class="sd">            # ass2=np.linspace(0,15,12)</span>
<span class="sd">            # ass=ass.reshape((ass.shape[0],1))</span>
<span class="sd">            # ass2=ass2.reshape((ass2.shape[0],1))</span>
<span class="sd">            # or_list=[ass,ass2]</span>
<span class="sd">            # ss_check_error=concat_array_from_list(list_of_array=or_list, concat_axis=0)</span>
<span class="sd">            # secont test :</span>
<span class="sd">            ass=np.linspace(0,15,14)</span>
<span class="sd">            ass2=np.random.randn(14)</span>
<span class="sd">            ass=ass.reshape((ass.shape[0],1))</span>
<span class="sd">            ass2=ass2.reshape((ass2.shape[0],1))</span>
<span class="sd">            or_list=[ass,ass2]</span>
<span class="sd">            # ss=concat_array_from_list(list_of_array=or_list, concat_axis=0)</span>
<span class="sd">            ss=concat_array_from_list(list_of_array=or_list, concat_axis=1)</span>
<span class="sd">            print(ss)</span>
<span class="sd">            print(ss.shape)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#first attemp when the len of list is ==1 :</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_of_array</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">list_of_array</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">==</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="n">output_array</span><span class="o">=</span><span class="n">list_of_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">output_array</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">concat_axis</span><span class="o">==</span><span class="mi">0</span> <span class="p">:</span>
                    <span class="n">output_array</span><span class="o">=</span><span class="n">output_array</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">output_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="k">else</span> <span class="p">:</span>
                    <span class="n">output_array</span><span class="o">=</span><span class="n">output_array</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">output_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">output_array</span>
        
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">list_of_array</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">==</span><span class="nb">list</span><span class="p">:</span>
            <span class="n">output_array</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">list_of_array</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">concat_axis</span><span class="o">==</span><span class="mi">0</span> <span class="p">:</span>
                <span class="n">output_array</span><span class="o">=</span><span class="n">output_array</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">output_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">else</span> <span class="p">:</span>
                <span class="n">output_array</span><span class="o">=</span><span class="n">output_array</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">output_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">output_array</span>
    
    <span class="c1"># check the size of array in the liste when the len of list is &gt;=2</span>
    
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span><span class="n">elt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">list_of_array</span><span class="p">)</span> <span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span><span class="o">==</span><span class="nb">list</span><span class="p">:</span>
            <span class="n">elt</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">elt</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">elt</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span><span class="mi">1</span> <span class="p">:</span>
            <span class="k">if</span> <span class="n">concat_axis</span><span class="o">==</span><span class="mi">0</span> <span class="p">:</span>
                <span class="n">elt</span><span class="o">=</span><span class="n">elt</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">elt</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">else</span> <span class="p">:</span>
                <span class="n">elt</span><span class="o">=</span><span class="n">elt</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">elt</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">list_of_array</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">=</span><span class="n">elt</span>
 

    <span class="n">output_array</span><span class="o">=</span><span class="n">list_of_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">list_of_array</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">output_array</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">output_array</span><span class="p">,</span><span class="n">ii</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">concat_axis</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">output_array</span></div>


<div class="viewcode-block" id="sort_array_data"><a class="viewcode-back" href="../../../utils.html#csamtpy.utils.func_utils.sort_array_data">[docs]</a><span class="k">def</span> <span class="nf">sort_array_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>  <span class="n">sort_order</span> <span class="o">=</span><span class="mi">0</span><span class="p">,</span>
              <span class="n">concatenate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">concat_axis_order</span><span class="o">=</span><span class="mi">0</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to sort array data and concatenate </span>
<span class="sd">    numpy.ndarray </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : numpy.ndarray </span>
<span class="sd">            must be in simple array , list of array and </span>
<span class="sd">            dictionary whom the value is numpy.ndarray </span>
<span class="sd">            </span>
<span class="sd">    sort_order : int, optional </span>
<span class="sd">            index  of colum to sort data. The default is 0.</span>
<span class="sd">    concatenate : Boolean , optional</span>
<span class="sd">            concatenate all array in the object.</span>
<span class="sd">            Must be the same dimentional if concatenate is set to True. </span>
<span class="sd">            The default is False.</span>
<span class="sd">    concat_axis_order : int, optional</span>
<span class="sd">            must the axis of concatenation  . The default is axis=0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    data : Tnumpy.ndarray</span>
<span class="sd">        Either the simple sort data or </span>
<span class="sd">        array sorted and concatenated .</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">==</span><span class="nb">list</span> <span class="p">:</span>
        <span class="k">for</span> <span class="n">ss</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">data</span> <span class="p">:</span>
            <span class="n">val</span><span class="o">=</span><span class="n">val</span><span class="p">[</span><span class="n">val</span><span class="p">[:,</span><span class="n">sort_order</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s2">&quot;mergesort&quot;</span><span class="p">)]</span>
            <span class="n">data</span><span class="p">[</span><span class="n">ss</span><span class="p">]</span><span class="o">=</span><span class="n">val</span>
            
        <span class="k">if</span> <span class="n">concatenate</span><span class="p">:</span> 
            <span class="n">data</span><span class="o">=</span><span class="n">concat_array_from_list</span><span class="p">(</span><span class="n">list_of_array</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                        <span class="n">concat_axis</span><span class="o">=</span><span class="n">concat_axis_order</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">==</span><span class="nb">dict</span><span class="p">:</span>
        
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span> 
            <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">[</span><span class="n">value</span><span class="p">[:,</span><span class="n">sort_order</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s2">&quot;mergesort&quot;</span><span class="p">)]</span>
            <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">value</span>
            
        <span class="k">if</span> <span class="n">concatenate</span><span class="o">==</span><span class="kc">True</span> <span class="p">:</span>
            <span class="n">temp_list</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="n">data</span><span class="o">=</span><span class="n">concat_array_from_list</span><span class="p">(</span><span class="n">list_of_array</span><span class="o">=</span><span class="n">temp_list</span><span class="p">,</span>
                                    <span class="n">concat_axis</span><span class="o">=</span><span class="n">concat_axis_order</span><span class="p">)</span>
    <span class="k">else</span> <span class="p">:</span> 
        <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="p">[:,</span><span class="n">sort_order</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s2">&quot;mergesort&quot;</span><span class="p">)]</span>
        
    <span class="k">return</span> <span class="n">data</span> </div>
        
<div class="viewcode-block" id="transfer_array_"><a class="viewcode-back" href="../../../utils.html#csamtpy.utils.func_utils.transfer_array_">[docs]</a><span class="nd">@deprecated</span> <span class="p">(</span><span class="s2">&quot;Function replaced to another </span><span class="si">{_search_ToFill_Data}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">transfer_array_</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index_key</span><span class="p">,</span><span class="n">start_value_depth</span><span class="p">,</span> <span class="n">end_value_depth</span><span class="p">,</span> 
                    <span class="n">column_order_selection</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span> 
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : dict</span>
<span class="sd">        Dictionnary of numpy ndarray .</span>
<span class="sd">        </span>
<span class="sd">    index_key : float </span>
<span class="sd">        key of the dictionnary . must be a number of the first column of offset .</span>
<span class="sd">        </span>
<span class="sd">    start_value_depth : float </span>
<span class="sd">        If the depth is not reach must add depth of the closest point.</span>
<span class="sd">        give the start value which match to the maxi depth of the data :</span>
<span class="sd">            The default is -214.</span>
<span class="sd">            </span>
<span class="sd">    end_value_depth : float</span>
<span class="sd">        Maximum depth of the survey. The default is -904.</span>
<span class="sd">        </span>
<span class="sd">    column_order_selection : int,</span>
<span class="sd">        the index of depth column. The default is 0.</span>
<span class="sd">    axis : int , optional</span>
<span class="sd">        numpy.ndarray axis . The default is 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        return the array data we want to top to .</span>
<span class="sd">    </span>
<span class="sd">    e.g. ::</span>
<span class="sd">        if __name__=&quot;__main__&quot;:</span>
<span class="sd">            sos=abs(np.random.randn(4,3)*4)</span>
<span class="sd">            sos2=abs(np.random.randn(4,3)*10.8)</span>
<span class="sd">            # print(sos2)</span>
<span class="sd">            sis1=sort_array_data(data=sos,sort_order =1,</span>
<span class="sd">                                concatenate=False, concat_axis_order=0)</span>
<span class="sd">            sis2=sort_array_data(data=sos2,sort_order =1,</span>
<span class="sd">                                concatenate=False, concat_axis_order=0)</span>
<span class="sd">            </span>
<span class="sd">            dico={&quot;18.4&quot;:sis1,</span>
<span class="sd">                  &quot;21.4&quot;:sis2}</span>
<span class="sd">            test=transfer_array_(data=dico, index_key=11.4, </span>
<span class="sd">                                  start_value_depth=-14, end_value_depth=23,</span>
<span class="sd">                                  column_order_selection=1)</span>
<span class="sd">            </span>
<span class="sd">            print(&quot;sis1\n:&quot;,sis1)</span>
<span class="sd">            print(&quot;sis2\n:&quot;,sis2)</span>
<span class="sd">            print(&quot;Finaltest\n&quot;, test)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">start_value_depth</span><span class="o">=</span><span class="nb">abs</span><span class="p">(</span><span class="n">start_value_depth</span><span class="p">)</span>
    <span class="n">end_value_depth</span><span class="o">=</span><span class="nb">abs</span><span class="p">(</span><span class="n">end_value_depth</span><span class="p">)</span>
    <span class="n">comp</span><span class="p">,</span> <span class="n">flag</span><span class="p">,</span><span class="n">iter_</span><span class="p">,</span><span class="n">translist_</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,[]</span>
    
   <span class="c1"># chef the depth colum if negative before enter in loop :  </span>

    <span class="k">if</span> <span class="nb">type</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">==</span><span class="nb">dict</span> <span class="p">:</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span> <span class="c1"># scroll the dictionary </span>
            <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">&gt;</span> <span class="nb">float</span><span class="p">(</span><span class="n">index_key</span><span class="p">):</span>   <span class="c1"># check the key of dictionnary</span>
                                        <span class="c1">#before using its value </span>
                <span class="n">maxi_depth</span><span class="o">=</span><span class="nb">abs</span><span class="p">(</span><span class="n">value</span><span class="p">[:,</span><span class="n">column_order_selection</span><span class="p">])</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="c1"># if yes</span>
                    <span class="c1"># calculate the max depth of the value :</span>
                <span class="n">comp</span><span class="o">=</span><span class="mi">0</span>
                <span class="k">for</span> <span class="n">rowline</span> <span class="ow">in</span> <span class="n">value</span> <span class="p">:</span> <span class="c1"># scroll the row of the array dict value</span>
                
                    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">rowline</span><span class="p">[</span><span class="n">column_order_selection</span><span class="p">])</span><span class="o">&gt;</span><span class="n">start_value_depth</span> <span class="p">:</span> <span class="c1"># check its</span>
                        <span class="c1"># print(abs(rowline[column_order_selection]))</span>

                        <span class="c1"># value and compare it to section we must start extract (start)</span>
                        <span class="k">if</span> <span class="n">end_value_depth</span> <span class="o">&gt;</span> <span class="n">maxi_depth</span><span class="p">:</span>
                            <span class="n">transData_</span><span class="o">=</span><span class="n">value</span><span class="p">[</span><span class="n">comp</span><span class="p">:,:]</span> <span class="c1"># if yes transfer data :</span>
                            <span class="c1"># print(transData_)</span>
                            <span class="n">translist_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">transData_</span><span class="p">)</span>
                            
                            <span class="n">start_value_depth</span><span class="o">=</span><span class="nb">abs</span><span class="p">(</span><span class="n">transData_</span><span class="p">[:,</span><span class="n">column_order_selection</span><span class="p">])</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
                            <span class="c1"># start_value_depth=maxi_depth</span>
                            
                            <span class="n">comp</span><span class="p">,</span><span class="n">iter_</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">iter_</span><span class="o">+</span><span class="mi">1</span>
                            <span class="n">flag</span><span class="o">=</span><span class="mi">1</span>
                            
                        <span class="k">elif</span> <span class="n">end_value_depth</span><span class="o">&lt;=</span><span class="n">maxi_depth</span><span class="p">:</span>
                            <span class="n">indix</span> <span class="o">=</span><span class="nb">abs</span><span class="p">(</span><span class="n">value</span><span class="p">[:,</span><span class="n">column_order_selection</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">end_value_depth</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">iter_</span><span class="o">==</span><span class="mi">0</span> <span class="p">:</span> 
                                <span class="n">transData_</span><span class="o">=</span><span class="n">value</span><span class="p">[</span><span class="n">comp</span><span class="p">:</span><span class="n">indix</span><span class="p">,::]</span> 
                                <span class="n">flag</span><span class="o">=</span><span class="mi">0</span>
                                <span class="k">break</span> 
                            <span class="k">else</span> <span class="p">:</span>
                                <span class="n">transData_</span><span class="o">=</span><span class="n">value</span><span class="p">[</span><span class="n">comp</span><span class="p">:</span><span class="n">indix</span><span class="p">,::]</span>
                                <span class="n">translist_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">transData_</span><span class="p">)</span>
                                <span class="n">flag</span><span class="o">=</span><span class="mi">1</span>
                                
                        <span class="k">if</span> <span class="n">start_value_depth</span> <span class="o">&gt;=</span> <span class="n">end_value_depth</span><span class="p">:</span>
                            <span class="n">flag</span><span class="o">=</span><span class="mi">1</span>
                            <span class="k">break</span>
                    <span class="k">else</span> <span class="p">:</span>
                        <span class="n">comp</span> <span class="o">+=</span><span class="mi">1</span> 
                        
    <span class="k">if</span> <span class="n">flag</span> <span class="o">==</span><span class="mi">0</span> <span class="p">:</span> 
        <span class="k">return</span> <span class="n">transData_</span>
    <span class="k">if</span> <span class="n">flag</span><span class="o">==</span><span class="mi">1</span> <span class="p">:</span> 
        <span class="n">trans_array</span><span class="o">=</span><span class="n">concat_array_from_list</span><span class="p">(</span><span class="n">list_of_array</span><span class="o">=</span><span class="n">translist_</span><span class="p">,</span> <span class="n">concat_axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">trans_array</span> 

            
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">==</span><span class="nb">list</span><span class="p">:</span> <span class="c1"># create a dictionnary of array value </span>
        <span class="n">dico</span><span class="o">=</span><span class="p">{}</span>
        <span class="k">for</span> <span class="n">ss</span><span class="p">,</span> <span class="n">value</span>  <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="n">data</span><span class="p">)</span> <span class="p">:</span>
            <span class="n">dico</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])]</span><span class="o">=</span><span class="n">value</span>
        <span class="c1"># call recursive function </span>
        <span class="n">transfer_array_</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">dico</span><span class="p">,</span><span class="n">index_key</span><span class="o">=</span><span class="n">index_key</span><span class="p">,</span><span class="n">start_value_depth</span><span class="o">=</span><span class="n">start_value_depth</span><span class="p">,</span>
                        <span class="n">end_value_depth</span><span class="o">=</span><span class="n">end_value_depth</span><span class="p">,</span><span class="n">column_order_selection</span><span class="o">=</span><span class="n">column_order_selection</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>
        
            
<div class="viewcode-block" id="interpol_scipy"><a class="viewcode-back" href="../../../utils.html#csamtpy.utils.func_utils.interpol_scipy">[docs]</a><span class="k">def</span> <span class="nf">interpol_scipy</span> <span class="p">(</span><span class="n">x_value</span><span class="p">,</span> <span class="n">y_value</span><span class="p">,</span><span class="n">x_new</span><span class="p">,</span>
                    <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span><span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="s2">&quot;extrapolate&quot;</span><span class="p">):</span>
    
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    function to interpolate data </span>
<span class="sd">    </span>
<span class="sd">    parameters :</span>
<span class="sd">    ------------</span>
<span class="sd">    * x_value : np.ndarray </span>
<span class="sd">                value on array data : original absciss </span>
<span class="sd">    * y_value : np.ndarray </span>
<span class="sd">                value on array data : original coordinates (slope)</span>
<span class="sd">    * x_new  : np.ndarray </span>
<span class="sd">                new value of absciss you want to interpolate data </span>
<span class="sd">    * kind  : str </span>
<span class="sd">            projection kind : </span>
<span class="sd">                maybe : &quot;linear&quot;, &quot;cubic&quot;</span>
<span class="sd">    * fill : str </span>
<span class="sd">        kind of extraolation, if None , *spi will use constraint interpolation </span>
<span class="sd">        can be &quot;extrapolate&quot; to fill_value.</span>
<span class="sd">    * plot : Boolean </span>
<span class="sd">        Set to True to see a wiewer graph</span>
<span class="sd">        </span>
<span class="sd">    </span>
<span class="sd">    return: </span>
<span class="sd">    --------</span>
<span class="sd">        np.ndarray </span>
<span class="sd">        y_new ,new function interplolate values .</span>
<span class="sd">        </span>
<span class="sd">    e.g. ::</span>
<span class="sd">        if __name__==&quot;__main__&quot;:</span>
<span class="sd">            fill=&quot;extrapolate&quot;</span>
<span class="sd">            x=np.linspace(0,15,10)</span>
<span class="sd">            y=np.random.randn(10)</span>
<span class="sd">            x_=np.linspace(0,20,15)</span>
<span class="sd">            ss=interpol_Scipy(x_value=x, y_value=y, x_new=x_, kind=&quot;linear&quot;)</span>
<span class="sd">            print(ss)</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">func_</span><span class="o">=</span><span class="n">spi</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">x_value</span><span class="p">,</span> <span class="n">y_value</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span><span class="n">fill_value</span><span class="o">=</span><span class="n">fill</span><span class="p">)</span>
    <span class="n">y_new</span><span class="o">=</span><span class="n">func_</span><span class="p">(</span><span class="n">x_new</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">plot</span> <span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_value</span><span class="p">,</span> <span class="n">y_value</span><span class="p">,</span><span class="s2">&quot;o&quot;</span><span class="p">,</span><span class="n">x_new</span><span class="p">,</span> <span class="n">y_new</span><span class="p">,</span><span class="s2">&quot;--&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span><span class="s2">&quot;cubic&quot;</span><span class="p">],</span><span class="n">loc</span><span class="o">=</span><span class="s2">&quot;best&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">y_new</span></div>


<span class="k">def</span> <span class="nf">_set_depth_to_coeff</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">depth_column_index</span><span class="p">,</span><span class="n">coeff</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">depth_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : np.ndarray</span>
<span class="sd">        must be on array channel .</span>
<span class="sd">    depth_column_index : int</span>
<span class="sd">        index of depth_column.</span>
<span class="sd">    depth_axis : int, optional</span>
<span class="sd">        Precise kind of orientation of depth data(axis =0 or axis=1) </span>
<span class="sd">        The default is 0.</span>
<span class="sd">    coeff : float,</span>
<span class="sd">        the value you want to multiplie depth. </span>
<span class="sd">        set depth to negative multiply by one. </span>
<span class="sd">        The default is -1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    data : np.ndarray</span>
<span class="sd">        new data after set depth according to it value.</span>
<span class="sd">        </span>
<span class="sd">    example::</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; if __name__==&quot;__main__&quot;:</span>
<span class="sd">            import numpy as np </span>
<span class="sd">            np.random.seed(4)</span>
<span class="sd">            data=np.random.rand(4,3)</span>
<span class="sd">            data=data*(-1)</span>
<span class="sd">            print(&quot;data\n&quot;,data)</span>
<span class="sd">            data[:,1]=data[:,1]*(-1)</span>
<span class="sd">            # data[data&lt;0]</span>
<span class="sd">            print(&quot;data2\n&quot;,data)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">depth_axis</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">data</span><span class="p">[:,</span><span class="n">depth_column_index</span><span class="p">]</span><span class="o">=</span><span class="n">data</span><span class="p">[:,</span><span class="n">depth_column_index</span><span class="p">]</span><span class="o">*</span><span class="n">coeff</span>
    <span class="k">if</span> <span class="n">depth_axis</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">data</span><span class="p">[</span><span class="n">depth_column_index</span><span class="p">,:]</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="n">depth_column_index</span><span class="p">,:]</span><span class="o">*</span><span class="n">coeff</span>  

    <span class="k">return</span> <span class="n">data</span>
            


<div class="viewcode-block" id="broke_array_to_"><a class="viewcode-back" href="../../../utils.html#csamtpy.utils.func_utils.broke_array_to_">[docs]</a><span class="k">def</span> <span class="nf">broke_array_to_</span><span class="p">(</span><span class="n">arrayData</span><span class="p">,</span> <span class="n">keyIndex</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">broken_type</span><span class="o">=</span><span class="s2">&quot;dict&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    broke data array into different value with their same key </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arrayData :np.array</span>
<span class="sd">        data array .</span>
<span class="sd">        </span>
<span class="sd">    keyIndex : int, </span>
<span class="sd">        index of column to create dict key </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dico_brok : dict </span>
<span class="sd">        dictionnary of array.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># find the max_counts</span>
    
    <span class="n">vcounts_temp</span><span class="p">,</span><span class="n">counts_temp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">arrayData</span><span class="p">[:,</span><span class="n">keyIndex</span><span class="p">],</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">vcounts_temp_max</span><span class="o">=</span><span class="n">vcounts_temp</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="c1"># print(vcounts_temp)</span>
    <span class="c1"># print(vcounts_temp_max)</span>
    <span class="c1"># print(vcounts_temp.min())</span>

    <span class="n">dico_brok</span><span class="o">=</span><span class="p">{}</span>
    <span class="n">lis_brok</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">index</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">deb</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">for</span> <span class="n">rowlines</span> <span class="ow">in</span> <span class="n">arrayData</span> <span class="p">:</span>
        <span class="k">if</span> <span class="n">rowlines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">vcounts_temp_max</span><span class="p">:</span>
            <span class="n">value</span><span class="o">=</span><span class="n">arrayData</span><span class="p">[</span><span class="n">index</span><span class="p">:,::]</span>
            <span class="k">if</span> <span class="n">broken_type</span><span class="o">==</span><span class="s2">&quot;dict&quot;</span><span class="p">:</span>
                <span class="n">dico_brok</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rowlines</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span><span class="o">=</span><span class="n">value</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">broken_type</span><span class="o">==</span><span class="s2">&quot;list&quot;</span><span class="p">:</span>
                <span class="n">lis_brok</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="k">break</span>
        <span class="k">elif</span> <span class="n">rowlines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span><span class="n">arrayData</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">keyIndex</span><span class="p">]:</span>
            <span class="n">value</span><span class="o">=</span><span class="n">arrayData</span><span class="p">[</span><span class="n">deb</span><span class="p">:</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">,::]</span>
            <span class="k">if</span> <span class="n">broken_type</span><span class="o">==</span><span class="s2">&quot;dict&quot;</span><span class="p">:</span>
                <span class="n">dico_brok</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rowlines</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span><span class="o">=</span><span class="n">value</span>
            <span class="k">elif</span> <span class="n">broken_type</span><span class="o">==</span><span class="s2">&quot;list&quot;</span><span class="p">:</span>
                <span class="n">lis_brok</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">deb</span><span class="o">=</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span>
        <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span>
    <span class="k">if</span> <span class="n">broken_type</span><span class="o">==</span><span class="s2">&quot;dict&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dico_brok</span>
    <span class="k">elif</span> <span class="n">broken_type</span><span class="o">==</span><span class="s2">&quot;list&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">lis_brok</span></div>
    

<span class="nd">@deprecated</span><span class="p">(</span><span class="s1">&#39;this function is replaced by [_search_ToFill_Data] &#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_OlDFUNCNOUSEsearch_fill_data</span><span class="p">(</span><span class="n">dicoReal</span><span class="p">,</span> <span class="n">arrayTemp</span> <span class="p">,</span> 
                      <span class="n">max_value</span><span class="p">,</span> <span class="n">index_of_depth</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : dict</span>
<span class="sd">        Dictionnary of numpy ndarray .</span>
<span class="sd">        </span>
<span class="sd">    dataReal : dict</span>
<span class="sd">         dictionnary . must be a dictionnary of real of offset .</span>
<span class="sd">        </span>
<span class="sd">    arrayTemp : np.ndarray </span>
<span class="sd">             must be a numpy array of reserve data , the one , we want to </span>
<span class="sd">             extract the depth data to fill array </span>

<span class="sd">    max_value : float</span>
<span class="sd">            Maximum depth of the survey. </span>
<span class="sd">        </span>
<span class="sd">    index_of_depth : int,</span>
<span class="sd">            the index of depth column. The default is 0.</span>
<span class="sd">    axis : int , optional</span>
<span class="sd">        numpy.ndarray axis . The default is 0.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndictionnary of offsets filled </span>
<span class="sd">        return the array data we want to top to .</span>
<span class="sd">    </span>
<span class="sd">    e.g. ::</span>
<span class="sd">        if __name__=&quot;__main__&quot;:</span>
<span class="sd">            np.random.seed(0)</span>
<span class="sd">            sos=abs(np.random.randn(4,3)*4)</span>
<span class="sd">            sos2=abs(np.random.randn(4,3)*10.8)</span>
<span class="sd">            sos3=abs(np.randon.rand(8,3)*12.4)</span>
<span class="sd">            # print(sos2)</span>
<span class="sd">            sis1=sort_array_data(data=sos,sort_order =1,</span>
<span class="sd">                                concatenate=False, concat_axis_order=0)</span>
<span class="sd">            sis2=sort_array_data(data=sos2,sort_order =1,</span>
<span class="sd">                                concatenate=False, concat_axis_order=0)</span>
<span class="sd">            sis3=sort_array_data(data=sos3,sort_order =1,</span>
<span class="sd">                                concatenate=False, concat_axis_order=0)</span>
<span class="sd">            </span>
<span class="sd">            dico={&quot;18.4&quot;:sis1,</span>
<span class="sd">                  &quot;21.4&quot;:sis2}</span>
<span class="sd">            test=_search_fill_data(dicoReal=dico, index_key=11.4, </span>
<span class="sd">                                  start_value=10, max_value=23,</span>
<span class="sd">                                  index_of_depth=1)</span>
<span class="sd">            </span>
<span class="sd">            print(&quot;sis1\n:&quot;,sis1)</span>
<span class="sd">            print(&quot;sis2\n:&quot;,sis2)</span>
<span class="sd">            print(&quot;Finaltest\n&quot;, test)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># arange a dictionany : </span>
    <span class="c1">#from keys : for k in sorted(dico.keys()):</span>
    <span class="c1">#   print(%s: %s&quot;,%(k,names[k]))</span>
    <span class="c1"># from values : for k , v  in sorted(dico.items(),key=lambda x:x[1]):</span>
    <span class="c1">#   print(%s: %s&quot;,%(k,v))</span>
    
    <span class="n">_all_checker</span><span class="p">,</span><span class="n">keyToSkip</span><span class="o">=</span><span class="p">[],[]</span>
    <span class="n">litemp</span><span class="o">=</span> <span class="n">broke_array_to_</span><span class="p">(</span><span class="n">arrayData</span><span class="o">=</span><span class="n">arrayTemp</span><span class="p">,</span><span class="n">keyIndex</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                            <span class="n">broken_type</span><span class="o">=</span><span class="s2">&quot;list&quot;</span><span class="p">)</span>
    <span class="n">itemp</span><span class="p">,</span><span class="n">real</span><span class="p">,</span><span class="n">realTem</span><span class="o">=</span><span class="p">[],[],[]</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">litemp</span><span class="p">:</span>
        <span class="n">temp</span><span class="o">=</span><span class="n">sort_array_data</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">ii</span><span class="p">,</span><span class="n">sort_order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                             <span class="n">concatenate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">itemp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
    <span class="c1"># print(itemp)</span>
        
    <span class="k">for</span> <span class="n">key</span> <span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dicoReal</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
        <span class="c1"># print(sorted(dicoReal.items()))</span>
        <span class="c1"># for ii, rowline in enumerate(value)  :</span>
        <span class="n">rowmax</span><span class="o">=</span><span class="n">value</span><span class="p">[:,</span><span class="n">index_of_depth</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">real</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">float</span><span class="p">(</span><span class="n">key</span><span class="p">),</span><span class="n">rowmax</span><span class="p">))</span>
        <span class="n">_all_checker</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rowmax</span><span class="p">)</span>
        
    
    <span class="c1">#chek if all elements are reach the depth max  </span>
    <span class="c1"># if all(_all_checker)==True : # if one of the depth is the same </span>
    <span class="c1">#     return dicoReal</span>
    <span class="n">realTem</span><span class="o">=</span><span class="n">real</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">realTem</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">max_value</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">realTem</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
            <span class="c1">#real.pop(ii)</span>
            
    <span class="k">if</span> <span class="n">realTem</span> <span class="o">==</span><span class="p">[]:</span>
        <span class="k">return</span> <span class="n">dicoReal</span>
    
    
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Real : </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">real</span><span class="p">)</span>
    <span class="n">idx</span><span class="p">,</span><span class="n">flag</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
    <span class="n">comp</span><span class="p">,</span><span class="n">sp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">fin_list</span><span class="p">,</span><span class="n">endList</span><span class="o">=</span><span class="p">[],[]</span>
    
    <span class="k">while</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">realTem</span><span class="p">):</span>
        
        <span class="n">indexKey</span><span class="o">=</span><span class="n">realTem</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="c1">#11,4</span>
        <span class="n">maxKey</span><span class="o">=</span><span class="n">realTem</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="c1">#214        </span>
        <span class="c1"># if real[idx][1]==max_value : # case where thedepth  value of realdico is get  </span>
        <span class="c1">#     flag=3</span>
        <span class="c1"># # elif real[idx][1]==max_value : # case where thedepth  value of realdico is get  </span>
        <span class="c1"># #     flag=3</span>
        <span class="c1"># else :</span>
        <span class="k">if</span> <span class="n">idx</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">realTem</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">indic</span><span class="o">=</span><span class="n">real</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">realTem</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            <span class="c1"># check whether there is data after a delete the offset with depth value reach </span>
            <span class="k">if</span> <span class="n">realTem</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">real</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">nexIndex</span><span class="o">=</span><span class="n">itemp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span> <span class="p">:</span>
                <span class="n">nexIndex</span><span class="o">=</span><span class="n">real</span><span class="p">[</span><span class="n">indic</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span> <span class="p">:</span>
            <span class="n">nexIndex</span><span class="o">=</span><span class="n">realTem</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="c1">#61.4</span>
        <span class="c1"># loop the reserve list :</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">array</span> <span class="ow">in</span> <span class="nb">enumerate</span> <span class="p">(</span><span class="n">itemp</span><span class="p">):</span> <span class="c1">#itemp is the  list of reserve broken list</span>
        
            <span class="c1"># if array[0][0]&gt; indexKey and array[0][0]&gt; nexIndex:</span>
            <span class="c1">#     keyToSkip.append(realTem[idx])</span>
            <span class="c1">#     continue </span>
            <span class="k">if</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span> <span class="n">indexKey</span> <span class="ow">and</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="n">nexIndex</span> <span class="p">:</span> <span class="c1">#check offset and next offset , if True :</span>
                
                <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">rowline</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="p">:</span> <span class="c1"># loop the array now </span>
                    <span class="c1"># tem_depth=rowline[1] # take the value of depth of reserve array for the first row </span>
                    <span class="k">if</span> <span class="n">rowline</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">maxKey</span> <span class="p">:</span><span class="c1"># maxKey=214, rowline[1]= :# (max_value=904) if True :</span>
                        <span class="n">sp</span><span class="o">=</span><span class="n">sp</span><span class="o">+</span><span class="mi">1</span>
                        <span class="k">if</span> <span class="n">sp</span><span class="o">==</span><span class="mi">0</span> <span class="p">:</span>
                            <span class="n">add_array</span><span class="o">=</span><span class="n">array</span><span class="p">[</span><span class="n">index</span><span class="p">:,:]</span>
                            <span class="c1"># num=index</span>
                            <span class="c1"># print(&quot;True:\n&quot;,add_array)</span>
                            <span class="n">flag</span><span class="o">=</span><span class="mi">4</span>
                        <span class="k">else</span> <span class="p">:</span>
                            <span class="n">sp</span><span class="o">=-</span><span class="mi">1</span>
                            <span class="k">pass</span>
                        <span class="c1"># print(maxtem)</span>
            <span class="k">if</span> <span class="n">flag</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span>
                <span class="c1"># maxtem=array[-1][1]       # take the maximum depth of the reserve array , last row</span>
                <span class="k">if</span> <span class="n">array</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>  <span class="o">&lt;</span> <span class="n">max_value</span> <span class="p">:</span> <span class="c1"># if the maximum depth not reach </span>
                    <span class="n">comp</span><span class="o">=</span><span class="n">comp</span><span class="o">+</span><span class="mi">1</span>
                    <span class="k">if</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="n">nexIndex</span> <span class="p">:</span>
                        <span class="n">endList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">add_array</span><span class="p">)</span>
                    <span class="k">else</span> <span class="p">:</span>
                        <span class="n">fin_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">add_array</span><span class="p">)</span> <span class="c1"># keep the array in temporary list </span>
                    <span class="c1"># maxKey = maxtem   # set up new maximum depth </span>
                    <span class="c1"># flag=1</span>
                    <span class="n">maxKey</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> 
                    <span class="c1"># print(&quot;flag4,comp&gt;1&quot;)</span>
                    <span class="c1"># if maxKey &lt; </span>
                <span class="k">elif</span> <span class="n">array</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>  <span class="o">==</span><span class="n">max_value</span> <span class="p">:</span> <span class="c1"># the maximum depth is reached</span>
                    <span class="n">flag</span><span class="o">=</span><span class="mi">5</span>
    
            <span class="k">if</span> <span class="n">flag</span><span class="o">==</span><span class="mi">5</span> <span class="p">:</span>
                
                <span class="k">if</span> <span class="n">comp</span><span class="o">==</span><span class="mi">0</span> <span class="p">:</span> <span class="c1"># first check is ok </span>
                    <span class="c1"># add_array=array[num:,:] # cut the array </span>
                    <span class="n">endList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">add_array</span><span class="p">)</span>
                    <span class="n">flag</span><span class="o">=</span><span class="mi">0</span>
                    <span class="c1"># print(&quot;flag5,comp=0&quot;)</span>
                <span class="k">else</span> <span class="p">:</span>
                  <span class="n">add_array</span><span class="o">=</span><span class="n">array</span><span class="p">[</span><span class="n">index</span><span class="p">:,:]</span> <span class="c1">#  </span>
                  <span class="n">fin_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">add_array</span><span class="p">)</span> <span class="c1"># list to create one ar</span>

                  <span class="n">flag</span><span class="o">=</span><span class="mi">1</span>
                      
        <span class="c1"># if flag==3 : # in that case is true , save the value of the offset </span>
        <span class="c1">#     # for key , value in dicoReal.items() :</span>
        <span class="c1">#     #     if float(key) == real[idx][0]:</span>
        <span class="c1">#     #         endList.append(value)</span>
        <span class="c1">#     keyToSkip.append(array[0][0])</span>
            
                    
        <span class="k">if</span> <span class="n">flag</span><span class="o">==</span><span class="mi">1</span> <span class="p">:</span>
            <span class="n">arT</span><span class="o">=</span><span class="n">concat_array_from_list</span><span class="p">(</span><span class="n">list_of_array</span><span class="o">=</span><span class="n">fin_list</span><span class="p">,</span><span class="n">concat_axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
            <span class="n">endList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arT</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">flag</span><span class="o">==</span><span class="mi">0</span> <span class="p">:</span>
            <span class="n">endList</span><span class="o">=</span><span class="n">endList</span>
        
        <span class="n">idx</span><span class="o">=</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span>
            
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;keyToSkip</span><span class="se">\n</span><span class="s2">:&quot;</span><span class="p">,</span><span class="n">keyToSkip</span><span class="p">)</span>       
        
    
    <span class="c1">#delete the the offset which are full depth on the list </span>
    <span class="c1"># print(keyToSkip)</span>
    <span class="c1"># print(real,&quot;\n&quot;)</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">realTem</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">keyToSkip</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">realTem</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
            <span class="c1">#real.pop(ii)</span>
    
    <span class="c1"># now we are the list of recoverd depth </span>
    <span class="c1"># build dictionnary</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Realtem</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">realTem</span><span class="p">,)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;endlist : </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">endList</span><span class="p">)</span>
    <span class="c1"># print(keyToSkip)</span>
    
    <span class="k">for</span> <span class="n">ii</span> <span class="p">,</span> <span class="n">tuple_</span> <span class="ow">in</span> <span class="nb">enumerate</span> <span class="p">(</span><span class="n">realTem</span><span class="p">)</span> <span class="p">:</span> <span class="c1">#take the realkey from dico</span>
        <span class="n">realKey</span><span class="p">,</span> <span class="n">maxValue</span><span class="o">=</span><span class="n">tuple_</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">realKey</span><span class="p">,</span><span class="n">maxValue</span><span class="p">)</span>
        
        <span class="n">add_array</span><span class="o">=</span><span class="n">endList</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>       <span class="c1"># take the add_value generated</span>
        <span class="c1"># print(endList)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">dicoReal</span><span class="o">.</span><span class="n">items</span><span class="p">():</span> <span class="c1"># search in dictionnary the key</span>
            <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">==</span><span class="n">realKey</span><span class="p">:</span> <span class="c1"># and compare it to the key from tuple ...</span>
                        <span class="c1">#... just to have certitude then concatenate </span>
                <span class="n">val</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">value</span><span class="p">,</span><span class="n">add_array</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">dicoReal</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">val</span>
        <span class="c1"># print(ii)</span>
    <span class="k">return</span> <span class="n">dicoReal</span> 


<span class="k">def</span> <span class="nf">_search_ToFill_Data</span> <span class="p">(</span><span class="n">dicoReal</span><span class="p">,</span> <span class="n">arrayTemp</span> <span class="p">,</span> 
                      <span class="n">max_value</span><span class="p">,</span> <span class="n">index_of_depth</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span> 
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    parameters :</span>
<span class="sd">    ------------</span>
<span class="sd">        data : dict</span>
<span class="sd">                Dictionnary of numpy ndarray .</span>
<span class="sd">                </span>
<span class="sd">        dicoReal : dict</span>
<span class="sd">             dictionnary . must be a dictionnary of real of offset .</span>
<span class="sd">            </span>
<span class="sd">        arrayTemp : np.ndarray </span>
<span class="sd">                 must be a numpy array of reserve data , the one , we want to </span>
<span class="sd">                 extract the depth data to fill array </span>
<span class="sd">    </span>
<span class="sd">        max_value : float</span>
<span class="sd">                Maximum depth of the survey. </span>
<span class="sd">            </span>
<span class="sd">        index_of_depth : int,</span>
<span class="sd">                the index of depth column. The default is 0.</span>
<span class="sd">        axis : int , optional</span>
<span class="sd">            numpy.ndarray axis . The default is 0.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndictionnary of offsets filled </span>
<span class="sd">            return the array data we want to top to .</span>
<span class="sd">        </span>
<span class="sd">        Test : :</span>
<span class="sd">            </span>
<span class="sd">            &gt;&gt;&gt;     </span>
<span class="sd">            import numpy as np </span>
<span class="sd">                np.random.seed(0)</span>
<span class="sd">                sos=abs(np.random.randn(4,3)*4)</span>
<span class="sd">                sos2=abs(np.random.randn(4,3)*10.8)</span>
<span class="sd">                sos3=abs(np.random.randn(5,3)*10.8)</span>
<span class="sd">                temp3=abs(np.random.rand(4,3)*12.4)</span>
<span class="sd">                temp2=abs(np.random.rand(4,3)*15.4)</span>
<span class="sd">                temp1=abs(np.random.rand(4,3)*9.4)</span>
<span class="sd">                temp4=abs(np.random.rand(5,3)*9.9)</span>
<span class="sd">                dico,temp={},[]</span>
<span class="sd">                ff=[sos,sos2,sos3,temp1,temp2,temp3,temp4]</span>
<span class="sd">            </span>
<span class="sd">                fin=[sort_array_data(data=ii,sort_order =1,</span>
<span class="sd">                                concatenate=False, concat_axis_order=0) for ii in  ff ]</span>
<span class="sd">                key=[11.9,61.4,102.7]</span>
<span class="sd">                vat=[214,405,904]</span>
<span class="sd">                for ii in range(3):</span>
<span class="sd">                    fin[ii][:,0]=key[ii]</span>
<span class="sd">                    fin[ii][-1][1]=vat[ii]</span>
<span class="sd">                    </span>
<span class="sd">                tempi=[(19.4,[11,18,50,120]),(28.4,[12,17,403,904]),</span>
<span class="sd">                       (78.3,[11,8,202,804]),(124.4,[203,403,604,714,904])]</span>
<span class="sd">                </span>
<span class="sd">                for ss, val in enumerate(tempi) :</span>
<span class="sd">                    fin[ss+3][:,0]=val[0]</span>
<span class="sd">                    fin[ss+3][:,1]=np.array(val[1])       </span>
<span class="sd">                </span>
<span class="sd">                for ss, van in enumerate (fin):</span>
<span class="sd">                    if ss&lt;=3 :</span>
<span class="sd">                        dico[van[0][0]]=van</span>
<span class="sd">                    if ss&gt;3 :</span>
<span class="sd">                        temp.append(van)</span>
<span class="sd">                </span>
<span class="sd">                arrayTemp=concat_array_from_list(list_of_array=temp,</span>
<span class="sd">                                                 concat_axis=0)</span>
<span class="sd">                sis02=_search_ToFill_Data(dicoReal=dico, arrayTemp=arrayTemp , </span>
<span class="sd">                              max_value=904, index_of_depth=1,axis=0)</span>
<span class="sd">                print(sis02)</span>
<span class="sd">                    </span>
<span class="sd">            </span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="c1">#Notes :</span>
    <span class="c1"># arange a dictionany : </span>
    <span class="c1">#from keys : for k in sorted(dico.keys()):</span>
    <span class="c1">#   print(%s: %s&quot;,%(k,names[k]))</span>
    <span class="c1"># from values : for k , v  in sorted(dico.items(),key=lambda x:x[1]):</span>
    <span class="c1">#   print(%s: %s&quot;,%(k,v)</span>
    <span class="c1"># for ii , value in enumerate(realTem):</span>
    <span class="c1"># if value[0] in keyToSkip:</span>
    <span class="c1">#     del realTem[ii]</span>
    <span class="c1">#     #real.pop(ii)</span>
    <span class="c1">#------------------------------------</span>
    <span class="c1"># _all_checker,keyToSkip=[],[]</span>
    <span class="n">litemp</span><span class="o">=</span> <span class="n">broke_array_to_</span><span class="p">(</span><span class="n">arrayData</span><span class="o">=</span><span class="n">arrayTemp</span><span class="p">,</span><span class="n">keyIndex</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                            <span class="n">broken_type</span><span class="o">=</span><span class="s2">&quot;list&quot;</span><span class="p">)</span>
    <span class="n">itemp</span><span class="p">,</span><span class="n">real</span><span class="o">=</span><span class="p">[],[],</span>
    <span class="c1"># flag=-1</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">litemp</span><span class="p">:</span>
        <span class="n">temp</span><span class="o">=</span><span class="n">sort_array_data</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">ii</span><span class="p">,</span><span class="n">sort_order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                             <span class="n">concatenate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">itemp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
    <span class="c1"># print(itemp)</span>
    <span class="k">for</span> <span class="n">key</span> <span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dicoReal</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
        <span class="c1"># print(sorted(dicoReal.items()))</span>
        <span class="c1"># for ii, rowline in enumerate(value)  :</span>
        <span class="n">rowmax</span><span class="o">=</span><span class="n">value</span><span class="p">[:,</span><span class="n">index_of_depth</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">real</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">float</span><span class="p">(</span><span class="n">key</span><span class="p">),</span><span class="n">rowmax</span><span class="p">))</span>
        <span class="c1"># _all_checker.append(rowmax)</span>
        
    <span class="c1"># print(itemp)</span>
    <span class="n">iter_</span><span class="o">=-</span><span class="mi">1</span>  
    <span class="k">for</span> <span class="n">ss</span><span class="p">,(</span><span class="n">offs</span><span class="p">,</span> <span class="n">maxDepth</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="n">real</span><span class="p">):</span>
        <span class="c1"># [(11.4,214),(19.4,120),(61.4,405),(102,904)]</span>
        <span class="c1"># print(offs)</span>
        <span class="k">if</span> <span class="n">maxDepth</span> <span class="o">&lt;</span> <span class="n">max_value</span> <span class="p">:</span> <span class="c1"># max_value=904 , maxDepth=214</span>
            <span class="k">if</span> <span class="n">ss</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">real</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">arTem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">itemp</span><span class="p">):</span>
                    <span class="n">kk</span><span class="o">=</span><span class="n">arTem</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">kk</span> <span class="o">&gt;</span> <span class="n">offs</span> <span class="p">:</span>
                        <span class="n">nextIndex</span><span class="o">=</span><span class="n">kk</span>
                    <span class="k">else</span> <span class="p">:</span>
                        <span class="k">break</span>
                <span class="c1"># nextIndex=itemp[-1][0][0]</span>
            <span class="k">else</span> <span class="p">:</span>
                <span class="n">nextIndex</span><span class="o">=</span><span class="n">real</span><span class="p">[</span><span class="n">ss</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">array</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">itemp</span><span class="p">)</span> <span class="p">:</span> <span class="c1"># [array(28),array(78), ....]</span>
            
                <span class="k">if</span> <span class="n">offs</span> <span class="o">&lt;</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>  <span class="ow">and</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nextIndex</span><span class="p">:</span> 

                    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">rowline</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="p">:</span> <span class="c1"># scroll array(28)</span>
                        <span class="k">if</span> <span class="n">rowline</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span> <span class="n">maxDepth</span> <span class="p">:</span>  <span class="c1"># if rowline &gt; the maxDepth=214</span>
                            <span class="n">iter_</span><span class="o">=</span><span class="n">iter_</span><span class="o">+</span><span class="mi">1</span> <span class="c1"># first iteration on array (28)</span>
                            <span class="k">if</span> <span class="n">iter_</span><span class="o">==</span><span class="mi">0</span> <span class="p">:</span> <span class="c1"># collect the remain info and add to dico</span>
                                <span class="n">add_array</span><span class="o">=</span><span class="n">array</span><span class="p">[</span><span class="n">index</span><span class="p">:,:]</span>
                                <span class="n">maxDepth</span><span class="o">=</span><span class="n">array</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="c1"># caluclate nnex</span>
                                <span class="c1"># print(add_array)</span>
                            <span class="k">else</span> <span class="p">:</span>
                                <span class="k">pass</span>
                            <span class="k">if</span> <span class="n">iter_</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">maxDepth</span><span class="o">&lt;=</span><span class="n">max_value</span> <span class="p">:</span>
                                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">dicoReal</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="p">:</span>
                                    <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span><span class="n">offs</span> <span class="p">:</span>
                                        <span class="n">new_value</span><span class="o">=</span><span class="n">concat_array_from_list</span><span class="p">(</span><span class="n">list_of_array</span><span class="o">=</span><span class="p">[</span><span class="n">value</span><span class="p">,</span><span class="n">add_array</span><span class="p">],</span>
                                                                     <span class="n">concat_axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
                                        <span class="n">dicoReal</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">new_value</span>
                                        <span class="n">iter_</span><span class="o">=-</span><span class="mi">1</span>
                                        <span class="c1"># break</span>
                <span class="k">else</span> <span class="p">:</span>
                    <span class="k">pass</span>
             
    <span class="k">return</span> <span class="n">dicoReal</span>
        

<div class="viewcode-block" id="straighten_out_list"><a class="viewcode-back" href="../../../utils.html#csamtpy.utils.func_utils.straighten_out_list">[docs]</a><span class="k">def</span> <span class="nf">straighten_out_list</span> <span class="p">(</span><span class="n">main_list</span> <span class="p">,</span> <span class="n">list_to_straigh</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    main_list : list</span>
<span class="sd">        list of which the data must absolutely appear into the straighen list.</span>
<span class="sd">        in our case , it is the staion list : a list of offset </span>
<span class="sd">    list_to_straigh : list</span>
<span class="sd">        list contain the data (offset calculated , the depth and the resistivity (log10)), </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list_to_straigh : list</span>
<span class="sd">        the straighen list.</span>
<span class="sd">        some offset have been replaced by the offsets which are not in the </span>
<span class="sd">        main_list whithout change the lengh of the straighen list. </span>


<span class="sd">    e.g. :: </span>
<span class="sd">            import numpy as np </span>
<span class="sd">            np.random.seed(14)</span>
<span class="sd">            ss=np.random.randn(10)*12</span>
<span class="sd">            ss=ss.tolist()</span>
<span class="sd">            ss=[round(float(jj),4) for jj in ss]</span>
<span class="sd">            ss.sort()</span>
<span class="sd">            red=np.random.randn(7)*12</span>
<span class="sd">            red=red.tolist()</span>
<span class="sd">            test=[19, 15.012, 5.5821, 0.7234,3.1, </span>
<span class="sd">                  0.7919, 3.445, 4.7398, 5.1, 10.8, 15.51,21]</span>
<span class="sd">            </span>
<span class="sd">            main=[20., 0.7234, 5, 3.445, 15.51,10.7, 3,5.1]</span>
<span class="sd">            test.sort()</span>
<span class="sd">            main.sort()</span>
<span class="sd">            </span>
<span class="sd">            red=[round(float(ss),1) for ss in red]</span>
<span class="sd">        </span>
<span class="sd">            print(test)</span>
<span class="sd">            print(main)</span>
<span class="sd">            </span>
<span class="sd">            sos=straighten_out_list (main_list=main , </span>
<span class="sd">                                     list_to_straigh=test)</span>
<span class="sd">            print(&quot;sos:\n&quot;,sos)</span>
<span class="sd">            </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    
    <span class="n">staIter</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">list_to_straigh</span><span class="p">)</span><span class="c1"># ARRAY </span>
    <span class="n">max_X</span><span class="o">=</span><span class="n">staIter</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">valuesIter</span><span class="p">,</span><span class="n">counts</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">staIter</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">valuesIter</span><span class="o">=</span><span class="n">valuesIter</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="c1"># List sorted of straighten value</span>
    <span class="c1"># print(valuesIter)</span>
    

    <span class="n">misoffs</span><span class="p">,</span><span class="n">vamin</span><span class="p">,</span><span class="n">tempi</span><span class="o">=</span><span class="p">[],[],[]</span>
    <span class="c1"># min_,flag=1,0</span>
    <span class="k">for</span> <span class="n">sta</span> <span class="ow">in</span> <span class="n">main_list</span><span class="p">:</span> <span class="c1"># keep the offset not in list to straight </span>
        <span class="k">if</span> <span class="n">sta</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valuesIter</span> <span class="p">:</span>
            <span class="n">misoffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sta</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">misoffs</span> <span class="o">==</span><span class="p">[]:</span>
        <span class="k">return</span> <span class="n">list_to_straigh</span>
    
    <span class="c1"># inject miss offset value in the temporary list and sorted </span>
    <span class="c1">#this to choose the closet value we want to substitude the missoffset value </span>
    <span class="n">tempi</span><span class="o">=</span><span class="p">[</span><span class="n">ii</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">valuesIter</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">misoffs</span> <span class="p">:</span>
        <span class="n">tempi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>

    <span class="n">tempi</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">tempi</span><span class="p">)</span>

    <span class="n">tempi</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">reverse</span> <span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># print(&quot;mainlist:\n&quot;,main_list)</span>
    <span class="c1"># print(&quot;tempiSorted:\n&quot;,tempi)</span>
    <span class="c1"># print(&quot;missoff:\n&quot;,misoffs)</span>
    <span class="c1"># print(&quot;lisofStraight_max:\n&quot;,max_X)</span>
    <span class="c1"># # print(len(misoffs))</span>

    <span class="c1"># sp=-1</span>
    <span class="k">for</span> <span class="n">jj</span><span class="p">,</span> <span class="n">off</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tempi</span><span class="p">):</span> <span class="c1">#scroll the create temporary list</span>
        <span class="k">for</span> <span class="n">ss</span><span class="p">,</span> <span class="n">ofi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">misoffs</span><span class="p">):</span>  <span class="c1"># scroll the miss offset list and compare it </span>
                            <span class="c1"># to the temportary list </span>
            <span class="k">if</span> <span class="n">off</span><span class="o">==</span><span class="n">ofi</span><span class="p">:</span>
                <span class="c1"># print(off,ss)</span>
                <span class="n">indexof</span> <span class="o">=</span><span class="n">main_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">off</span><span class="p">)</span> <span class="c1"># find the index of &quot;off&quot; value in the mainlist</span>
                        <span class="c1"># in order to calculate the distance between the value to its next value </span>
                        <span class="c1"># or forward value ex :off=3 , backward =0.724 , forward =3.445</span>
                        
                <span class="c1"># if main_list[indexof]==main_list[-1]: # that&#39;s mean the &quot;off&quot; value reaches the end of mainlist</span>
                <span class="c1">#     if tempi[-1]&gt;main_list[indexof]: # </span>
                <span class="c1">#         deltaMain=main_list[indexof]-tempi[-1] # take the diff between</span>
                <span class="c1">#         vamin.append(tempi[-1])</span>
                <span class="c1">#     else :</span>
                <span class="c1">#         deltaMain=main_list[indexof]-tempi[-2]</span>
                <span class="c1"># else :</span>
                <span class="c1">#     deltaMain=main_list[indexof]-main_list[indexof+1]</span>
                    
                <span class="c1"># if main_list[indexof+1] != tempi[jj+1] :</span>
                <span class="k">if</span> <span class="n">off</span><span class="o">==</span><span class="n">tempi</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="c1"># deltaOffneg=abs(off-tempi[jj-1])</span>
                    <span class="n">vamin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tempi</span><span class="p">[</span><span class="n">jj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="c1"># delta=deltaOffneg</span>
                    
                <span class="k">elif</span> <span class="n">off</span><span class="o">==</span><span class="n">tempi</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">deltaOffpos</span><span class="o">=</span><span class="nb">abs</span><span class="p">(</span><span class="n">off</span><span class="o">-</span><span class="n">tempi</span><span class="p">[</span><span class="n">jj</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">vamin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tempi</span><span class="p">[</span><span class="n">jj</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
                    <span class="c1"># delta=deltaOffpos</span>
                <span class="k">else</span> <span class="p">:</span>
                    <span class="n">deltaOffpos</span><span class="o">=</span><span class="nb">abs</span><span class="p">(</span><span class="n">off</span><span class="o">-</span><span class="n">tempi</span><span class="p">[</span><span class="n">jj</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">deltaOffneg</span><span class="o">=</span><span class="nb">abs</span><span class="p">(</span><span class="n">off</span><span class="o">-</span><span class="n">tempi</span><span class="p">[</span><span class="n">jj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">deltaOffpos</span> <span class="o">&gt;=</span> <span class="n">deltaOffneg</span> <span class="p">:</span>
                        <span class="c1"># delta=deltaOffneg</span>
                        <span class="n">vamin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tempi</span><span class="p">[</span><span class="n">jj</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                        <span class="c1"># index=jj-1</span>
                    <span class="k">else</span> <span class="p">:</span>
                        <span class="c1"># delta=deltaOffpos</span>
                        <span class="c1"># index=jj+1</span>
                            <span class="n">vamin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tempi</span><span class="p">[</span><span class="n">jj</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># print(&quot;vamin:\n&quot;,vamin)   </span>
    <span class="c1"># print(len(vamin))</span>
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">list_to_straigh</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">ss</span><span class="p">,</span> <span class="n">of</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vamin</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">val</span><span class="o">==</span><span class="n">of</span> <span class="p">:</span>
                <span class="n">list_to_straigh</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">=</span><span class="n">misoffs</span><span class="p">[</span><span class="n">ss</span><span class="p">]</span>
                
    <span class="c1"># if list_to_straigh[-1] !=max_X :</span>
        
    <span class="k">return</span> <span class="n">list_to_straigh</span></div>

<div class="viewcode-block" id="take_firstValue_offDepth"><a class="viewcode-back" href="../../../utils.html#csamtpy.utils.func_utils.take_firstValue_offDepth">[docs]</a><span class="k">def</span> <span class="nf">take_firstValue_offDepth</span><span class="p">(</span><span class="n">data_array</span><span class="p">,</span>
                             <span class="n">filter_order</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data_array : np.array </span>
<span class="sd">        array of the data .</span>
<span class="sd">    filter_order : int , optional</span>
<span class="sd">        the column you want to filter. The default is 1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array : TYPE</span>
<span class="sd">        return array of the data filtered.</span>
<span class="sd">        </span>
<span class="sd">    </span>
<span class="sd">    e.g. :: </span>
<span class="sd">        import numpy as np </span>
<span class="sd">            list8=[[4,2,0.1],[8,2,0.7],[10,1,0.18],[4,3,0.1],</span>
<span class="sd">            [7,2,1.2],[10,3,0.5],[10,1,0.5],[8.2,0,1.9],</span>
<span class="sd">            [10,7,0.5],[10,1,0.5],[2,0,1.4],[5,4,0.5],</span>
<span class="sd">            [10,2,0.7],[7,2,1.078],[10,2,3.5],[10,8,1.9]]</span>
<span class="sd">            test=np.array(list8)</span>
<span class="sd">            </span>
<span class="sd">            # print(np_test)</span>
<span class="sd">            ss=take_firstValue_offDepth(data_array =np_test, filter_order=1)</span>
<span class="sd">            # ss=averageData(np_array=np_test,filter_order=1,</span>
<span class="sd">            #                axis_average=0, astype=&quot;int&quot;)</span>
<span class="sd">            </span>
<span class="sd">            print(ss)</span>

<span class="sd">        </span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">listofArray</span><span class="o">=</span><span class="p">[]</span><span class="c1">#data_array[0,:]]</span>
    <span class="n">data_array</span><span class="o">=</span><span class="n">data_array</span><span class="p">[</span><span class="n">data_array</span><span class="p">[:,</span><span class="n">filter_order</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s2">&quot;mergesort&quot;</span><span class="p">)]</span>
    <span class="c1"># print(data_array,&quot;\n:&quot;)</span>
    <span class="c1"># np_array=np_array[np_array[:,filter_order].argsort(kind=&quot;mergesort&quot;)]</span>
     <span class="c1">#returns the differents value on the filtersort index of array :</span>
    <span class="n">values</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">data_array</span><span class="p">[:,</span><span class="n">filter_order</span><span class="p">],</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">rowline</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data_array</span> <span class="p">):</span> 
    
        <span class="k">if</span> <span class="n">rowline</span><span class="p">[</span><span class="n">filter_order</span><span class="p">]</span><span class="o">==</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">listofArray</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data_array</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
            <span class="k">break</span> 
        <span class="k">elif</span> <span class="n">rowline</span><span class="p">[</span><span class="n">filter_order</span><span class="p">]</span> <span class="o">!=</span><span class="n">data_array</span><span class="p">[</span><span class="n">ii</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">filter_order</span><span class="p">]:</span>
            <span class="n">listofArray</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data_array</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
        
        
    <span class="n">array</span> <span class="o">=</span><span class="n">concat_array_from_list</span><span class="p">(</span><span class="n">list_of_array</span><span class="o">=</span><span class="n">listofArray</span><span class="p">,</span> <span class="n">concat_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">array</span><span class="o">=</span><span class="n">array</span><span class="p">[</span><span class="n">array</span><span class="p">[:,</span><span class="n">filter_order</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s2">&quot;mergesort&quot;</span><span class="p">)]</span>
    <span class="n">listofArray</span><span class="o">=</span><span class="p">[]</span>

    <span class="k">return</span> <span class="n">array</span> </div>

<div class="viewcode-block" id="dump_comma"><a class="viewcode-back" href="../../../utils.html#csamtpy.utils.func_utils.dump_comma">[docs]</a><span class="k">def</span> <span class="nf">dump_comma</span><span class="p">(</span><span class="n">input_car</span><span class="p">,</span> <span class="n">max_value</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">carType</span><span class="o">=</span><span class="s1">&#39;mixed&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input_car : str,</span>
<span class="sd">    </span>
<span class="sd">        Input character.</span>
<span class="sd">    max_value : int, optional</span>
<span class="sd">        DESCRIPTION. The default is 2.</span>
<span class="sd">        </span>
<span class="sd">    carType =str </span>
<span class="sd">        Type of character , you want to entry : </span>
<span class="sd">            it may be as arguments parameters :</span>
<span class="sd">               for value :  [&#39;value&#39;,&#39;val&#39;,&quot;numeric&quot;,</span>
<span class="sd">                           &quot;num&quot;, &quot;num&quot;,&quot;float&quot;,&quot;int&quot;]</span>
<span class="sd">               for pure character : [&quot;car&quot;,&quot;character&quot;,&quot;ch&quot;,&quot;char&quot;,&quot;str&quot;,,</span>
<span class="sd">                                     &quot;mix&quot;, &quot;mixed&quot;,&quot;merge&quot;,&quot;mer&quot;,</span>
<span class="sd">                                     &quot;both&quot;,&quot;num&amp;val&quot;,&quot;val&amp;num&amp;&quot;]</span>
<span class="sd">                 it seems not possible to convert to float or integer.</span>
<span class="sd">                 the defaut is mixed </span>
<span class="sd">                 </span>
<span class="sd">    </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Tuple of input character</span>
<span class="sd">        must be return tuple of float value, or string value </span>
<span class="sd">        </span>
<span class="sd">    example ::</span>
<span class="sd">            ss=dump_comma(input_car=&quot;,car,box&quot;, max_value=3, </span>
<span class="sd">                  carType=&quot;str&quot;)</span>
<span class="sd">            print(ss)</span>
<span class="sd">            &gt;&gt;&gt; (&#39;0&#39;, &#39;car&#39;, &#39;box&#39;)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    
    
        <span class="c1"># dump &quot;,&quot; at the end of </span>
    <span class="n">flag</span><span class="o">=</span><span class="mi">0</span>
    
    <span class="k">if</span> <span class="n">input_car</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;,&quot;</span><span class="p">:</span>
        <span class="n">input_car</span><span class="o">=</span><span class="n">input_car</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">input_car</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;,&quot;</span><span class="p">:</span>
        <span class="n">input_car</span><span class="o">=</span><span class="s2">&quot;0,&quot;</span><span class="o">+</span> <span class="n">input_car</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        
    <span class="k">if</span> <span class="n">carType</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">,</span><span class="s1">&#39;val&#39;</span><span class="p">,</span><span class="s2">&quot;numeric&quot;</span><span class="p">,</span>
                           <span class="s2">&quot;num&quot;</span><span class="p">,</span> <span class="s2">&quot;num&quot;</span><span class="p">,</span><span class="s2">&quot;float&quot;</span><span class="p">,</span><span class="s2">&quot;int&quot;</span><span class="p">]:</span>
        <span class="n">input_car</span><span class="o">=</span><span class="nb">eval</span><span class="p">(</span><span class="n">input_car</span><span class="p">)</span>
        
    <span class="k">elif</span> <span class="n">carType</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;car&quot;</span><span class="p">,</span><span class="s2">&quot;character&quot;</span><span class="p">,</span><span class="s2">&quot;ch&quot;</span><span class="p">,</span><span class="s2">&quot;char&quot;</span><span class="p">,</span><span class="s2">&quot;str&quot;</span><span class="p">,</span>
                             <span class="s2">&quot;mix&quot;</span><span class="p">,</span> <span class="s2">&quot;mixed&quot;</span><span class="p">,</span><span class="s2">&quot;merge&quot;</span><span class="p">,</span><span class="s2">&quot;mer&quot;</span><span class="p">,</span>
                             <span class="s2">&quot;both&quot;</span><span class="p">,</span><span class="s2">&quot;num&amp;val&quot;</span><span class="p">,</span><span class="s2">&quot;val&amp;num&amp;&quot;</span><span class="p">]:</span>
        
        <span class="n">input_car</span><span class="o">=</span><span class="n">input_car</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
        <span class="n">flag</span><span class="o">=</span><span class="mi">1</span>
        
    <span class="c1"># elif carType.lower() in [&quot;mix&quot;, &quot;mixed&quot;,&quot;merge&quot;,&quot;mer&quot;,</span>
    <span class="c1">#                          &quot;both&quot;,&quot;num&amp;val&quot;,&quot;val&amp;num&amp;&quot;]:</span>
    <span class="c1">#     input_car=input_car.split(&quot;,&quot;)</span>
    
        
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">input_car</span><span class="p">)</span><span class="o">==</span><span class="kc">False</span> <span class="p">:</span>
        <span class="n">inputlist</span><span class="o">=</span><span class="p">[</span><span class="n">input_car</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># input_car=tuple(inputlist)</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">input_car</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">True</span> <span class="p">:</span>
        <span class="c1"># if flag==1 :</span>
        <span class="c1">#     inputlist=input_car</span>
        <span class="c1">#     # print(inputlist)</span>
        <span class="c1"># else :</span>
        <span class="n">inputlist</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">input_car</span><span class="p">)</span>
            
        <span class="c1"># print(&quot;false&quot;)</span>
    
    <span class="n">input_car</span><span class="o">=</span><span class="n">inputlist</span><span class="p">[:</span><span class="n">max_value</span><span class="p">]</span>
    <span class="c1"># print(input_car)</span>
    <span class="k">if</span> <span class="n">flag</span><span class="o">==</span><span class="mi">1</span> <span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputlist</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span> <span class="p">:</span>
            <span class="k">return</span><span class="p">(</span><span class="n">inputlist</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">input_car</span><span class="p">)</span></div>

                    
<div class="viewcode-block" id="build_wellData"><a class="viewcode-back" href="../../../utils.html#csamtpy.utils.func_utils.build_wellData">[docs]</a><span class="k">def</span> <span class="nf">build_wellData</span> <span class="p">(</span><span class="n">add_azimuth</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">utm_zone</span><span class="o">=</span><span class="s2">&quot;49N&quot;</span><span class="p">,</span>
                    <span class="n">report_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">add_geochemistry_sample</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    add_azimuth : Bool, optional</span>
<span class="sd">        compute azimuth if add_azimut is set to True. The default is False.</span>
<span class="sd">        </span>
<span class="sd">    utm_zone : Str, optional</span>
<span class="sd">        WGS84 utm_projection. set your zone if add_azimuth is turn to True. </span>
<span class="sd">        The default is &quot;49N&quot;.</span>
<span class="sd">        </span>
<span class="sd">    report_path : str, optional</span>
<span class="sd">        path to save your _well_report. The default is None.</span>
<span class="sd">        its match the current work directory </span>
<span class="sd">        </span>
<span class="sd">    add_geochemistry_sample: bool</span>
<span class="sd">        add_sample_data.Set to True if you want to add_mannually Geochimistry data.</span>
<span class="sd">        default is False.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    Exception</span>
<span class="sd">        manage the dimentionaly of ndarrays .</span>
<span class="sd">    OSError</span>
<span class="sd">        when report_path is not found in your O.S.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    name_of_location : str</span>
<span class="sd">        name of location of well .</span>
<span class="sd">    WellData : np.ndarray</span>
<span class="sd">        data of build Wells .</span>
<span class="sd">    GeolData : np.ndarray</span>
<span class="sd">        data of build geology.</span>

<span class="sd">    eg::</span>
<span class="sd">        import numpy as np </span>
<span class="sd">        import os, shutil</span>
<span class="sd">        import warnings,</span>
<span class="sd">        form _utils.avgpylog import AvgPyLog</span>
<span class="sd">        </span>
<span class="sd">        _logger=AvgPyLog.get_avgpy_logger(__name__)</span>
<span class="sd">        </span>
<span class="sd">        well=build_wellData (add_azimuth=True, utm_zone=&quot;49N&quot;)</span>
<span class="sd">        print(&quot;nameof locations\n:&quot;,well[0])</span>
<span class="sd">        print(&quot;CollarData\n:&quot;,well[1])</span>
<span class="sd">        print(&quot;GeolData\n:&quot;,well[2])</span>
<span class="sd">        </span>
<span class="sd">        ...&gt;&gt;&gt; outputs ::</span>
<span class="sd">                nameof locations</span>
<span class="sd">                : Shimen</span>
<span class="sd">                CollarData</span>
<span class="sd">                : [[&#39;S01&#39; &#39;477205.6935&#39; &#39;2830978.218&#39; &#39;987.25&#39; &#39;-90&#39; &#39;0.0&#39; &#39;Shi01&#39;</span>
<span class="sd">                  &#39;Wdanxl0&#39;]</span>
<span class="sd">                 [&#39;S18&#39; &#39;477915.4355&#39; &#39;2830555.927&#39; &#39;974.4&#39; &#39;-90&#39; &#39;2.111&#39; &#39;Shi18&#39;</span>
<span class="sd">                  &#39;Wdanxl0&#39;]]</span>
<span class="sd">                GeolData</span>
<span class="sd">                : [[&#39;S01&#39; &#39;0.0&#39; &#39;240.2&#39; &#39;granite&#39;]</span>
<span class="sd">                 [&#39;S01&#39; &#39;240.2&#39; &#39;256.4&#39; &#39; basalte&#39;]</span>
<span class="sd">                 [&#39;S01&#39; &#39;256.4&#39; &#39;580.0&#39; &#39; granite&#39;]</span>
<span class="sd">                 [&#39;S01&#39; &#39;580.0&#39; &#39;987.25&#39; &#39;rock&#39;]</span>
<span class="sd">                 [&#39;S18&#39; &#39;0.0&#39; &#39;110.3&#39; &#39;sand&#39;]</span>
<span class="sd">                 [&#39;S18&#39; &#39;110.3&#39; &#39;520.2&#39; &#39;agrilite&#39;]</span>
<span class="sd">                 [&#39;S18&#39; &#39;520.2&#39; &#39;631.3&#39; &#39; granite&#39;]</span>
<span class="sd">                 [&#39;S18&#39; &#39;631.3&#39; &#39;974.4&#39; &#39; rock&#39;]]</span>
<span class="sd">            outputfile :Shimen_wellReports_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">reg_lines</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">wellSites</span><span class="p">,</span><span class="n">ftgeo</span><span class="p">,</span><span class="n">hole_list</span><span class="p">,</span><span class="n">Geolist</span><span class="o">=</span><span class="p">[],[],[],[]</span>
    
    <span class="n">text</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Enter the name of Location:&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;well_name :&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;Coordinates (Easting, Northing)_UTM_</span><span class="si">{0}</span><span class="s2"> : &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">utm_zone</span><span class="p">),</span>
                      <span class="s2">&quot;Hole Buttom  and dip values (Bottom, dip):&quot;</span> <span class="p">,</span>
                      <span class="s2">&quot;Layers-thickness levels in (meters):&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;Geology-layers or &lt;stratigraphy&gt; names (Top_To_Buttom):&quot;</span><span class="p">,</span> 
                      <span class="s2">&quot;</span><span class="si">{0:-^70}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39; Report &#39;</span><span class="p">),</span>
                      
                      <span class="s2">&quot;DH_Hole,DH_Easting, DH_Northing, DH_Buttom,&quot;</span>\
                      <span class="s2">&quot; DH_Dip,DH_Azimuth, DH_PlanDepth,DH_Descrip&quot;</span><span class="p">,</span>
                      
                      <span class="s2">&quot;GeolData :&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;WellData:&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;DH_Hole, DH_From, DH_To, Rock&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;SampleData&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;DH_Hole, DH_From,DH_To, Sample&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;</span><span class="si">{0:-^70}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39; InputData &#39;</span><span class="p">),</span>
                      <span class="p">]</span>
    
    
    <span class="n">name_of_location</span> <span class="o">=</span><span class="nb">input</span><span class="p">(</span><span class="s2">&quot;Enter the name of Location:&quot;</span><span class="p">)</span>
    <span class="n">reg_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;</span><span class="si">{0:&gt;18}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name_of_location</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">))</span>
    <span class="n">reg_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">reg_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    
    <span class="n">comp</span><span class="o">=-</span><span class="mi">1</span>
    <span class="k">while</span> <span class="mi">1</span> <span class="p">:</span>
        <span class="n">DH_Hole</span><span class="o">=</span><span class="nb">input</span><span class="p">(</span><span class="s2">&quot;Enter the well_name :&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">DH_Hole</span><span class="o">==</span><span class="s2">&quot;&quot;</span> <span class="ow">or</span> <span class="n">DH_Hole</span><span class="o">==</span><span class="s2">&quot;end&quot;</span><span class="p">:</span>
            <span class="n">Geol</span><span class="o">=</span><span class="n">concat_array_from_list</span><span class="p">(</span><span class="n">list_of_array</span><span class="o">=</span><span class="n">Geolist</span><span class="p">,</span>
                                            <span class="n">concat_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">break</span>
         
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Enter the coordinates (Easting, Northing) : &quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">DH_East_North</span><span class="o">=</span><span class="nb">input</span><span class="p">()</span>
        <span class="n">DH_East_North</span><span class="o">=</span><span class="n">dump_comma</span><span class="p">(</span><span class="n">input_car</span><span class="o">=</span><span class="n">DH_East_North</span><span class="p">,</span>
                                 <span class="n">max_value</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">carType</span><span class="o">=</span><span class="s1">&#39;value&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Enter the Hole Bottom value and dip (Bottom, dip):&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">dh_botdip</span><span class="o">=</span><span class="nb">input</span><span class="p">()</span>
        <span class="n">dh_botdip</span><span class="o">=</span><span class="n">dump_comma</span><span class="p">(</span><span class="n">input_car</span><span class="o">=</span><span class="n">dh_botdip</span><span class="p">,</span>
                                 <span class="n">max_value</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">carType</span><span class="o">=</span><span class="s1">&#39;value&#39;</span><span class="p">)</span>
        <span class="c1">#check  the dip of the well </span>
        <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">dh_botdip</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">==</span><span class="mf">0.</span><span class="p">:</span>
            <span class="n">dh_botdip</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="mf">90.</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">float</span><span class="p">(</span><span class="n">dh_botdip</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">==</span><span class="mf">0.</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
            <span class="s2">&quot;The curent bottom has a value 0.0 . Must put the bottom of the well as deep as possible !&quot;</span>
                            <span class="p">)</span>
            
        <span class="n">hole_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">DH_Hole</span><span class="p">)</span>

        <span class="n">wellSites</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">DH_Hole</span><span class="p">,</span> <span class="n">DH_East_North</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">DH_East_North</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                          <span class="n">dh_botdip</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">dh_botdip</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">))</span>

        <span class="c1">#DH_Hole (ID)	DH_East	DH_North	DH_RH	DH_Dip	DH_Azimuth	DH_Top	DH_Bottom	DH_PlanDepth	DH_Decr	Mask </span>
        <span class="n">reg_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;</span><span class="si">{0:&gt;7}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">DH_Hole</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">reg_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">reg_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;</span><span class="si">{0:&gt;14}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ii</span><span class="p">))</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">DH_East_North</span><span class="p">)])</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">reg_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">reg_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;</span><span class="si">{0:&gt;7}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ii</span><span class="p">))</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">dh_botdip</span><span class="p">)])</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">comp</span><span class="o">+=-</span><span class="mi">1</span>
        <span class="k">while</span> <span class="n">DH_Hole</span> <span class="p">:</span>
            <span class="c1"># print(&quot;Enter the layer thickness (From_, _To, geology):&quot;,end=&#39;&#39;)</span>
            <span class="k">if</span> <span class="n">comp</span><span class="o">==-</span><span class="mi">1</span> <span class="p">:</span>
                <span class="n">Geol</span><span class="o">=</span><span class="n">concat_array_from_list</span><span class="p">(</span><span class="n">list_of_array</span><span class="o">=</span><span class="n">ftgeo</span><span class="p">,</span>
                                            <span class="n">concat_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                
                <span class="n">ftgeo</span><span class="o">=</span><span class="p">[]</span>        <span class="c1">#  initialize temporary list </span>
                
                <span class="k">break</span>
            <span class="c1"># comp=comp+1</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Enter the layers-thickness levels in (meters):&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="n">dh_from_in</span><span class="o">=</span><span class="nb">input</span><span class="p">()</span>
            
            <span class="k">if</span> <span class="n">dh_from_in</span><span class="o">==</span><span class="s2">&quot;&quot;</span> <span class="ow">or</span> <span class="n">dh_from_in</span><span class="o">==</span><span class="s2">&quot;end&quot;</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="n">dh_from</span><span class="o">=</span><span class="nb">eval</span><span class="p">(</span><span class="n">dh_from_in</span><span class="p">)</span>
            
            <span class="n">dh_from_ar</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dh_from</span><span class="p">)</span>
            <span class="n">dh_from_ar</span><span class="o">=</span><span class="n">dh_from_ar</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">dh_from_ar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">))</span> 
            <span class="c1"># check the last input bottom : </span>
            <span class="k">if</span> <span class="n">dh_from_ar</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dh_botdip</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;The input bottom of well {{0}}, is {{1}}. It&#39;s less last layer thickess: {{2}}.&quot;</span>\
                             <span class="s2">&quot;we add maximum bottom at 1.023km depth.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">DH_Hole</span><span class="p">,</span><span class="n">dh_botdip</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                                          <span class="n">dh_from_ar</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">dh_botdip</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="mf">1023.</span><span class="p">)</span>
                <span class="n">wellSites</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span><span class="n">dh_botdip</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># last append of wellSites </span>
            <span class="c1">#find Dh_to through give dh_from</span>
            
            <span class="n">dh_to</span><span class="o">=</span><span class="n">dh_from_ar</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">dh_to</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dh_to</span><span class="p">,</span><span class="n">dh_botdip</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">dh_to</span><span class="o">=</span><span class="n">dh_to</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">dh_to</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">))</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Enter the geology-layers names (From _To):&quot;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">rock</span><span class="o">=</span><span class="nb">input</span><span class="p">()</span>
            <span class="n">rock</span><span class="o">=</span><span class="n">rock</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span> <span class="c1"># strip in the case where &quot;,&quot;appear at the end </span>
            <span class="n">rock_ar</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rock</span><span class="p">)</span>
            <span class="n">rock_ar</span><span class="o">=</span><span class="n">rock_ar</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">rock_ar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">))</span>

            <span class="k">try</span> <span class="p">:</span>
                <span class="k">if</span> <span class="n">rock_ar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">dh_from_ar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">drill_names</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">rock_ar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">),</span><span class="n">DH_Hole</span><span class="p">)</span>
                <span class="n">fromtogeo</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">drill_names</span><span class="p">,</span><span class="n">dh_from_ar</span><span class="p">,</span>
                                              <span class="n">dh_to</span><span class="p">,</span> <span class="n">rock_ar</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;np.ndarry sizeError:Check &#39;geologie&#39;, &#39;Dh_From&#39;, and &quot;</span>\
                             <span class="s2">&quot;&#39;Dh_To&#39; arrays size properly . It seems one size is &quot;</span>\
                                 <span class="s2">&quot; too longeR than another. &quot;</span><span class="p">)</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot; All the arrays size must match propertly!&quot;</span><span class="p">)</span>
                
            <span class="n">ftgeo</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fromtogeo</span><span class="p">)</span>
            <span class="n">comp</span><span class="o">=-</span><span class="mi">1</span>
            
            <span class="n">reg_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">reg_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;</span><span class="si">{0:&gt;7}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">jj</span><span class="p">))</span>  <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">dh_from</span><span class="p">)])</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">reg_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">reg_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;</span><span class="si">{0:&gt;12}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">jj</span><span class="p">)</span> <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="n">rock</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span> <span class="c1"># rock already in list </span>
            <span class="c1"># reg_lines.append(&quot;&quot;.join(rock+&quot;\n&quot;))</span>
            
        <span class="n">reg_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">Geolist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Geol</span><span class="p">)</span>    


    <span class="n">name_of_location</span><span class="o">=</span><span class="n">name_of_location</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span>
    <span class="c1">#set on numpy array</span>
    
    <span class="k">for</span> <span class="n">ii</span> <span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">wellSites</span><span class="p">):</span>
        <span class="n">value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="n">wellSites</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">=</span><span class="n">value</span>
    <span class="c1">#create a wellsites array </span>
    
    <span class="n">wellSites</span><span class="o">=</span><span class="n">concat_array_from_list</span><span class="p">(</span><span class="n">wellSites</span><span class="p">,</span><span class="n">concat_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">DH_Hole</span><span class="o">=</span><span class="n">wellSites</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">DH_PlanDepth</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">wellSites</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],),</span><span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;&lt;U8&quot;</span><span class="p">)</span>
    <span class="n">DH_Decr</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">wellSites</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],),</span><span class="s2">&quot;Wdanxl0&quot;</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;&lt;U9&quot;</span><span class="p">)</span>
    
    
    <span class="n">lenloc</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">name_of_location</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">DH_Hole</span><span class="p">):</span>
         <span class="c1"># in order to keep all the well name location</span>
        <span class="n">DH_PlanDepth</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">name_of_location</span><span class="p">[:</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">lenloc</span><span class="o">/</span><span class="mi">2</span><span class="p">)]</span><span class="o">+</span><span class="n">row</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:])</span>

    <span class="n">Geol</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">Geol</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]])</span>
    <span class="n">Geol</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">Geol</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]])</span>
    
    <span class="k">if</span> <span class="n">add_azimuth</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
        <span class="n">DH_Azimuth</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">wellSites</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">add_azimuth</span> <span class="o">==</span> <span class="kc">True</span> <span class="p">:</span>
        <span class="n">DH_Azimuth</span><span class="o">=</span><span class="n">compute_azimuth</span><span class="p">(</span><span class="n">easting</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">wellSites</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]),</span>
                                   <span class="n">northing</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">wellSites</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]]),</span>
                                   <span class="n">utm_zone</span><span class="o">=</span><span class="n">utm_zone</span><span class="p">)</span>

        
    <span class="n">DH_Azimuth</span><span class="o">=</span><span class="n">DH_Azimuth</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">DH_Azimuth</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">))</span>
    
    
    <span class="n">WellData</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">wellSites</span><span class="p">,</span><span class="n">DH_Azimuth</span><span class="p">,</span>
                             <span class="n">DH_PlanDepth</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">DH_PlanDepth</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">)),</span>
                             <span class="n">DH_Decr</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">DH_Decr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">))),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">GeolData</span><span class="o">=</span><span class="n">Geol</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1">#-----write Report---</span>
    
    <span class="n">reg_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="c1"># reg_lines.append(text[7]+&quot;\n&quot;)</span>
    
    <span class="n">reg_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">reg_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;</span><span class="si">{0:&gt;12}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ss</span><span class="p">)</span> <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">text</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)])</span> <span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">rowline</span> <span class="ow">in</span> <span class="n">WellData</span> <span class="p">:</span>
        <span class="n">reg_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;</span><span class="si">{0:&gt;12}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ss</span><span class="p">)</span> <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">rowline</span><span class="o">.</span><span class="n">tolist</span><span class="p">()])</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="n">reg_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">reg_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;</span><span class="si">{0:&gt;12}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ss</span><span class="p">)</span> <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">text</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)])</span> <span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">GeolData</span><span class="p">):</span>
        <span class="n">reg_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;</span><span class="si">{0:&gt;12}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ss</span><span class="p">)</span> <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">row</span><span class="o">.</span><span class="n">tolist</span><span class="p">()])</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">add_geochemistry_sample</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
        <span class="n">SampleData</span><span class="o">=</span><span class="n">build_geochemistry_sample</span><span class="p">()</span>
        <span class="n">reg_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">reg_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;</span><span class="si">{0:&gt;12}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ss</span><span class="p">)</span> <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">text</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)])</span> <span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">SampleData</span><span class="p">):</span>
            <span class="n">reg_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;</span><span class="si">{0:&gt;12}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ss</span><span class="p">)</span> <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">row</span><span class="o">.</span><span class="n">tolist</span><span class="p">()])</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span> <span class="p">:</span>
        <span class="n">SampleData</span><span class="o">=</span><span class="kc">None</span>        
        

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">_wellReport_&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name_of_location</span><span class="p">),</span><span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fid</span><span class="p">:</span>
        <span class="c1"># for ii in reg_lines :</span>
        <span class="n">fid</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="n">reg_lines</span><span class="p">)</span>
    <span class="n">fid</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    
    <span class="c1">#---end write report---</span>
    
    <span class="k">if</span> <span class="n">report_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">report_path</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">report_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="p">:</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">report_path</span><span class="p">):</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">((</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">_wellReport_&quot;</span><span class="o">.</span>\
                                      <span class="nb">format</span><span class="p">(</span><span class="n">name_of_location</span><span class="p">))),</span><span class="n">report_path</span><span class="p">)</span>
        <span class="k">else</span> <span class="p">:</span>
            <span class="k">raise</span> <span class="ne">OSError</span> <span class="p">(</span><span class="s2">&quot;The path does not match in your O.S .Try to put the right path&quot;</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span> <span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span><span class="s2">&quot;the report_path doesn&#39;t match properly.Try to fix it !&quot;</span><span class="p">)</span>
        
    
    
    <span class="k">return</span> <span class="p">(</span><span class="n">name_of_location</span><span class="p">,</span> <span class="n">WellData</span> <span class="p">,</span> <span class="n">GeolData</span><span class="p">,</span> <span class="n">SampleData</span><span class="p">)</span></div>
        
        
<div class="viewcode-block" id="compute_azimuth"><a class="viewcode-back" href="../../../utils.html#csamtpy.utils.func_utils.compute_azimuth">[docs]</a><span class="k">def</span> <span class="nf">compute_azimuth</span><span class="p">(</span><span class="n">easting</span><span class="p">,</span> <span class="n">northing</span><span class="p">,</span> <span class="n">utm_zone</span><span class="o">=</span><span class="s2">&quot;49N&quot;</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    *easting : np.ndarray</span>
<span class="sd">        Easting value of coordinates _UTM_WGS84 </span>
<span class="sd">        </span>
<span class="sd">    *northing : np.ndarray</span>
<span class="sd">        Northing value of coordinates._UTM_WGS84</span>
<span class="sd">        </span>
<span class="sd">    *utm_zone : str, optional</span>
<span class="sd">        the utm_zone . if None try to get is through </span>
<span class="sd">        gis.get_utm_zone(latitude, longitude). </span>
<span class="sd">        latitude and longitude must be on degree decimals. The default is &quot;49N&quot;.</span>
<span class="sd">    *extrapolate : bool , </span>
<span class="sd">        for other purpose , user can extrapolate azimuth value , in order to get the sizesize as </span>
<span class="sd">        the easting and northing size. The the value will repositionate at each point data were collected. </span>
<span class="sd">            Default is False as originally azimuth computation . </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">            np.ndarray</span>
<span class="sd">        azimuth.</span>
<span class="sd">        </span>
<span class="sd">        eg.::</span>
<span class="sd">            &gt;&gt; import gis_tools as gis </span>
<span class="sd">                easting=[477205.6935,477261.7258,477336.4355,477373.7903,477448.5,</span>
<span class="sd">                 477532.5484,477588.5806,477616.5968]</span>
<span class="sd">                northing=[2830978.218, 2830944.879,2830900.427, 2830878.202,2830833.75,</span>
<span class="sd">                              2830783.742,2830750.403,2830733.734]</span>
<span class="sd">                </span>
<span class="sd">                test=compute_azimuth(easting=np.array(easting), </span>
<span class="sd">                                     northing=np.array(northing), utm_zone=&quot;49N&quot;)</span>
<span class="sd">                print(test)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#---**** method to compute azimuth****----</span>
    
    <span class="n">reference_ellipsoid</span><span class="o">=</span><span class="mi">23</span>
    
    <span class="n">lat</span><span class="p">,</span><span class="n">long</span><span class="o">=</span><span class="n">gis</span><span class="o">.</span><span class="n">utm_to_ll</span><span class="p">(</span><span class="n">reference_ellipsoid</span><span class="o">=</span><span class="n">reference_ellipsoid</span><span class="p">,</span>
                                <span class="n">northing</span><span class="o">=</span><span class="n">northing</span><span class="p">,</span> <span class="n">easting</span><span class="o">=</span><span class="n">easting</span><span class="p">,</span> <span class="n">zone</span><span class="o">=</span><span class="n">utm_zone</span><span class="p">)</span>
    
    <span class="c1">#i, idx, ic_=0,0,pi/180</span>
    <span class="n">azimuth</span><span class="o">=</span><span class="mi">0</span>
    
    <span class="n">i</span><span class="p">,</span><span class="n">ic_</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span><span class="mi">180</span>
    
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">lat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">xl</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">ic_</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lat</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">ic_</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">ic_</span><span class="p">)</span>\
            <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">ic_</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">((</span><span class="n">long</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">long</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="n">ic_</span><span class="p">)</span>
        <span class="n">yl</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">((</span><span class="n">long</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">long</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="n">ic_</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">azim</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">yl</span><span class="p">,</span><span class="n">xl</span><span class="p">)</span>
        <span class="n">azimuth</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">azimuth</span><span class="p">,</span> <span class="n">azim</span><span class="p">)</span>
        <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="n">lat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span> <span class="p">:</span>
            <span class="c1"># azimuth.append(0)</span>
            <span class="k">break</span>
    
    
    <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">True</span> <span class="p">:</span> 
        <span class="c1"># interpolate azimuth to find the azimuth to first station considered to 0.</span>
    
        <span class="n">ff</span><span class="o">=</span><span class="n">spi</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">azimuth</span><span class="o">.</span><span class="n">size</span><span class="p">),</span>
                                   <span class="n">y</span><span class="o">=</span><span class="n">azimuth</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">fill_value</span><span class="o">=</span><span class="s1">&#39;extrapolate&#39;</span><span class="p">)</span>
        <span class="n">y_new</span> <span class="p">,</span> <span class="n">azim</span> <span class="o">=</span> <span class="n">ff</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">azimuth</span><span class="p">)</span>
        <span class="n">azim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">azim</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">y_new</span> <span class="p">,</span> <span class="n">azimuth</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">else</span> <span class="p">:</span> 
        <span class="n">azim</span><span class="o">=</span><span class="n">azimuth</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="c1"># substract the zero value added for computation as origin.</span>
    <span class="c1">#convert to degree : modulo 45degree</span>
    <span class="n">azim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="k">lambda</span> <span class="n">zz</span> <span class="p">:</span> <span class="n">zz</span> <span class="o">*</span> <span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">azim</span><span class="p">)</span> 
    
    
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">azim</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="build_geochemistry_sample"><a class="viewcode-back" href="../../../utils.html#csamtpy.utils.func_utils.build_geochemistry_sample">[docs]</a><span class="k">def</span> <span class="nf">build_geochemistry_sample</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build geochemistry_sample_data</span>
<span class="sd">    </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    </span>
<span class="sd">        Process to build geochemistry sample data manually .</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Sample : np.ndarray</span>
<span class="sd">    </span>
<span class="sd">        Geochemistry sample Data.</span>

<span class="sd">    eg.::</span>
<span class="sd">            geoch=build_geochemistry_sample()</span>
<span class="sd">              print(geoch)</span>
<span class="sd">        &gt;&gt;&gt;: output sampleData</span>
<span class="sd">            [[&#39;S0X4&#39; &#39;0&#39; &#39;254.0&#39; &#39;PUP&#39;]</span>
<span class="sd">             [&#39;S0X4&#39; &#39;254&#39; &#39;521.0&#39; &#39;mg&#39;]</span>
<span class="sd">             [&#39;S0X4&#39; &#39;521&#39; &#39;625.0&#39; &#39;tut&#39;]</span>
<span class="sd">             [&#39;S0X4&#39; &#39;625&#39; &#39;984.0&#39; &#39;suj&#39;]</span>
<span class="sd">             [&#39;S0X2&#39; &#39;0&#39; &#39;19.0&#39; &#39;pup&#39;]</span>
<span class="sd">             [&#39;S0X2&#39; &#39;19&#39; &#39;425.0&#39; &#39;hut&#39;]</span>
<span class="sd">             [&#39;S0X2&#39; &#39;425&#39; &#39;510.0&#39; &#39;mgt&#39;]</span>
<span class="sd">             [&#39;S0X2&#39; &#39;510&#39; &#39;923.2&#39; &#39;pyt&#39;]]</span>
<span class="sd">                </span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">tempsamp</span><span class="p">,</span><span class="n">SampleList</span><span class="o">=</span><span class="p">[],[]</span>
    <span class="n">comp</span><span class="o">=-</span><span class="mi">1</span>
    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Enter Hole Name or &lt;Enter/end&gt; to stop:&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">holeName</span><span class="o">=</span><span class="nb">input</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">holeName</span><span class="o">==</span><span class="s2">&quot;&quot;</span> <span class="ow">or</span> <span class="n">holeName</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;stop&quot;</span><span class="p">,</span><span class="s2">&quot;end&quot;</span><span class="p">,</span><span class="s2">&quot;enter&quot;</span><span class="p">,</span>
                                                <span class="s2">&quot;finish&quot;</span><span class="p">,</span><span class="s2">&quot;close&quot;</span><span class="p">]:</span>
            <span class="n">Sample</span><span class="o">=</span><span class="n">concat_array_from_list</span><span class="p">(</span><span class="n">list_of_array</span><span class="o">=</span><span class="n">SampleList</span><span class="p">,</span>
                                          <span class="n">concat_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">break</span>
        <span class="n">comp</span><span class="o">=</span><span class="n">comp</span><span class="o">+</span><span class="mi">1</span>
        <span class="n">samp_buttom</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s2">&quot;Enter the buttom of the sampling (m):&quot;</span><span class="p">))</span>
        
        <span class="k">while</span> <span class="n">holeName</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">comp</span><span class="o">==-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">samP</span><span class="o">=</span><span class="n">concat_array_from_list</span><span class="p">(</span><span class="n">list_of_array</span><span class="o">=</span><span class="n">tempsamp</span><span class="p">,</span><span class="n">concat_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">tempsamp</span><span class="o">=</span><span class="p">[]</span>
                <span class="k">break</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Enter the sampling levels:&quot;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="n">samplevel</span><span class="o">=</span><span class="nb">input</span><span class="p">()</span>    
            <span class="n">samplevel</span><span class="o">=</span><span class="n">dump_comma</span><span class="p">(</span><span class="n">input_car</span><span class="o">=</span><span class="n">samplevel</span><span class="p">,</span> <span class="n">max_value</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> 
                            <span class="n">carType</span><span class="o">=</span><span class="s1">&#39;value&#39;</span><span class="p">)</span>
            <span class="n">samp_ar</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">samplevel</span><span class="p">))</span>
            <span class="n">samp_ar</span><span class="o">=</span><span class="n">samp_ar</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">samp_ar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">))</span>
            
            <span class="n">dh_to</span><span class="o">=</span><span class="n">samp_ar</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">dh_to</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dh_to</span><span class="p">,</span><span class="n">samp_buttom</span><span class="p">)</span>
            <span class="n">dh_to</span><span class="o">=</span><span class="n">dh_to</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">dh_to</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">))</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Enter the samples&#39; names:&quot;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="n">sampName</span><span class="o">=</span><span class="nb">input</span><span class="p">()</span>
            <span class="n">sampName</span><span class="o">=</span><span class="n">dump_comma</span><span class="p">(</span><span class="n">input_car</span><span class="o">=</span><span class="n">sampName</span><span class="p">,</span> <span class="n">max_value</span><span class="o">=</span><span class="n">samp_ar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                            <span class="n">carType</span><span class="o">=</span><span class="s1">&#39;mixed&#39;</span><span class="p">)</span>
            <span class="n">sampName_ar</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">sampName</span><span class="p">))</span>
            <span class="n">sampName_ar</span><span class="o">=</span><span class="n">sampName_ar</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">sampName_ar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">try</span> <span class="p">:</span>
                <span class="n">holes_names</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">sampName_ar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">),</span><span class="n">holeName</span><span class="p">)</span>
                <span class="n">samfromto</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">holes_names</span><span class="p">,</span><span class="n">samp_ar</span><span class="p">,</span><span class="n">dh_to</span><span class="p">,</span><span class="n">sampName_ar</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span> <span class="p">:</span>
                <span class="k">raise</span> <span class="p">(</span><span class="s2">&quot;IndexError!, arrrays sample_DH_From:</span><span class="si">{0}</span><span class="s2"> &amp;DH_To :</span><span class="si">{1}</span><span class="s2">&amp;&quot;</span>\
                       <span class="s2">&quot; &#39;Sample&#39;:</span><span class="si">{2}</span><span class="s2"> doesn&#39;t not match proprerrly.</span><span class="si">{3}</span><span class="s2">&quot;</span><span class="o">.</span>\
                           <span class="nb">format</span><span class="p">(</span><span class="n">samp_ar</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dh_to</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">sampName_ar</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;IndexError !, dimentional problem.&quot;</span>\
                              <span class="s2">&quot; please check np.ndarrays.shape.&quot;</span><span class="p">)</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;IndexError !, dimentional problem.&quot;</span>\
                              <span class="s2">&quot; please check np.ndarrays.shape.&quot;</span><span class="p">)</span>
            <span class="n">tempsamp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">samfromto</span><span class="p">)</span>
            <span class="n">comp</span><span class="o">=-</span><span class="mi">1</span>
        <span class="n">SampleList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">samP</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">Sample</span></div>



<div class="viewcode-block" id="parse_wellData"><a class="viewcode-back" href="../../../utils.html#csamtpy.utils.func_utils.parse_wellData">[docs]</a><span class="k">def</span> <span class="nf">parse_wellData</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include_azimuth</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">utm_zone</span><span class="o">=</span><span class="s2">&quot;49N&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to parse well information in*csv file </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename : str, optional</span>
<span class="sd">        DESCRIPTION. The default is None.</span>
<span class="sd">    include_azimuth: bool , </span>
<span class="sd">        Way to compute azimuth automatically </span>
<span class="sd">        </span>
<span class="sd">    utm_zone : str, </span>
<span class="sd">        set coordinate _utm_WGS84. Defaut is 49N</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    FileNotFoundError</span>
<span class="sd">        if typical file deoesnt match the *csv file.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    name_of_location : str</span>
<span class="sd">        Name of location .</span>
<span class="sd">    WellData : np.ndarray</span>
<span class="sd">        Specificy the collar Data .</span>
<span class="sd">    GeoData : np.ndarray</span>
<span class="sd">        specify the geology data .</span>
<span class="sd">    SampleData : TYPE</span>
<span class="sd">        geochemistry sample Data.</span>


<span class="sd">    e.g. :: </span>
<span class="sd">            dir_=r&quot;F:\OneDrive\Python\CodesExercices\ex_avgfiles\modules&quot;</span>
<span class="sd">            os.chdir(dir_)</span>
<span class="sd">            parse_=parse_wellData(filename=&#39;Drill&amp;GeologydataT.csv&#39;)</span>
<span class="sd">            </span>
<span class="sd">            print(&quot;NameOflocation:\n&quot;,parse_[0])</span>
<span class="sd">            print(&quot;WellData:\n&quot;,parse_[1])</span>
<span class="sd">            print(&quot;GeoData:\n&quot;,parse_[2])</span>
<span class="sd">            print(&quot;Sample:\n&quot;,parse_[3])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    
    
    <span class="n">identity</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;DH_Hole (ID)&quot;</span><span class="p">,</span><span class="s2">&quot;DH_East&quot;</span><span class="p">,</span><span class="s2">&quot;DH_North&quot;</span><span class="p">,</span><span class="s2">&quot;DH_Dip&quot;</span><span class="p">,</span>
              <span class="s2">&quot;Elevation&quot;</span> <span class="p">,</span><span class="s1">&#39;DH_Azimuth&#39;</span><span class="p">,</span><span class="s2">&quot;DH_Top&quot;</span><span class="p">,</span><span class="s2">&quot;DH_Bottom&quot;</span><span class="p">,</span>
              <span class="s2">&quot;DH_PlanDepth&quot;</span><span class="p">,</span><span class="s2">&quot;DH_Decr&quot;</span><span class="p">,</span><span class="s2">&quot;Mask &quot;</span><span class="p">]</span>
    
    <span class="n">car</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">ss</span> <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">identity</span><span class="p">])</span>
    <span class="c1"># print(car)</span>
    
    <span class="c1">#ckeck the if it is the correct file</span>
    <span class="n">_flag</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span>
        <span class="n">filename</span><span class="o">=</span><span class="p">[</span><span class="n">file</span> <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">())</span> \
                  <span class="k">if</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="ow">and</span> <span class="n">file</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.csv&quot;</span><span class="p">))]</span>
        <span class="c1"># print(filename)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span> <span class="p">(</span><span class="n">filename</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">filename</span> <span class="p">:</span>
                <span class="k">with</span> <span class="nb">open</span> <span class="p">(</span><span class="n">file</span><span class="p">,</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span> <span class="p">:</span>
                    <span class="n">data</span><span class="o">=</span><span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
                    <span class="n">_flag</span><span class="o">=</span><span class="mi">1</span>
        <span class="k">else</span> <span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;The </span><span class="si">{0}</span><span class="s1"> doesnt not match the *csv file&#39;</span>\
                          <span class="s1">&#39; You must convert file on *.csv format&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;The input file is wrong ! only *.csv file &quot;</span>\
                          <span class="s2">&quot; can be parsed.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="p">:</span>
        <span class="k">assert</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.csv&quot;</span><span class="p">),</span> <span class="s2">&quot;The input file </span><span class="si">{0}</span><span class="s2"> is not in *.csv format&quot;</span>
        <span class="k">with</span> <span class="nb">open</span> <span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">data</span><span class="o">=</span><span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>   
            <span class="n">_flag</span><span class="o">=</span><span class="mi">1</span>
            
    <span class="k">if</span> <span class="n">_flag</span><span class="o">==</span><span class="mi">1</span> <span class="p">:</span>
        <span class="k">try</span> <span class="p">:</span>
            <span class="c1"># print(data[0])</span>
            <span class="n">head</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="se">\ufeff</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">head</span><span class="o">=</span><span class="n">_nonevalue_checker</span><span class="p">(</span><span class="n">list_of_value</span><span class="o">=</span><span class="n">head</span><span class="p">,</span>
                                    <span class="n">value_to_delete</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="n">chk</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span> <span class="k">for</span> <span class="n">ii</span> <span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="n">head</span><span class="p">)</span> <span class="k">if</span> <span class="n">value</span> <span class="o">==</span><span class="n">identity</span><span class="p">[</span><span class="n">ii</span><span class="p">]]</span>
            <span class="c1"># data[0]=head</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">chk</span><span class="p">):</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;The </span><span class="si">{0}</span><span class="s1"> doesnt not match the correct file&#39;</span>\
                              <span class="s1">&#39; to parse drill data&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The input file is wrong ! must &quot;</span>\
                              <span class="s2">&quot;input the correct file to be parsed.&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span> <span class="p">:</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="s2">&quot;The *csv file does no match the well file&quot;</span><span class="p">,</span><span class="n">e</span><span class="p">)</span>
            
        <span class="c1"># process to parse all data </span>
        <span class="c1"># coll,geol,samp=[],[],[]</span>

    <span class="k">for</span> <span class="n">ss</span><span class="p">,</span> <span class="n">elm</span> <span class="ow">in</span> <span class="nb">enumerate</span> <span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="n">elm</span><span class="o">=</span><span class="n">elm</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">elm</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">value</span><span class="o">==</span><span class="s1">&#39;&#39;</span> <span class="ow">or</span> <span class="n">value</span><span class="o">==</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">:</span>
                <span class="n">elm</span><span class="o">=</span><span class="n">elm</span><span class="p">[:</span><span class="n">ii</span><span class="p">]</span>
        <span class="n">data</span><span class="p">[</span><span class="n">ss</span><span class="p">]</span><span class="o">=</span><span class="n">elm</span>
        
    <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">head</span>

    <span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">jj</span><span class="p">)</span><span class="k">for</span> <span class="n">jj</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="k">if</span> <span class="n">val</span><span class="o">==</span><span class="p">[]]</span>

    <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="p">[]:</span>
        <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        
    <span class="c1">## final check ###</span>
    <span class="n">safeData</span><span class="o">=</span><span class="n">_nonelist_checker</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">_checker</span><span class="o">=</span><span class="kc">True</span> <span class="p">,</span>
                  <span class="n">list_to_delete</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">])</span>
    <span class="n">data</span><span class="o">=</span><span class="n">safeData</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="c1"># identify collar , geology dans sample data </span>
    <span class="n">comp</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">for</span> <span class="n">ss</span> <span class="p">,</span> <span class="n">elm</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">elm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;geology&#39;</span><span class="p">:</span>
            <span class="n">coll</span><span class="o">=</span><span class="n">data</span><span class="p">[:</span><span class="n">ss</span><span class="p">]</span>
            <span class="n">comp</span><span class="o">=</span><span class="n">ss</span>
        <span class="k">if</span> <span class="n">elm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span><span class="s2">&quot;sample&quot;</span><span class="p">:</span>
            <span class="n">geol</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="n">comp</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">ss</span><span class="p">]</span>
            <span class="n">samp</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="n">ss</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            
    <span class="c1"># build numpy data array </span>
    <span class="n">collar_list</span><span class="o">=</span><span class="n">coll</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="c1"># print(collar_list)</span>
    <span class="n">collar_ar</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">collar_list</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">identity</span><span class="p">)),</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;&lt;U12&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">collar_ar</span><span class="p">):</span>
        <span class="n">collar_ar</span><span class="p">[</span><span class="n">ii</span><span class="p">:,:</span><span class="nb">len</span><span class="p">(</span><span class="n">collar_list</span><span class="p">[</span><span class="n">ii</span><span class="p">])]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">collar_list</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
    
    <span class="n">bottom_ar</span><span class="o">=</span><span class="n">collar_ar</span><span class="p">[:,</span><span class="mi">7</span><span class="p">]</span>
    <span class="c1"># print(bottom_ar)</span>
        
    <span class="n">geol_list</span><span class="o">=</span><span class="n">geol</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">geol_ar</span><span class="o">=</span><span class="n">_order_well</span> <span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">geol_list</span><span class="p">,</span><span class="n">bottom_value</span><span class="o">=</span><span class="n">bottom_ar</span><span class="p">)</span>
    <span class="n">samp_list</span><span class="o">=</span><span class="n">samp</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">samp_ar</span><span class="o">=</span><span class="n">_order_well</span> <span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">samp_list</span><span class="p">,</span><span class="n">bottom_value</span><span class="o">=</span><span class="n">bottom_ar</span><span class="p">)</span>
    
    <span class="n">name_of_location</span> <span class="o">=</span><span class="n">filename</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span>
    <span class="c1"># find Description </span>
    <span class="n">DH_PlanDepth</span><span class="o">=</span><span class="n">collar_ar</span><span class="p">[:,</span><span class="mi">8</span><span class="p">]</span>
    <span class="n">DH_Decr</span><span class="o">=</span><span class="n">collar_ar</span><span class="p">[:,</span><span class="mi">9</span><span class="p">]</span>
    
    <span class="n">lenloc</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">name_of_location</span><span class="p">)</span>
    
 
    <span class="k">for</span> <span class="n">ss</span> <span class="p">,</span> <span class="n">singleArray</span> <span class="ow">in</span> <span class="nb">enumerate</span> <span class="p">(</span><span class="n">DH_PlanDepth</span><span class="p">):</span>
        <span class="c1"># print(singleArray)</span>
        <span class="k">if</span> <span class="n">singleArray</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="ow">or</span> <span class="n">singleArray</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span>
            <span class="n">singleArray</span><span class="o">=</span><span class="n">name_of_location</span><span class="p">[:</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">lenloc</span><span class="o">/</span><span class="mi">2</span><span class="p">)]</span><span class="o">+</span><span class="n">collar_ar</span><span class="p">[</span><span class="n">ss</span><span class="p">,</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
            <span class="n">DH_PlanDepth</span><span class="p">[</span><span class="n">ss</span><span class="p">]</span><span class="o">=</span><span class="n">singleArray</span>
            <span class="k">if</span> <span class="n">DH_Decr</span><span class="p">[</span><span class="n">ss</span><span class="p">]</span> <span class="o">==</span><span class="s1">&#39;&#39;</span><span class="ow">or</span> <span class="n">DH_Decr</span><span class="p">[</span><span class="n">ss</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span>
                <span class="n">DH_Decr</span><span class="p">[</span><span class="n">ss</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;wdanx&quot;</span><span class="o">+</span><span class="n">collar_ar</span><span class="p">[</span><span class="n">ss</span><span class="p">,</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span>\
                    <span class="n">name_of_location</span><span class="o">.</span><span class="n">lower</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">collar_ar</span><span class="p">[</span><span class="n">ss</span><span class="p">,</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="n">collar_ar</span><span class="p">[:,</span><span class="mi">8</span><span class="p">]</span><span class="o">=</span><span class="n">DH_PlanDepth</span>
    <span class="n">collar_ar</span><span class="p">[:,</span><span class="mi">9</span><span class="p">]</span><span class="o">=</span><span class="n">DH_Decr</span>
    
    <span class="k">if</span> <span class="n">include_azimuth</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
        <span class="n">DH_Azimuth</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">collar_ar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">include_azimuth</span><span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">DH_Azimuth</span><span class="o">=</span><span class="n">compute_azimuth</span><span class="p">(</span><span class="n">easting</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">collar_ar</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]),</span>
                                  <span class="n">northing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">collar_ar</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]]),</span>
                                  <span class="n">utm_zone</span><span class="o">=</span><span class="n">utm_zone</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="n">collar_ar</span><span class="p">[:,</span><span class="mi">5</span><span class="p">]</span><span class="o">=</span><span class="n">DH_Azimuth</span>
    

    <span class="n">name_of_location</span><span class="o">=</span><span class="n">name_of_location</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span>
    <span class="n">WellData</span><span class="p">,</span><span class="n">GeoData</span><span class="p">,</span><span class="n">SampleData</span><span class="o">=</span><span class="n">collar_ar</span><span class="p">,</span><span class="n">geol_ar</span><span class="p">,</span> <span class="n">samp_ar</span> 

    <span class="k">return</span> <span class="p">(</span><span class="n">name_of_location</span><span class="p">,</span> <span class="n">WellData</span><span class="p">,</span><span class="n">GeoData</span><span class="p">,</span><span class="n">SampleData</span><span class="p">)</span></div>
                   

            
<span class="k">def</span> <span class="nf">_nonelist_checker</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">_checker</span><span class="o">=</span><span class="kc">False</span> <span class="p">,</span>
                      <span class="n">list_to_delete</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to delete a special item on list in data.</span>
<span class="sd">    Any item you want to delete is acceptable as long as item is on a list.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : list</span>
<span class="sd">        container of list. Data must contain others list.</span>
<span class="sd">        the element to delete should be on list.</span>
<span class="sd">    _checker : bool, optional</span>
<span class="sd">        DESCRIPTION. The default is False.</span>
<span class="sd">    list_to_delete : TYPE, optional</span>
<span class="sd">        DESCRIPTION. The default is [&#39;\n&#39;].</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    _occ : int</span>
<span class="sd">        number of occurence.</span>
<span class="sd">    num_turn : int</span>
<span class="sd">        number of turns to elimate the value.</span>
<span class="sd">    data : list</span>
<span class="sd">        data safeted exempt of the value we want to delete.</span>
<span class="sd">        </span>
<span class="sd">    example ::</span>
<span class="sd">            listtest =[[&#39;DH_Hole&#39;, &#39;Thick01&#39;, &#39;Thick02&#39;, &#39;Thick03&#39;,</span>
<span class="sd">                &#39;Thick04&#39;, &#39;sample02&#39;, &#39;sample03&#39;], </span>
<span class="sd">                [&#39;sample04&#39;], [], [&#39;\n&#39;], </span>
<span class="sd">               [&#39;S01&#39;, &#39;98.62776918&#39;, &#39;204.7500461&#39;, &#39;420.0266651&#39;], [&#39;prt&#39;],</span>
<span class="sd">               [&#39;pup&#39;, &#39;pzs&#39;],[], [&#39;papate04&#39;, &#39;\n&#39;], </span>
<span class="sd">               [&#39;S02&#39;, &#39;174.4293956&#39;], [], [&#39;400.12&#39;, &#39;974.8945704&#39;],</span>
<span class="sd">               [&#39;pup&#39;, &#39;prt&#39;, &#39;pup&#39;, &#39;pzs&#39;, &#39;&#39;, &#39;\n&#39;],</span>
<span class="sd">               [&#39;saple07&#39;], [], &#39;&#39;,  [&#39;sample04&#39;], [&#39;\n&#39;],</span>
<span class="sd">               [&#39;&#39;], [313.9043882], [&#39;&#39;], [&#39;&#39;], [&#39;2&#39;], [&#39;&#39;], [&#39;2&#39;], [&#39;&#39;], [&#39;&#39;], [&#39;\n&#39;], </span>
<span class="sd">               [&#39;&#39;], [&#39;968.82&#39;], [], [],[], [&#39;&#39;],[ 0.36], [&#39;&#39;], [&#39;\n&#39;]]</span>
<span class="sd">    </span>
<span class="sd">                ss=_nonelist_checker(data=listtest, _checker=True,</span>
<span class="sd">                                     list_to_delete=[&#39;&#39;])</span>
<span class="sd">                print(ss)</span>
<span class="sd">                </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">_occ</span><span class="p">,</span><span class="n">num_turn</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
    
    
    <span class="k">if</span> <span class="n">_checker</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">_occ</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">return</span> <span class="n">_occ</span><span class="p">,</span> <span class="n">num_turn</span><span class="p">,</span> <span class="n">data</span> 
    
   
    <span class="k">while</span> <span class="n">_checker</span> <span class="ow">is</span> <span class="kc">True</span> <span class="p">:</span>
        <span class="k">if</span> <span class="n">list_to_delete</span> <span class="ow">in</span> <span class="n">data</span> <span class="p">:</span>
            <span class="k">for</span> <span class="n">indix</span> <span class="p">,</span> <span class="n">elem_chker</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">list_to_delete</span> <span class="o">==</span> <span class="n">elem_chker</span> <span class="p">:</span>
                    <span class="n">_occ</span><span class="o">=</span><span class="n">_occ</span><span class="o">+</span><span class="mi">1</span>
                    <span class="k">del</span> <span class="n">data</span><span class="p">[</span><span class="n">indix</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">list_to_delete</span><span class="p">:</span>
                        <span class="n">_occ</span> <span class="o">+=</span><span class="mi">1</span>
                        <span class="c1"># data=data[:-1]</span>
                        <span class="n">data</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">list_to_delete</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span> <span class="p">:</span>
            <span class="n">_checker</span> <span class="o">=</span><span class="kc">False</span>
        <span class="n">num_turn</span><span class="o">+=</span><span class="mi">1</span>

        
    <span class="k">return</span> <span class="n">_occ</span><span class="p">,</span><span class="n">num_turn</span><span class="p">,</span><span class="n">data</span>
        
<span class="k">def</span> <span class="nf">_order_well</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to reorganize value , depth rock and depth-sample </span>
<span class="sd">    the program controls  the input depth value and compare it . </span>
<span class="sd">    with the bottom. It will pay attention that bottom depth must</span>
<span class="sd">    be greater or egual of any other value. In the same time ,</span>
<span class="sd">    the program check if value entered are sorted on ascending order . </span>
<span class="sd">    well must go deep ( less value to great value). Negative values of</span>
<span class="sd">    depths are not acceptable.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : list,</span>
<span class="sd">        data contains list of well thickness and rock description .</span>
<span class="sd">    **kwargs : dict,</span>
<span class="sd">        * bottom_value * : np.ndarray float</span>
<span class="sd">            value of bottom . it may the basement extrapolation.</span>
<span class="sd">            default is 1.023 km</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    data : np.ndarray</span>
<span class="sd">        data aranged to [DH_Hole, DH_From, DH_To, Rock.] arrays</span>
<span class="sd">        </span>
<span class="sd">    e.g.::</span>
<span class="sd">        listtest =[[&#39;DH_Hole&#39;, &#39;Thick01&#39;, &#39;Thick02&#39;, &#39;Thick03&#39;,</span>
<span class="sd">                    &#39;Thick04&#39;,&#39;Rock01&#39;, &#39;Rock02&#39;, &#39;Rock03&#39;, &#39;Rock04&#39;],</span>
<span class="sd">        [&#39;S01&#39;, &#39;0.0&#39;, &#39;98.62776918&#39;, &#39;204.7500461&#39;,&#39;420.0266651&#39;, &#39;GRT&#39;, &#39;ATRK&#39;, &#39;GRT&#39;, &#39;ROCK&#39;],</span>
<span class="sd">        [&#39;S02&#39;, &#39;174.4293956&#39;, &#39;313.9043882&#39;, &#39;400.12&#39;, &#39;974.8945704&#39;, &#39;GRT&#39;, &#39;ATRK&#39;, &#39;GRT&#39;, &#39;ROCK&#39;]]</span>
<span class="sd">        </span>
<span class="sd">        # print(listtest[1:])</span>
<span class="sd">        ss=_order_well(listtest[1:])</span>
<span class="sd">        </span>
<span class="sd">        print(ss)</span>


<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">this_function_name</span><span class="o">=</span><span class="n">inspect</span><span class="o">.</span><span class="n">getframeinfo</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">currentframe</span><span class="p">())[</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">bottomgeo</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;bottom_value&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="c1"># bottomsamp=kwargs.pop(&quot;sample_bottom_value&quot;,None)</span>
    <span class="c1"># if type(bottomgeo) is np.ndarray :_flag=1</span>
    <span class="c1"># else : _flag=0</span>
    
    <span class="n">temp</span><span class="o">=</span><span class="p">[]</span>

    <span class="n">_logger</span><span class="o">.</span><span class="n">info</span> <span class="p">(</span><span class="s2">&quot;You pass by </span><span class="si">{0}</span><span class="s2"> function! Thin now , everything is ok. &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">this_function_name</span><span class="p">))</span>
    
    <span class="k">for</span> <span class="n">jj</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span> <span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="n">thickness_len</span><span class="p">,</span><span class="n">dial1</span><span class="p">,</span><span class="n">dial2</span><span class="o">=</span><span class="n">intell_index</span><span class="p">(</span><span class="n">datalist</span><span class="o">=</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="c1">#call intell_index</span>
        <span class="n">value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="n">dh_from</span><span class="o">=</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">thickness_len</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">dh_to</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">thickness_len</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;&lt;U12&quot;</span><span class="p">)</span>
                <span class="c1"># ---- check the last value given        </span>
        <span class="n">max_given_bottom</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">dh_from</span><span class="p">]))</span> 
                <span class="c1"># ----it may be less than bottom value                                                                .</span>
        <span class="n">dh_geo</span><span class="o">=</span><span class="n">value</span><span class="p">[</span><span class="n">thickness_len</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">dh_to</span><span class="o">=</span><span class="n">dh_from</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="c1"># if _flag==0 :</span>
        <span class="k">if</span> <span class="n">bottomgeo</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">==</span><span class="s2">&quot;&quot;</span> <span class="ow">or</span> <span class="n">bottomgeo</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span><span class="o">==</span><span class="kc">None</span> <span class="p">:</span>
            <span class="n">bottomgeoidx</span><span class="o">=</span><span class="mf">1023.</span>
            <span class="k">if</span> <span class="n">max_given_bottom</span> <span class="o">&gt;</span> <span class="n">bottomgeoidx</span><span class="p">:</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;value </span><span class="si">{0}</span><span class="s2"> is greater than the Bottom depth </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">max_given_bottom</span> <span class="p">,</span><span class="n">bottomgeoidx</span><span class="p">))</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span> <span class="p">(</span><span class="s2">&quot;Given values have a value greater than the depth !&quot;</span><span class="p">)</span>
                
            <span class="n">dh_to</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dh_to</span><span class="p">,</span><span class="n">bottomgeoidx</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1">#elif :_flag==1 :         # check the bottom , any values given </span>
                                        <span class="c1"># must be less or egual to depth not greater.</span>
            <span class="k">if</span> <span class="n">max_given_bottom</span><span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="n">bottomgeo</span><span class="p">[</span><span class="n">jj</span><span class="p">]):</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;value </span><span class="si">{0}</span><span class="s2"> is greater than the Bottom depth </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">max_given_bottom</span> <span class="p">,</span><span class="n">bottomgeo</span><span class="p">[</span><span class="n">jj</span><span class="p">]))</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span> <span class="p">(</span><span class="s2">&quot;Given values have a value greater than the depth !&quot;</span><span class="p">)</span>
            <span class="n">dh_to</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dh_to</span><span class="p">,</span><span class="n">bottomgeo</span><span class="p">[</span><span class="n">jj</span><span class="p">])</span>
            
        <span class="n">dh_hole</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">thickness_len</span><span class="p">),</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="n">temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">dh_hole</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">dh_hole</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">)),</span>
                                    <span class="n">dh_from</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">dh_from</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">)),</span>
                                    <span class="n">dh_to</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">dh_to</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">)),</span>
                                    <span class="n">dh_geo</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">dh_geo</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">))),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span> <span class="p">))</span>
        
    <span class="n">data</span><span class="o">=</span><span class="n">concat_array_from_list</span><span class="p">(</span><span class="n">list_of_array</span><span class="o">=</span><span class="n">temp</span><span class="p">,</span> <span class="n">concat_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">data</span>
                                
        
<div class="viewcode-block" id="intell_index"><a class="viewcode-back" href="../../../utils.html#csamtpy.utils.func_utils.intell_index">[docs]</a><span class="k">def</span> <span class="nf">intell_index</span> <span class="p">(</span><span class="n">datalist</span><span class="p">,</span><span class="n">assembly_dials</span> <span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    function to search index to differency value to string element like </span>
<span class="sd">    geological rocks and geologicals samples. It check that value are sorted</span>
<span class="sd">    in ascending order.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    datalist : list</span>
<span class="sd">        list of element : may contain value and rocks or sample .</span>
<span class="sd">    assembly_dials : list, optional</span>
<span class="sd">        separate on two list : values and rocks or samples. The default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     - index : int</span>
<span class="sd">        index of breaking up.</span>
<span class="sd">     - first_dial : list , </span>
<span class="sd">         first sclice of value part </span>
<span class="sd">     - secund_dial : list , </span>
<span class="sd">         second slice of rocks or sample part.</span>
<span class="sd">     - assembly : list </span>
<span class="sd">         list of first_dial and second_dial</span>
<span class="sd">    </span>
<span class="sd">    eg ::     </span>
<span class="sd">        listtest =[[&#39;DH_Hole&#39;, &#39;Thick01&#39;, &#39;Thick02&#39;, &#39;Thick03&#39;,</span>
<span class="sd">                    &#39;Thick04&#39;,&#39;Rock01&#39;, &#39;Rock02&#39;, &#39;Rock03&#39;, &#39;Rock04&#39;],</span>
<span class="sd">        [&#39;S01&#39;, &#39;0.0&#39;, &#39;98.62776918&#39;, &#39;204.7500461&#39;,&#39;420.0266651&#39;,&#39;520&#39;, &#39;GRT&#39;, </span>
<span class="sd">         &#39;ATRK&#39;, &#39;GRT&#39;, &#39;ROCK&#39;,&#39;GRANODIORITE&#39;],</span>
<span class="sd">        [&#39;S02&#39;, &#39;174.4293956&#39;, &#39;313.9043882&#39;,&#39;974.8945704&#39;, &#39;GRT&#39;, &#39;ATRK&#39;, &#39;GRT&#39;]]</span>
<span class="sd">        listtest2=[listtest[1][1:],listtest[2][1:]]</span>
<span class="sd">        for ii in listtest2 :</span>
<span class="sd">            op=intell_index(datalist=ii)</span>
<span class="sd">            print(&quot;index:\n&quot;,op [0])</span>
<span class="sd">            print(&#39;firstDials :\n&#39;,op [1])</span>
<span class="sd">            print(&#39;secondDials:\n&#39;,op [2])</span>
<span class="sd">        </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># assembly_dials=[]</span>
    <span class="n">max_</span><span class="o">=</span><span class="mi">0</span>              <span class="c1"># way to check whether values are in sort (ascending =True) order </span>
                        <span class="c1"># because we go to deep (first value must be less than the next none)</span>
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span> <span class="p">(</span><span class="n">datalist</span><span class="p">):</span>
        <span class="k">try</span> <span class="p">:</span> 
            <span class="n">thick</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">thick</span> <span class="o">&gt;=</span> <span class="n">max_</span><span class="p">:</span>
                <span class="n">max_</span><span class="o">=</span><span class="n">thick</span> 
            <span class="k">else</span> <span class="p">:</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;the input value </span><span class="si">{0}</span><span class="s2"> is less than the previous one.&quot;</span>\
                              <span class="s2">&quot; Please enter value greater than </span><span class="si">{1}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">thick</span><span class="p">,</span> <span class="n">max_</span><span class="p">)</span> <span class="p">)</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Value </span><span class="si">{1}</span><span class="s2"> must be greater than the previous value </span><span class="si">{0}</span><span class="s2">.&quot;</span>\
                              <span class="s2">&quot; Must change on your input data.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">thick</span><span class="p">,</span><span class="n">max_</span><span class="p">))</span>
        <span class="k">except</span> <span class="p">:</span>
            <span class="c1"># pass</span>
            <span class="n">indexi</span><span class="o">=</span><span class="n">ii</span>
            <span class="k">break</span>
        
    <span class="n">first_dial</span><span class="o">=</span><span class="n">datalist</span><span class="p">[:</span><span class="n">indexi</span><span class="p">]</span>
    <span class="n">second_dial</span> <span class="o">=</span><span class="n">datalist</span><span class="p">[</span><span class="n">indexi</span><span class="p">:]</span>

    <span class="k">if</span> <span class="n">assembly_dials</span><span class="p">:</span>
        
        <span class="n">assembly_dials</span><span class="o">=</span><span class="p">[</span><span class="n">first_dial</span><span class="p">,</span><span class="n">second_dial</span><span class="p">]</span>
        
        <span class="k">return</span> <span class="n">indexi</span><span class="p">,</span> <span class="n">assembly_dials</span>
        
    <span class="k">return</span> <span class="n">indexi</span><span class="p">,</span> <span class="n">first_dial</span><span class="p">,</span> <span class="n">second_dial</span></div>

<span class="k">def</span> <span class="nf">_nonevalue_checker</span> <span class="p">(</span><span class="n">list_of_value</span><span class="p">,</span> <span class="n">value_to_delete</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function similar to _nonelist_checker. the function deletes the specific </span>
<span class="sd">    value on the list whatever the number of repetition of value_to_delete.</span>
<span class="sd">    The difference with none list checker is value to delete </span>
<span class="sd">    may not necessary be on list.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    list_of_value : list</span>
<span class="sd">        DESCRIPTION.</span>
<span class="sd">    value_to_delete : TYPE, optional</span>
<span class="sd">        DESCRIPTION. The default is &#39;&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list_of_value : list</span>
<span class="sd">        safe list without the deleted value .</span>
<span class="sd">    </span>
<span class="sd">    eg:: </span>
<span class="sd">            test=[&#39;DH_Hole (ID)&#39;, &#39;DH_East&#39;, &#39;DH_North&#39;, &#39;DH_Dip&#39;, &#39;Elevation &#39;, &#39;DH_Azimuth&#39;, </span>
<span class="sd">             &#39;DH_Top&#39;, &#39;DH_Bottom&#39;, &#39;DH_PlanDepth&#39;, &#39;DH_Decr&#39;, &#39;Mask&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;]</span>
<span class="sd">            </span>
<span class="sd">            test0= _nonevalue_checker (list_of_value=test)</span>
<span class="sd">            </span>
<span class="sd">            print(test0)</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">value_to_delete</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span>
        <span class="n">value_to_delete</span>  <span class="o">=</span><span class="s1">&#39;&#39;</span>
    
    <span class="k">if</span> <span class="nb">type</span> <span class="p">(</span><span class="n">list_of_value</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span> <span class="p">:</span>
        <span class="n">list_of_value</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">list_of_value</span><span class="p">)</span>
        
    <span class="n">start_point</span><span class="o">=</span><span class="mi">1</span>
    <span class="k">while</span> <span class="n">start_point</span> <span class="o">==</span><span class="mi">1</span> <span class="p">:</span>
        <span class="k">if</span> <span class="n">value_to_delete</span> <span class="ow">in</span> <span class="n">list_of_value</span> <span class="p">:</span>
            <span class="p">[</span><span class="n">list_of_value</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span> <span class="k">for</span>  <span class="n">ii</span><span class="p">,</span> <span class="n">elm</span> <span class="ow">in</span>\
             <span class="nb">enumerate</span> <span class="p">(</span><span class="n">list_of_value</span><span class="p">)</span> <span class="k">if</span> <span class="n">elm</span><span class="o">==</span><span class="n">value_to_delete</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">value_to_delete</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">list_of_value</span> <span class="p">:</span>
            <span class="n">start_point</span><span class="o">=</span><span class="mi">0</span> <span class="c1"># not necessary , just for secure the loop. </span>
            <span class="k">break</span>           <span class="c1"># be sure one case or onother , it will break</span>
    <span class="k">return</span> <span class="n">list_of_value</span> 
        
<span class="k">def</span> <span class="nf">_strip_item</span><span class="p">(</span><span class="n">item_to_clean</span><span class="p">,</span> <span class="n">item</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">multi_space</span><span class="o">=</span><span class="mi">12</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to strip item around string values.  if the item to clean is None or </span>
<span class="sd">    item-to clean is &quot;&#39;&#39;&quot;, function will return None value</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    item_to_clean : list or np.ndarray of string </span>
<span class="sd">         List to strip item.</span>
<span class="sd">    cleaner : str , optional</span>
<span class="sd">        item to clean , it may change according the use. The default is &#39;&#39;.</span>
<span class="sd">    multi_space : int, optional</span>
<span class="sd">        degree of repetition may find around the item. The default is 12.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    item_to_clean : list or ndarray</span>
<span class="sd">        cleaned item </span>
<span class="sd">         eg :     </span>
<span class="sd">             &gt;&gt;&gt; new_data=_strip_item (item_to_clean=np.array([&#39;      ss_data&#39;,&#39;    pati   &#39;]))</span>
<span class="sd">            # print(np.array([&#39;      ss_data&#39;,&#39;    pati   &#39;]))</span>
<span class="sd">            ... print(new_data)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">item</span><span class="o">==</span><span class="kc">None</span> <span class="p">:</span><span class="n">item</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span>
    
    <span class="n">cleaner</span> <span class="o">=</span><span class="p">[(</span><span class="s1">&#39;&#39;</span><span class="o">+</span> <span class="n">ii</span><span class="o">*</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">item</span><span class="p">))</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">multi_space</span><span class="p">)]</span>
    
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">item_to_clean</span> <span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span> <span class="p">:</span><span class="c1">#or type(item_to_clean ) !=np.ndarray:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">item_to_clean</span> <span class="p">)</span> <span class="o">!=</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="n">item_to_clean</span><span class="o">=</span><span class="p">[</span><span class="n">item_to_clean</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">item_to_clean</span> <span class="ow">in</span> <span class="n">cleaner</span> <span class="ow">or</span> <span class="n">item_to_clean</span> <span class="o">==</span><span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span> <span class="p">(</span><span class="s1">&#39;No data found in &lt;item_to_clean :</span><span class="si">{}</span><span class="s1">&gt; We gonna return None.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> 

  
    <span class="k">try</span> <span class="p">:</span> 
        <span class="n">multi_space</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">multi_space</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">:</span> 
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;argument &lt;multplier&gt; must be&#39;</span>\
                        <span class="s1">&#39; an integer not </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">multi_space</span><span class="p">)))</span>
    
    <span class="k">for</span> <span class="n">jj</span><span class="p">,</span> <span class="n">ss</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">item_to_clean</span><span class="p">)</span> <span class="p">:</span> 
        <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="n">cleaner</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">space</span> <span class="ow">in</span> <span class="n">ss</span> <span class="p">:</span>
                <span class="n">new_ss</span><span class="o">=</span><span class="n">ss</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="n">space</span><span class="p">)</span>
                <span class="n">item_to_clean</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span><span class="o">=</span><span class="n">new_ss</span>
    
    <span class="k">return</span> <span class="n">item_to_clean</span>
    
<span class="k">def</span> <span class="nf">_cross_eraser</span> <span class="p">(</span><span class="n">data</span> <span class="p">,</span> <span class="n">to_del</span><span class="p">,</span> <span class="n">deep_cleaner</span> <span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to delete some item present in another list. It may cheCk deeper </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : list</span>
<span class="sd">        Main data user want to filter.</span>
<span class="sd">    to_del : list</span>
<span class="sd">        list of item you want to delete present on the main data.</span>
<span class="sd">    deep_cleaner : bool, optional</span>
<span class="sd">        Way to deeply check. Sometimes the values are uncleaned and </span>
<span class="sd">        capitalizeed . this way must not find their safety correspondace </span>
<span class="sd">        then the algorth must clean item and to match all at the same time before eraisng.</span>
<span class="sd">        The default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    data : list</span>
<span class="sd">        list erased.</span>

<span class="sd">    eg :: </span>
<span class="sd">           &gt;&gt;&gt; data =[&#39;Z.mwgt&#39;,&#39;Z.pwgt&#39;,&#39;Freq&#39;,&#39; Tx.Amp&#39;,&#39;E.mag&#39;,&#39;   E.phz&#39;,</span>
<span class="sd">                      &#39;   B.mag&#39;,&#39;   B.phz&#39;,&#39;   Z.mag&#39;, &#39;   Zphz  &#39;]</span>
<span class="sd">    </span>
<span class="sd">            &gt;&gt;&gt; data2=[&#39;   B.phz&#39;,&#39;   Z.mag&#39;,]</span>
<span class="sd">                remain_data =cross_eraser(data=data, to_del=data2, </span>
<span class="sd">                                          deep_cleaner=True)</span>
<span class="sd">            ... print(remain_data)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">data</span> <span class="p">,</span> <span class="n">to_del</span><span class="o">=</span><span class="n">_strip_item</span><span class="p">(</span><span class="n">item_to_clean</span><span class="o">=</span><span class="n">data</span><span class="p">),</span> <span class="n">_strip_item</span><span class="p">(</span><span class="n">item_to_clean</span><span class="o">=</span><span class="n">to_del</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">deep_cleaner</span> <span class="p">:</span> 
        <span class="n">data</span><span class="p">,</span> <span class="n">to_del</span> <span class="o">=</span><span class="p">[</span><span class="n">ii</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">data</span><span class="p">],</span> <span class="p">[</span><span class="n">jj</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="n">to_del</span><span class="p">]</span>
        
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">):</span> 
        <span class="k">while</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">to_del</span> <span class="p">:</span>
            <span class="k">del</span> <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">index</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="p">:</span>
                <span class="k">break</span>

    <span class="k">return</span> <span class="n">data</span> 

<span class="k">def</span> <span class="nf">_remove_str_word</span> <span class="p">(</span><span class="n">char</span><span class="p">,</span> <span class="n">word_to_remove</span><span class="p">,</span> <span class="n">deep_remove</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Small funnction to remove a word present on  astring character </span>
<span class="sd">    whatever the number of times it will repeated.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    char : str</span>
<span class="sd">        may the the str phrases or sentences . main items.</span>
<span class="sd">    word_to_remove : str</span>
<span class="sd">        specific word to remove.</span>
<span class="sd">    deep_remove : bool, optional</span>
<span class="sd">        use the lower case to remove the word even the word is uppercased </span>
<span class="sd">        of capitalized. The default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    char : str </span>
<span class="sd">        new_char without the removed word .</span>
<span class="sd">        </span>
<span class="sd">        E.G :: </span>
<span class="sd">                &gt;&gt;&gt; ch =&#39;AMTAVG 7.76: &quot;K1.fld&quot;, Dated 99-01-01,AMTAVG, Processed 11 Jul 17 AMTAVG&#39;</span>
<span class="sd">                &gt;&gt;&gt; ss=_remove_str_word(char=ch, word_to_remove=&#39;AMTAVG&#39;, deep_remove=False)</span>

<span class="sd">                &gt;&gt;&gt; print(ss)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">char</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span> <span class="p">:</span> <span class="n">char</span> <span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">word_to_remove</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span> <span class="p">:</span> <span class="n">word_to_remove</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">word_to_remove</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">deep_remove</span> <span class="o">==</span> <span class="kc">True</span> <span class="p">:</span>
        <span class="n">word_to_remove</span><span class="p">,</span> <span class="n">char</span> <span class="o">=</span><span class="n">word_to_remove</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span><span class="n">char</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">word_to_remove</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">char</span> <span class="p">:</span>
        <span class="k">return</span> <span class="n">char</span>

    <span class="k">while</span> <span class="n">word_to_remove</span> <span class="ow">in</span> <span class="n">char</span> <span class="p">:</span> 
        <span class="k">if</span> <span class="n">word_to_remove</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">char</span> <span class="p">:</span> 
            <span class="k">break</span> 
        <span class="n">index_wr</span> <span class="o">=</span> <span class="n">char</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">word_to_remove</span><span class="p">)</span>
        <span class="n">remain_len</span><span class="o">=</span><span class="n">index_wr</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">word_to_remove</span><span class="p">)</span>
        <span class="n">char</span><span class="o">=</span><span class="n">char</span><span class="p">[:</span><span class="n">index_wr</span><span class="p">]</span><span class="o">+</span><span class="n">char</span><span class="p">[</span><span class="n">remain_len</span><span class="p">:]</span>

    <span class="k">return</span> <span class="n">char</span>

<div class="viewcode-block" id="stn_check_split_type"><a class="viewcode-back" href="../../../utils.html#csamtpy.utils.func_utils.stn_check_split_type">[docs]</a><span class="k">def</span> <span class="nf">stn_check_split_type</span><span class="p">(</span><span class="n">data_lines</span><span class="p">):</span> 
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read data_line and check for data line the presence of split_type &lt; &#39;,&#39; or &#39; &#39;, or any other marks.&gt;</span>
<span class="sd">    Threshold is assume to be third of total data length.</span>
<span class="sd">    </span>
<span class="sd">    params : data_lines : list of data to parse . </span>
<span class="sd">    </span>
<span class="sd">    return : The split _type </span>
<span class="sd">    </span>
<span class="sd">    eg:: </span>
<span class="sd">        path =  os.path.join(os.environ[&quot;pyCSAMT&quot;], </span>
<span class="sd">                          &#39;csamtpy&#39;,&#39;data&#39;, K6.stn)</span>
<span class="sd">                        with open (path, &#39;r&#39;, encoding=&#39;utf8&#39;) as f : </span>
<span class="sd">                            data= f.readlines()</span>
<span class="sd">                        print(stn_check_split_type(data_lines=data))</span>
<span class="sd">            </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">split_type</span> <span class="o">=</span><span class="p">[</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="s1">&#39;:&#39;</span><span class="p">,</span><span class="s1">&#39; &#39;</span><span class="p">,</span><span class="s1">&#39;;&#39;</span> <span class="p">]</span>
    <span class="n">data_to_read</span> <span class="o">=</span><span class="p">[]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_lines</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span> <span class="c1"># change the data if data is not dtype string elements.</span>
        <span class="k">if</span> <span class="n">data_lines</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="s1">&#39;int&#39;</span><span class="p">,</span> <span class="s1">&#39;complex&#39;</span><span class="p">]:</span> <span class="n">data_lines</span><span class="o">=</span><span class="n">data_lines</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;&lt;U12&#39;</span><span class="p">)</span>
        <span class="n">data_lines</span><span class="o">=</span> <span class="n">data_lines</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_lines</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data_lines</span><span class="p">[:</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_lines</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span><span class="p">)]):</span>
             <span class="n">data_to_read</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
             <span class="n">data_to_read</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">data_to_read</span><span class="p">])]</span> <span class="c1"># be sure the list is str item . </span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_lines</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span> <span class="n">data_to_read</span><span class="o">=</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">data_lines</span><span class="p">)]</span>
    
    <span class="k">for</span> <span class="n">jj</span><span class="p">,</span> <span class="n">sep</span>  <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">split_type</span><span class="p">)</span> <span class="p">:</span>
        <span class="k">if</span> <span class="n">data_to_read</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">:</span>
            <span class="k">if</span> <span class="n">data_to_read</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_lines</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sep</span> <span class="o">==</span> <span class="s1">&#39; &#39;</span><span class="p">:</span> <span class="k">return</span>  <span class="kc">None</span>  <span class="c1"># use None more conventional </span>
                <span class="k">else</span> <span class="p">:</span> <span class="k">return</span> <span class="n">sep</span> </div>

<div class="viewcode-block" id="minimum_parser_to_write_edi"><a class="viewcode-back" href="../../../utils.html#csamtpy.utils.func_utils.minimum_parser_to_write_edi">[docs]</a><span class="k">def</span> <span class="nf">minimum_parser_to_write_edi</span> <span class="p">(</span><span class="n">edilines</span><span class="p">,</span> <span class="n">parser</span> <span class="o">=</span> <span class="s1">&#39;=&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This fonction validate edifile for writing , string with egal.we assume that </span>
<span class="sd">    dictionnary in list will be for definemeasurment E and H fied. </span>
<span class="sd">    param : edilines : list : list of item to parse </span>
<span class="sd">            parser  : str : the egal is use  to parser edifile . it can be change </span>
<span class="sd">            default is egal (=)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">edilines</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">edilines</span> <span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="p">:</span> <span class="n">edilines</span> <span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">edilines</span><span class="p">)</span>
        <span class="k">else</span> <span class="p">:</span><span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;&lt;Edilines&gt; Must be on list&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">lines</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edilines</span><span class="p">)</span> <span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span><span class="k">continue</span> 
        <span class="k">elif</span> <span class="n">lines</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)</span> <span class="o">&lt;</span><span class="mi">0</span> <span class="p">:</span> <span class="k">raise</span> <span class="s1">&#39;None &lt;&quot;=&quot;&gt; found on this item&lt;</span><span class="si">{0}</span><span class="s1">&gt; of  the edilines list. list can not&#39;</span>\
            <span class="s1">&#39; be parsed.Please put egal between key and value &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">edilines</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
    
    <span class="k">return</span> <span class="n">edilines</span> </div>
            

<div class="viewcode-block" id="round_dipole_length"><a class="viewcode-back" href="../../../utils.html#csamtpy.utils.func_utils.round_dipole_length">[docs]</a><span class="k">def</span> <span class="nf">round_dipole_length</span><span class="p">(</span><span class="n">value</span><span class="p">):</span> 
    <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    small function to graduate dipole length 5 to 5. Goes to be reality and </span>
<span class="sd">    simple computation .</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="n">mm</span> <span class="o">=</span> <span class="n">value</span> <span class="o">%</span> <span class="mi">5</span> 
    <span class="k">if</span> <span class="n">mm</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="p">:</span><span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">value</span> <span class="o">-</span> <span class="n">mm</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">mm</span> <span class="o">&gt;=</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">mm</span> <span class="o">&lt;</span> <span class="mi">7</span> <span class="p">:</span><span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">value</span> <span class="o">-</span><span class="n">mm</span> <span class="o">+</span><span class="mi">5</span><span class="p">)</span> 
    <span class="k">else</span><span class="p">:</span><span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">value</span> <span class="o">-</span> <span class="n">mm</span> <span class="o">+</span><span class="mf">10.</span><span class="p">)</span></div>
    


<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s2">&quot;__main__&quot;</span> <span class="p">:</span>
      
    <span class="c1"># dir_=r&quot;F:\OneDrive\Python\CodesExercices\ex_avgfiles\avgmo&quot;</span>
    <span class="c1"># os.chdir(dir_)</span>
    <span class="c1"># parse_=parse_wellData(filename=&#39;shimenDH.csv&#39;, include_azimuth=True,utm_zone=&#39;49N&#39;)</span>
    
    <span class="c1"># print(&quot;NameOflocation:\n&quot;,parse_[0])</span>
    <span class="c1"># print(&quot;WellData:\n&quot;,parse_[1])</span>
    <span class="c1"># print(&quot;GeoData:\n&quot;,parse_[2])</span>
    <span class="c1"># print(&quot;Sample:\n&quot;,parse_[3])</span>
    <span class="c1"># data =[&#39;Z.mwgt&#39;,&#39;Z.pwgt&#39;,&#39;Freq&#39;,&#39; Tx.Amp&#39;,&#39;E.mag&#39;,&#39;   E.phz&#39;,</span>
    <span class="c1">#         &#39;   B.mag&#39;,&#39;   B.phz&#39;,&#39;   Z.mag&#39;, &#39;   Zphz  &#39;]</span>
    
    <span class="c1"># data2=[&#39; B.phz&#39;,&#39; Z.mag&#39;,]</span>
    <span class="c1"># # cleaner =[(&#39;&#39;+ ii*&#39;*&#39;) for ii in range(7)]</span>
    <span class="c1"># print(_cross_eraser(data=data2, to_del=data))</span>
    <span class="c1"># print(_cross_eraser(data=data, to_del=data2))</span>
    <span class="c1"># # print(_strip_item(item_to_clean=data, item=&#39; &#39;))</span>
    <span class="c1"># # # print(cleaner)</span>
    <span class="c1"># ts =&#39;50.0&#39;</span>
    <span class="c1"># ch =&#39;AMTAVG 7.76: &quot;K1.fld&quot;, Dated 99-01-01,AMTAVG, Processed 11 Jul 17 AMTAVG&#39;</span>
    <span class="c1"># ss=_remove_str_word(char=ts, word_to_remove=&#39;m&#39;, deep_remove=False)</span>
            
    <span class="c1"># # ss =_pass()</span>
    <span class="c1"># print(ss)</span>
    <span class="c1"># print(_strip_item(item_to_clean=item))</span>
    <span class="n">file_1</span><span class="o">=</span><span class="s1">&#39;K1.AVG&#39;</span>
    <span class="n">file_2</span><span class="o">=</span><span class="s1">&#39;LCS01.avg&#39;</span>
    <span class="n">file_3</span><span class="o">=</span><span class="s1">&#39;LCS01_2_to_1.avg&#39;</span>
    <span class="n">file_stn</span><span class="o">=</span><span class="s1">&#39;K2.stn&#39;</span>
    <span class="c1"># print(os.getcwd())</span>
    <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;pyCSAMT&#39;</span><span class="p">]</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;C:/Users\Administrator\OneDrive\Python\project\pyCSAMT&#39;</span>
    <span class="c1"># path = r&#39;C:\Users\Administrator\Desktop\K1.stn&#39;</span>
    <span class="n">path</span> <span class="o">=</span>  <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">&quot;pyCSAMT&quot;</span><span class="p">],</span> 
                          <span class="s1">&#39;csamtpy&#39;</span><span class="p">,</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="n">file_stn</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span> <span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf8&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span> <span class="p">:</span> 
        <span class="n">data</span><span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">stn_check_split_type</span><span class="p">(</span><span class="n">data_lines</span><span class="o">=</span><span class="n">data</span><span class="p">))</span>
    
    <span class="c1"># ch=np.array([1,2,3])</span>
    <span class="c1"># print(&#39;&#39;.join([str(1),str(2)]))</span>
    
    <span class="c1"># ch= ch.astype(&#39;&lt;U12&#39;)</span>
    <span class="c1"># print(ch.dtype)</span>
    
    

    
    
    
    
    
    
    

    
        
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">pyCSAMT v1.0.01 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2021, Kouadio K. Laurent.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.4.0.
    </div>
  </body>
</html>