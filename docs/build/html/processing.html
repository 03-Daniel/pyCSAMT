
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Package Processing &#8212; pyCSAMT v1.0.01 documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Package Modeling" href="modeling.html" />
    <link rel="prev" title="Package CSAMT" href="csamt.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="modeling.html" title="Package Modeling"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="csamt.html" title="Package CSAMT"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">pyCSAMT v1.0.01 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="package-processing">
<h1>Package Processing<a class="headerlink" href="#package-processing" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-csamtpy.ff.processing.callffunc">
<span id="module-dispatcher"></span><h2><strong>Module Dispatcher</strong><a class="headerlink" href="#module-csamtpy.ff.processing.callffunc" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>This file is part of pyCSAMT.</p>
<p>pyCSAMT is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.</p>
<p>pyCSAMT is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.</p>
<p>You should have received a copy of the GNU Lesser General Public License
along with pyCSAMT.  If not, see &lt;<a class="reference external" href="https://www.gnu.org/licenses/">https://www.gnu.org/licenses/</a>&gt;.</p>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p>.Typical call files functions
.call files from Avg, AGSO, else…</p>
</div></blockquote>
<p>Created on Thu Nov 26 20:55:39 2020</p>
<p>&#64;author: &#64;Daniel03</p>
<dl class="function">
<dt id="csamtpy.ff.processing.callffunc.agso_data">
<code class="sig-prename descclassname">csamtpy.ff.processing.callffunc.</code><code class="sig-name descname">agso_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/csamtpy/ff/processing/callffunc.html#agso_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csamtpy.ff.processing.callffunc.agso_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Geological data codes processing
:: will later deprecated</p>
</dd></dl>

<dl class="function">
<dt id="csamtpy.ff.processing.callffunc.dipole_center_position">
<code class="sig-prename descclassname">csamtpy.ff.processing.callffunc.</code><code class="sig-name descname">dipole_center_position</code><span class="sig-paren">(</span><em class="sig-param">dipole_position=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/csamtpy/ff/processing/callffunc.html#dipole_center_position"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csamtpy.ff.processing.callffunc.dipole_center_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Generaly positions are taken at each electrode of dipole to that to easy correct data  for ploting and for
noise correction , we adjust coordinate by taking the center position that means ,
the number of points will be substract to one.
params : dipole_postion : array_like (ndarray,1): postion array at each electrodes.</p>
<p>return : array_centered_value .</p>
</dd></dl>

<dl class="function">
<dt id="csamtpy.ff.processing.callffunc.get_array_from_reffreq">
<code class="sig-prename descclassname">csamtpy.ff.processing.callffunc.</code><code class="sig-name descname">get_array_from_reffreq</code><span class="sig-paren">(</span><em class="sig-param">array_loc</em>, <em class="sig-param">freq_array</em>, <em class="sig-param">reffreq_value</em>, <em class="sig-param">stnNames=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/csamtpy/ff/processing/callffunc.html#get_array_from_reffreq"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csamtpy.ff.processing.callffunc.get_array_from_reffreq" title="Permalink to this definition">¶</a></dt>
<dd><p>Get array value at special frequency
params :</p>
<blockquote>
<div><p>array_loc : dict , dictionnary of stations :array_value :eg: S00:(ndarray,1) rho_values
freq_array : (ndarray,1) : frequency array for CSAMT survey
reffreq_value : int or float : the value of frequency user want to get the value
stnNames : list , list of stations names .</p>
</div></blockquote>
<dl class="simple">
<dt>return :</dt><dd><p>(ndarray,1) : an array of all station with reffreq_value .
eg : reffreq_value =1024. it return all value of the array at 1024Hz frequency .</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="csamtpy.ff.processing.callffunc.relocate_on_dict_arrays">
<code class="sig-prename descclassname">csamtpy.ff.processing.callffunc.</code><code class="sig-name descname">relocate_on_dict_arrays</code><span class="sig-paren">(</span><em class="sig-param">data_array</em>, <em class="sig-param">number_of_frequency</em>, <em class="sig-param">station_names=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/csamtpy/ff/processing/callffunc.html#relocate_on_dict_arrays"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csamtpy.ff.processing.callffunc.relocate_on_dict_arrays" title="Permalink to this definition">¶</a></dt>
<dd><p>Put data arrays on dictionnary where keys is each station and value the array of that station.
if station_names is None , program will create name of station. if station_names is given ,
function will sorted stations names . please make sure to provide correctly station according
the disposal you want .
params :</p>
<blockquote>
<div><p>number_of_frequency : array_like (ndarray,1) : array of frequency during survey
station_names: list of array_like : list of station .</p>
</div></blockquote>
<p>return : dict , key :stations , value : infos at data stations .</p>
</dd></dl>

<dl class="function">
<dt id="csamtpy.ff.processing.callffunc.set_stratum_on_dict">
<code class="sig-prename descclassname">csamtpy.ff.processing.callffunc.</code><code class="sig-name descname">set_stratum_on_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/csamtpy/ff/processing/callffunc.html#set_stratum_on_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csamtpy.ff.processing.callffunc.set_stratum_on_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Process to put geocodes_strata and geocodes_structures into dictionnaries
better way to go on metaclasses merely. Thus each keys of dictionary will be
its own object.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>strata_dict</strong> (<em>dict</em>) – Disctionnary of geostrata .</p></li>
<li><p><strong>structures_dict</strong> (<em>dict</em>) – Dictionnary of geostructures.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="csamtpy.ff.processing.callffunc.straighten_cac2CSfile">
<code class="sig-prename descclassname">csamtpy.ff.processing.callffunc.</code><code class="sig-name descname">straighten_cac2CSfile</code><span class="sig-paren">(</span><em class="sig-param">data_array</em>, <em class="sig-param">component_column_section=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/csamtpy/ff/processing/callffunc.html#straighten_cac2CSfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csamtpy.ff.processing.callffunc.straighten_cac2CSfile" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Sometimes head_sections of file _F2(CAC2CSAMT) provided is little
different colunms section name  according to different version .
it ‘s better to filter  and to check before returning the
correct informations we need.</p>
</div></blockquote>
<blockquote>
<div><dl>
<dt>data_array<span class="classifier">ndarray</span></dt><dd><blockquote>
<div><p>data from AVG astatic file</p>
</div></blockquote>
<dl class="simple">
<dt>component_column_section<span class="classifier">list</span></dt><dd><p>astactic file column comps provided .</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>returns :</dt><dd><dl class="simple">
<dt>array_we_need<span class="classifier">ndarray</span></dt><dd><p>same infos present in the plainty /1 Avg file</p>
</dd>
<dt>array_other_comp<span class="classifier">pd.Core.DataFrame</span></dt><dd><p>infos include through Astatic softwares . very usefull therefore
we keep it .</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="csamtpy.ff.processing.callffunc.truncated_data">
<code class="sig-prename descclassname">csamtpy.ff.processing.callffunc.</code><code class="sig-name descname">truncated_data</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">number_of_reccurence</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/csamtpy/ff/processing/callffunc.html#truncated_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csamtpy.ff.processing.callffunc.truncated_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to truncate all data according to number of frequency.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>list</em><em>, or </em><em>nd.array</em>) – data must be truncate.</p></li>
<li><p><strong>number_of_freq</strong> (<em>int</em>) – number of frequency imaged.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>loc_list</strong> – data truncated on list.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="csamtpy.ff.processing.callffunc.zstar_array_to_nan">
<code class="sig-prename descclassname">csamtpy.ff.processing.callffunc.</code><code class="sig-name descname">zstar_array_to_nan</code><span class="sig-paren">(</span><em class="sig-param">zstar_array</em>, <em class="sig-param">nan_value=nan</em>, <em class="sig-param">keep_str=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/csamtpy/ff/processing/callffunc.html#zstar_array_to_nan"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csamtpy.ff.processing.callffunc.zstar_array_to_nan" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>zstar_array</strong> (<em>ndarray</em>) – array contain unfloat converter value. the unconverter value can be a ‘*’</p></li>
<li><p><strong>nan_value</strong> (<em>float</em><em> or </em><em>np.nan type</em>) – the nan_value could be any value either int, float or str.  i The default is np.nan.</p></li>
<li><p><strong>keep_str</strong> (<em>bool</em><em>, </em><em>optional</em>) – keep the str item on your array. f keep_str is set to
false and the type nan_value is str , the program will force ‘<a href="#id7"><span class="problematic" id="id8">keep_str_</span></a>’  to True
to allow converter . The default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>zstrar_array converted .</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>TYPE ; ndarray</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-csamtpy.ff.processing.corr">
<span id="module-shifting"></span><h2><strong>Module Shifting</strong><a class="headerlink" href="#module-csamtpy.ff.processing.corr" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>This file is part of pyCSAMT.</p>
<p>pyCSAMT is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.</p>
<p>pyCSAMT is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.</p>
<p>You should have received a copy of the GNU Lesser General Public License
along with pyCSAMT.  If not, see &lt;<a class="reference external" href="https://www.gnu.org/licenses/">https://www.gnu.org/licenses/</a>&gt;.</p>
</div></blockquote>
<hr class="docutils" />
<p>Created on Sat Dec 12 13:55:47 2020</p>
<p>&#64;author: &#64;Daniel03</p>
<dl class="function">
<dt id="csamtpy.ff.processing.corr.interp_to_reference_freq">
<code class="sig-prename descclassname">csamtpy.ff.processing.corr.</code><code class="sig-name descname">interp_to_reference_freq</code><span class="sig-paren">(</span><em class="sig-param">freq_array</em>, <em class="sig-param">rho_array</em>, <em class="sig-param">reference_freq</em>, <em class="sig-param">plot=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/csamtpy/ff/processing/corr.html#interp_to_reference_freq"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csamtpy.ff.processing.corr.interp_to_reference_freq" title="Permalink to this definition">¶</a></dt>
<dd><p>interpolate frequencies to the reference frequencies.
Params: freq_array :  ndarray : frequency array</p>
<blockquote>
<div><p>reference_freq : float
Returns
——-</p>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="csamtpy.ff.processing.corr.shifting">
<em class="property">class </em><code class="sig-prename descclassname">csamtpy.ff.processing.corr.</code><code class="sig-name descname">shifting</code><span class="sig-paren">(</span><em class="sig-param">data_fn=None</em>, <em class="sig-param">freq_array=None</em>, <em class="sig-param">res_array=None</em>, <em class="sig-param">phase_array=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/csamtpy/ff/processing/corr.html#shifting"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csamtpy.ff.processing.corr.shifting" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>processing class<span class="classifier">shifting processing workflow</span></dt><dd><dl class="simple">
<dt>coorection  class deal with  AVG Zonge station file “<a href="#id1"><span class="problematic" id="id2">*</span></a>.stn” or SEG-EDI file. :</dt><dd><dl class="simple">
<dt>argument :</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>data_fn<span class="classifier">str</span></dt><dd><p>path to Zonge <a href="#id3"><span class="problematic" id="id4">*</span></a>AVG file of SEG-EDI file</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>res_array<span class="classifier">array_like (ndarray,1)</span></dt><dd><p>apparent resistivities uncorrected data</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>freq_array<span class="classifier">array_like (ndarray,1)</span></dt><dd><p>frequency array during survey</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>phase_array<span class="classifier">array_like(ndarray,1)</span></dt><dd><p>phase array during survey</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>More arrtibute will populate :</p>
<p>Methods                    Description
========================= =================================================
TMA                         Trimming Moving Average computation.
FLMA                        Fixed Length Dipole Moving average computation.
AMA                         Adaptative Moving average . see Biblio.</p>
</dd></dl>

</div>
<div class="section" id="module-csamtpy.ff.processing.zcalculator">
<span id="module-zcalculator"></span><h2><strong>Module ZCalculator</strong><a class="headerlink" href="#module-csamtpy.ff.processing.zcalculator" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>This file is part of pyCSAMT.</p>
<p>pyCSAMT is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.</p>
<p>pyCSAMT is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.</p>
<p>You should have received a copy of the GNU Lesser General Public License
along with pyCSAMT.  If not, see &lt;<a class="reference external" href="https://www.gnu.org/licenses/">https://www.gnu.org/licenses/</a>&gt;.</p>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p>.helper functions . special calculator</p>
</div></blockquote>
<p>Created on Thu Dec  3 16:44:29 2020</p>
<p>&#64;author: &#64;Daniel03</p>
<dl class="function">
<dt id="csamtpy.ff.processing.zcalculator.comp_phz">
<code class="sig-prename descclassname">csamtpy.ff.processing.zcalculator.</code><code class="sig-name descname">comp_phz</code><span class="sig-paren">(</span><em class="sig-param">comphz_array</em>, <em class="sig-param">units='deg'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/csamtpy/ff/processing/zcalculator.html#comp_phz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csamtpy.ff.processing.zcalculator.comp_phz" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>PHZc are from each data block :</dt><dd><p>units : rad</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>comphz_array</strong> (<em>float</em>) – average parameters phase for data blocs.</p></li>
<li><p><strong>e.g::</strong> – <div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span>  <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">&quot;pyCSAMT&quot;</span><span class="p">],</span>
<span class="go">              &#39;csamtpy&#39;,&#39;data&#39;, &#39;K1.AVG&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">csamtpy.core</span> <span class="kn">import</span> <span class="n">avg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phs_obj</span> <span class="o">=</span><span class="n">avg</span><span class="o">.</span><span class="n">Phase</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phs_obj</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;S00&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">value</span><span class="p">,</span> <span class="n">ss</span> <span class="o">=</span> <span class="n">comp_phz</span><span class="p">(</span><span class="n">comphz_array</span><span class="o">=</span><span class="n">phs_obj</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;S00&#39;</span><span class="p">],</span> <span class="n">to_degree</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">... </span><span class="nb">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
</p></li>
<li><p><strong>return</strong> – component phase averaged.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="csamtpy.ff.processing.zcalculator.comp_rho">
<code class="sig-prename descclassname">csamtpy.ff.processing.zcalculator.</code><code class="sig-name descname">comp_rho</code><span class="sig-paren">(</span><em class="sig-param">mag_E_field</em>, <em class="sig-param">mag_H_field</em>, <em class="sig-param">freq_array</em>, <em class="sig-param">A_spacing</em>, <em class="sig-param">Txcurr</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/csamtpy/ff/processing/zcalculator.html#comp_rho"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csamtpy.ff.processing.zcalculator.comp_rho" title="Permalink to this definition">¶</a></dt>
<dd><p>function to compute component average
unition : ohm.m
:param mag_E_field: magnitude of E-filed : averaged
:type mag_E_field: np.ndarray(ndarray,1)
:param mag_H_field: magnitude of H-Field : averaged
:type mag_H_field: np.ndarray(ndarray,1)
:param freq_array: frequency of station fiel
:type freq_array: np.ndarray(ndarray,1)
:param A_spacing: step_between station
:type A_spacing: np.float
:param Txcurr: distance of coil m, dipole
:type Txcurr: np.float</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>comp_rho</strong> – component averaged rho.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="csamtpy.ff.processing.zcalculator.compute_FLMA">
<code class="sig-prename descclassname">csamtpy.ff.processing.zcalculator.</code><code class="sig-name descname">compute_FLMA</code><span class="sig-paren">(</span><em class="sig-param">z_array=None</em>, <em class="sig-param">weighted_window=None</em>, <em class="sig-param">dipole_length=None</em>, <em class="sig-param">number_of_points=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/csamtpy/ff/processing/zcalculator.html#compute_FLMA"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csamtpy.ff.processing.zcalculator.compute_FLMA" title="Permalink to this definition">¶</a></dt>
<dd><p>!!! We will add this filter later !
<strong>*future plan *</strong></p>
</dd></dl>

<dl class="function">
<dt id="csamtpy.ff.processing.zcalculator.compute_TMA">
<code class="sig-prename descclassname">csamtpy.ff.processing.zcalculator.</code><code class="sig-name descname">compute_TMA</code><span class="sig-paren">(</span><em class="sig-param">data_array=None</em>, <em class="sig-param">number_of_TMApoints=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/csamtpy/ff/processing/zcalculator.html#compute_TMA"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csamtpy.ff.processing.zcalculator.compute_TMA" title="Permalink to this definition">¶</a></dt>
<dd><p>function to compute a trimmed-moving-average filter to estimate average apparent resistivities.
params : data_array : array_like(ndarray,1) : content of value to be trimmed</p>
<blockquote>
<div><p>number_of_TMA points : int , number of filter points .</p>
</div></blockquote>
<dl class="simple">
<dt>return<span class="classifier">array_like (ndarray, 1)</span></dt><dd><p>value corrected with TMA</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="csamtpy.ff.processing.zcalculator.compute_components_Z_Phz">
<code class="sig-prename descclassname">csamtpy.ff.processing.zcalculator.</code><code class="sig-name descname">compute_components_Z_Phz</code><span class="sig-paren">(</span><em class="sig-param">magn_E_field</em>, <em class="sig-param">magn_H_field</em>, <em class="sig-param">phz_E_field</em>, <em class="sig-param">phz_H_field</em>, <em class="sig-param">freq_value</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/csamtpy/ff/processing/zcalculator.html#compute_components_Z_Phz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csamtpy.ff.processing.zcalculator.compute_components_Z_Phz" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to compute all components  derived from Impedance Z.
user can  enter specifik units in kwargs arguments . program will compute and converts value
automatically.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>magn_E_field</strong> (<em>np.ndarray</em>) – <a href="#id9"><span class="problematic" id="id10">E_</span></a>.field magnitude (ndarray,1) : microV/KM*A</p></li>
<li><p><strong>magn_H_field</strong> (<em>np.ndarray</em>) – <a href="#id11"><span class="problematic" id="id12">H_</span></a>.field magnitude (ndarray,1): mGammas/A or picoTesla/A</p></li>
<li><p><strong>phz_E_field</strong> (<em>np.ndarray</em>) – E_field phase (ndarray, 1): mrad</p></li>
<li><p><strong>phz_H_field</strong> (<em>np.ndarray</em>) – H_field phase (ndarray,1) : mrad.</p></li>
<li><p><strong>freq_value</strong> (<em>np.ndarray</em>) – Frequency at which data was measured(ndarray,1): Hz</p></li>
<li><p><strong>**kwargs</strong> (<em>str</em>) – units conversion.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>CSex :pyCSAMT exception</strong><strong> ,</strong> – Exceptions if units entered by the user doesnt match or are messy.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul>
<li><p><strong>rho</strong> (<em>ndarray</em>) – Cagnard resistivity calculation. ohm.m</p></li>
<li><p><strong>phz</strong> (<em>ndarray</em>) – Impedance phase value.</p></li>
<li><p><strong>Zij</strong> (<em>ndarray</em>) – Impedance Tensor value.</p></li>
<li><p><strong>Zreal</strong> (<em>ndarray</em>) – Value of Real part of impedance Tensor.</p></li>
<li><p><strong>Zimag</strong> (<em>TYPE</em>) – Value of Imaginary part of impedance Tensor.</p></li>
<li><p><strong>Zreal_imag</strong> (<em>ndarray , complex</em>) – Complex value of impedance Tensor.</p></li>
<li><p><em>eg ::</em> – &gt;&gt;&gt; from csamtpy.core import avg
&gt;&gt;&gt; path =  os.path.join(os.environ[“pyCSAMT”],</p>
<blockquote>
<div><p>data’, ‘avg’, ‘K1.AVG’)</p>
</div></blockquote>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">emag_ob</span> <span class="o">=</span> <span class="n">avg</span><span class="o">.</span><span class="n">Emag</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hmag_obj</span> <span class="o">=</span> <span class="n">avg</span><span class="o">.</span><span class="n">Hmag</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ephz_obj</span> <span class="o">=</span> <span class="n">avg</span><span class="o">.</span><span class="n">Ephz</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hphz_obj</span> <span class="o">=</span> <span class="n">avg</span><span class="o">.</span><span class="n">Hphz</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq_obj</span> <span class="o">=</span><span class="n">avg</span><span class="o">.</span><span class="n">Frequency</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">station_name</span> <span class="o">=</span><span class="s1">&#39;S00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span><span class="p">,</span> <span class="n">phz</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">real</span><span class="p">,</span> <span class="n">imag</span><span class="p">,</span> <span class="n">comp</span> <span class="o">=</span><span class="n">compute_components_Z_Phz</span><span class="p">(</span>
<span class="go">    magn_E_field=emag_ob.loc[station_name],</span>
<span class="go">                            magn_H_field =hmag_obj.loc[station_name],</span>
<span class="go">                            phz_E_field =ephz_obj.loc[station_name],</span>
<span class="go">                            phz_H_field=hphz_obj.loc[station_name],</span>
<span class="go">                            freq_value=freq_obj.loc[station_name])</span>
<span class="gp">... </span><span class="n">rho</span>
</pre></div>
</div>
</li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="csamtpy.ff.processing.zcalculator.compute_sigmas_e_h_and_sigma_rho">
<code class="sig-prename descclassname">csamtpy.ff.processing.zcalculator.</code><code class="sig-name descname">compute_sigmas_e_h_and_sigma_rho</code><span class="sig-paren">(</span><em class="sig-param">pc_emag</em>, <em class="sig-param">pc_hmag</em>, <em class="sig-param">pc_app_rho</em>, <em class="sig-param">app_rho</em>, <em class="sig-param">emag</em>, <em class="sig-param">hmag</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/csamtpy/ff/processing/zcalculator.html#compute_sigmas_e_h_and_sigma_rho"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csamtpy.ff.processing.zcalculator.compute_sigmas_e_h_and_sigma_rho" title="Permalink to this definition">¶</a></dt>
<dd><p>function to compute Standard Deviation for E-field (sigma_e),
Standard Deviation for H-Field (sigma_h) ,
&amp; Standard Deviation for Component RHO (sigma_rho)</p>
<dl>
<dt>params :</dt><dd><dl class="simple">
<dt>pc_emag<span class="classifier">float  :Statistical variation of magnitude values from averaged data blocks.</span></dt><dd><p>Standard Deviation/Average Emag (%)</p>
</dd>
<dt>pc_hmag :float<span class="classifier">Statistical variation of magnitude values from averaged data blocks.</span></dt><dd><p>Standard Deviation / Average Hmag (%)</p>
</dd>
<dt>pc_app_rho: float<span class="classifier">Statistical variation of magnitude values from averaged data blocks.</span></dt><dd><p>Standard Deviation / Average Rho (%)</p>
</dd>
</dl>
<p>app_rho :float : resistivity calculated from averaged component (ohm.m)
Emag : float : average E - field magnitude(microVolt/Km <a href="#id5"><span class="problematic" id="id6">*</span></a>amp )
Hmag : float : average H - field magnitude(pTesta/amp) or (milliGammas/Amp)</p>
</dd>
<dt>return :</dt><dd><p>sigma_rho : float :srhoC (Standard Deviation for Component RHO)
c_var_Rho :float : C-varrhoC(  Coefficient of Variation for Component RHO)</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="csamtpy.ff.processing.zcalculator.find_reference_frequency">
<code class="sig-prename descclassname">csamtpy.ff.processing.zcalculator.</code><code class="sig-name descname">find_reference_frequency</code><span class="sig-paren">(</span><em class="sig-param">freq_array=None</em>, <em class="sig-param">reffreq_value=None</em>, <em class="sig-param">sharp=False</em>, <em class="sig-param">etching=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/csamtpy/ff/processing/zcalculator.html#find_reference_frequency"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csamtpy.ff.processing.zcalculator.find_reference_frequency" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to find and interpolate reference value if it is not present on the frequency range.
params :</p>
<blockquote>
<div><p>freq_array : (ndarray,1), array_like frequency range
reffreq_value : float or int : reference frequency value
sharp : bool  , if set to True , it forces the program to find mainly a value closest inside the</p>
<blockquote>
<div><p>frequency range.</p>
</div></blockquote>
<p>etching :bool , if set to True , it will print in your stdout.</p>
</div></blockquote>
<dl class="simple">
<dt>return<span class="classifier">float</span></dt><dd><p>reference frequency .</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="csamtpy.ff.processing.zcalculator.get_data_from_reference_frequency">
<code class="sig-prename descclassname">csamtpy.ff.processing.zcalculator.</code><code class="sig-name descname">get_data_from_reference_frequency</code><span class="sig-paren">(</span><em class="sig-param">array_loc</em>, <em class="sig-param">freq_array</em>, <em class="sig-param">reffreq_value</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/csamtpy/ff/processing/zcalculator.html#get_data_from_reference_frequency"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csamtpy.ff.processing.zcalculator.get_data_from_reference_frequency" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to get reference frequency  without call especially stations array. The function is profitable but
. It’s less expensive However if something wrong happened by using the first step to get a reference
array , it will try the traditionnally function to get it. If none value is found , an Error will
occurs.</p>
<dl>
<dt>params :</dt><dd><p>array_loc : dict :  assume to be a dictionnary of stations_data_values.
freq_array : array_like (ndarray,1) ; frequency array
reffreq_value : float or int : reffrence value  If the reference value is not in frequency array ,</p>
<blockquote>
<div><p>function will force to interpolate value amd find the correlative array.</p>
</div></blockquote>
</dd>
<dt>return array_like</dt><dd><p>an array of reference value at specific index .</p>
</dd>
<dt>e:g::</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">get_data_from_reference_frequency</span><span class="p">(</span><span class="n">array_loc</span><span class="o">=</span><span class="n">rho</span><span class="p">,</span> <span class="n">freq_array</span><span class="o">=</span><span class="n">freq_array</span><span class="p">,</span> <span class="n">reffreq_value</span><span class="o">=</span><span class="mf">1023.</span><span class="p">)</span>
<span class="gp">... </span><span class="o">---&gt;</span> <span class="n">Input</span> <span class="n">reference</span> <span class="n">frequency</span> <span class="n">has</span> <span class="n">been</span> <span class="n">interpolated</span> <span class="n">to</span> <span class="o">&lt;</span> <span class="mf">1024.0</span> <span class="o">&gt;</span> <span class="n">Hz</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="csamtpy.ff.processing.zcalculator.get_reffreq_index">
<code class="sig-prename descclassname">csamtpy.ff.processing.zcalculator.</code><code class="sig-name descname">get_reffreq_index</code><span class="sig-paren">(</span><em class="sig-param">freq_array</em>, <em class="sig-param">reffreq_value</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/csamtpy/ff/processing/zcalculator.html#get_reffreq_index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csamtpy.ff.processing.zcalculator.get_reffreq_index" title="Permalink to this definition">¶</a></dt>
<dd><p>get the index of reference index. From this index ,All array will filter data at this reffreq
value .
param : freq_array : (ndarray, 1): array of frequency</p>
<blockquote>
<div><p>reffreq_value : float, int : value of frequence</p>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="csamtpy.ff.processing.zcalculator.hanning">
<code class="sig-prename descclassname">csamtpy.ff.processing.zcalculator.</code><code class="sig-name descname">hanning</code><span class="sig-paren">(</span><em class="sig-param">dipole_length=50.0</em>, <em class="sig-param">number_of_points=7</em>, <em class="sig-param">large_band=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/csamtpy/ff/processing/zcalculator.html#hanning"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csamtpy.ff.processing.zcalculator.hanning" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>function to compute hanning window<span class="classifier">see biblo :</span></dt><dd><p>Torres-Verdin and Bostick, 1992, Principles of spatial surface electric field filtering in
magnetotellurics: electromagnetic array profiling (EMAP), Geophysics, v57, p603-622.</p>
</dd>
<dt>params :</dt><dd><p>dipole_length : float : the length of dipole , xk is centered between dipole
number_of_points : int : number of filter points</p>
</dd>
<dt>return  :</dt><dd><p>windowed hanning</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="csamtpy.ff.processing.zcalculator.hanning_x">
<code class="sig-prename descclassname">csamtpy.ff.processing.zcalculator.</code><code class="sig-name descname">hanning_x</code><span class="sig-paren">(</span><em class="sig-param">x_point_value</em>, <em class="sig-param">dipole_length=50.0</em>, <em class="sig-param">number_of_points=7</em>, <em class="sig-param">bandwidth_values=False</em>, <em class="sig-param">on_half=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/csamtpy/ff/processing/zcalculator.html#hanning_x"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csamtpy.ff.processing.zcalculator.hanning_x" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to compute point on window width .  Use discrete computing . Function show the value
at center point of window assume that the point is center locate on the window width .
It intergrates  value between dipole length. User can use see_extraband to see the values
on the total bandwith. If half is False the value of greater than center point will be
computed and not be 0 as the normal definition of Hanning window filter.</p>
<dl>
<dt>params :</dt><dd><p>x_point_value : float : value  to intergrate.
dipole_length : float : length of dipole on survey
number_of_point : int : survey point or number point to apply.
bandwidth_values:bool : see all value on the bandwith , value greater than x_center</p>
<blockquote>
<div><p>point will be computed .</p>
</div></blockquote>
<p>on-half : bool : value on the bandwith; value greater that x_center point = 0.</p>
</dd>
<dt>return :</dt><dd><dl class="simple">
<dt>hannx<span class="classifier">float</span><span class="classifier">integrated X_point_value or</span></dt><dd><p>array_like (ndarray,1) : array of window bandwidth .</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="csamtpy.ff.processing.zcalculator.hanning_xk">
<code class="sig-prename descclassname">csamtpy.ff.processing.zcalculator.</code><code class="sig-name descname">hanning_xk</code><span class="sig-paren">(</span><em class="sig-param">dipole_length=50.0</em>, <em class="sig-param">number_of_points=7</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/csamtpy/ff/processing/zcalculator.html#hanning_xk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csamtpy.ff.processing.zcalculator.hanning_xk" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>compute _hanning window on a wtdth of number of point :</dt><dd><p>integrate value on all the window_bandwidth discrete and continue. if value is greater than Hald of the width
value == 0 .</p>
</dd>
<dt>params<span class="classifier">dipole_length</span><span class="classifier">float</span><span class="classifier">length of dipole</span></dt><dd><p>number_of_points : int : value of points or survey stations .</p>
</dd>
<dt>return :</dt><dd><ol class="arabic simple">
<li><p>han_xk : array_like : continue value on half bandwidth x0– xk (center point)</p></li>
<li><p>windowed hanning : array_like (ndarray,1) : discrete _value :SUM(han(x0, xk))</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="csamtpy.ff.processing.zcalculator.interpolate_sets">
<code class="sig-prename descclassname">csamtpy.ff.processing.zcalculator.</code><code class="sig-name descname">interpolate_sets</code><span class="sig-paren">(</span><em class="sig-param">array_to</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">array_size=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/csamtpy/ff/processing/zcalculator.html#interpolate_sets"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csamtpy.ff.processing.zcalculator.interpolate_sets" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to interpolate data contain of multiple nan values.</p>
</dd></dl>

<dl class="function">
<dt id="csamtpy.ff.processing.zcalculator.mag_avg">
<code class="sig-prename descclassname">csamtpy.ff.processing.zcalculator.</code><code class="sig-name descname">mag_avg</code><span class="sig-paren">(</span><em class="sig-param">mag_array</em>, <em class="sig-param">A_spacing</em>, <em class="sig-param">Txcur</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/csamtpy/ff/processing/zcalculator.html#mag_avg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csamtpy.ff.processing.zcalculator.mag_avg" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>(RAW, E-, or H-field magnitude values)for each frequency</dt><dd><p>units : mV/Km*A</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mag_array</strong> (<em>np.array</em><em> (</em><em>ndarray</em><em>, </em><em>1</em><em>)</em>) – magnnitude value for each data block</p></li>
<li><p><strong>a_spacing</strong> (<em>float</em>) – dipole lengh</p></li>
<li><p><strong>txcur</strong> (<em>TYPE</em>) – curv coil.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>mag_avg</strong> (<em>np.ndarray</em>) – averaged data of magnitude data Block</p></li>
<li><p><strong>En</strong> (<em>np.ndarray</em>)</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="csamtpy.ff.processing.zcalculator.param_phz">
<code class="sig-prename descclassname">csamtpy.ff.processing.zcalculator.</code><code class="sig-name descname">param_phz</code><span class="sig-paren">(</span><em class="sig-param">pphz_array</em>, <em class="sig-param">to_degree=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/csamtpy/ff/processing/zcalculator.html#param_phz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csamtpy.ff.processing.zcalculator.param_phz" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>PHZn are from each data block :</dt><dd><p>units : mrad</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>pphz_array</strong> (<em>float</em>) – average parameters phase for data blocs.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="csamtpy.ff.processing.zcalculator.param_rho">
<code class="sig-prename descclassname">csamtpy.ff.processing.zcalculator.</code><code class="sig-name descname">param_rho</code><span class="sig-paren">(</span><em class="sig-param">rho_array</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/csamtpy/ff/processing/zcalculator.html#param_rho"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csamtpy.ff.processing.zcalculator.param_rho" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Parameter Average RHO (RHOp):</dt><dd><p>RHO are from each data block
unit : ohm.m</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="csamtpy.ff.processing.zcalculator.perforce_reference_freq">
<code class="sig-prename descclassname">csamtpy.ff.processing.zcalculator.</code><code class="sig-name descname">perforce_reference_freq</code><span class="sig-paren">(</span><em class="sig-param">dataset</em>, <em class="sig-param">frequency_array=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/csamtpy/ff/processing/zcalculator.html#perforce_reference_freq"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csamtpy.ff.processing.zcalculator.perforce_reference_freq" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to get automatically the reference frequency. If user doesnt provide the value ,
function will find automatically value .
params : data , array_like (array of avg DATA) ndim&gt;1</p>
<blockquote>
<div><p>frequency_array : array_like (ndarray,1) :array of frequency</p>
</div></blockquote>
<dl class="simple">
<dt>return :</dt><dd><p>reffreq_value : float : reference frequency value
uncover_index :int : index of reference value on frequency array
nan_ration : float : the ratio or the prevalence of nan in the data_set</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="csamtpy.ff.processing.zcalculator.phz_avg">
<code class="sig-prename descclassname">csamtpy.ff.processing.zcalculator.</code><code class="sig-name descname">phz_avg</code><span class="sig-paren">(</span><em class="sig-param">phz_array</em>, <em class="sig-param">to_degree</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/csamtpy/ff/processing/zcalculator.html#phz_avg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csamtpy.ff.processing.zcalculator.phz_avg" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>E-, H-field, or Impedance Phase values</dt><dd><p>units : mrad</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="csamtpy.ff.processing.zcalculator.rhophi2z">
<code class="sig-prename descclassname">csamtpy.ff.processing.zcalculator.</code><code class="sig-name descname">rhophi2z</code><span class="sig-paren">(</span><em class="sig-param">phase</em>, <em class="sig-param">freq</em>, <em class="sig-param">resistivity=None</em>, <em class="sig-param">z_array=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/csamtpy/ff/processing/zcalculator.html#rhophi2z"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csamtpy.ff.processing.zcalculator.rhophi2z" title="Permalink to this definition">¶</a></dt>
<dd><p>function to compute z , real part and imag part .</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>phase</strong> (<em>ndarray : phase angles array in radians</em>) – </p></li>
<li><p><strong>freq</strong> (<em>ndaray : frequencies array in Hz</em>) – </p></li>
<li><p><strong>resistivity</strong> (<em>ndarray : rho array in ohm.m</em>) – </p></li>
<li><p><strong>z_array</strong> (<em>ndarray : impedance z array in V/m</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>zz</strong> – absolute value of zz, real part of complex number zz and imaginary part of zz</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>z_real : z_imag : ndarrays</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="csamtpy.ff.processing.zcalculator.wbetaX">
<code class="sig-prename descclassname">csamtpy.ff.processing.zcalculator.</code><code class="sig-name descname">wbetaX</code><span class="sig-paren">(</span><em class="sig-param">Xpos</em>, <em class="sig-param">dipole_length=50.0</em>, <em class="sig-param">number_of_points=7</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/csamtpy/ff/processing/zcalculator.html#wbetaX"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csamtpy.ff.processing.zcalculator.wbetaX" title="Permalink to this definition">¶</a></dt>
<dd><p>weight Beta is  computed following the paper of :</p>
<p>Torres-verdfn, C., and F. X. Bostick, 1992, Principles of spatial surface electric field
filtering in magnetotellurics : Electromagnetic array profiling ( EMAP ): Geophysics, 57(4), 25–34.</p>
<blockquote>
<div><p>Xpos : str : reference position on the field
dipole_length : float : length of dipole measurement
number_of_points : int : point to stand filters , window width</p>
<p>will improbe later !</p>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="csamtpy.ff.processing.zcalculator.weight_beta">
<code class="sig-prename descclassname">csamtpy.ff.processing.zcalculator.</code><code class="sig-name descname">weight_beta</code><span class="sig-paren">(</span><em class="sig-param">dipole_length=50.0</em>, <em class="sig-param">number_of_points=7</em>, <em class="sig-param">window_width=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/csamtpy/ff/processing/zcalculator.html#weight_beta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csamtpy.ff.processing.zcalculator.weight_beta" title="Permalink to this definition">¶</a></dt>
<dd><p>WeightBeta function is  weight Hanning window . if window width is not provide  , function
will compute the width of window.</p>
<p>see biblio
Torres-Verdin and Bostick, 1992, Principles of spatial surface electric field filtering in</p>
<blockquote>
<div><dl class="simple">
<dt>magnetotellurics: electromagnetic array profiling (EMAP), Geophysics, v57, p603-622.</dt><dd><p>SUM(Betaj (j=1..M)=1 .</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>params :</dt><dd><p>dipole_length : float : length of dipole in meter (m)
number_of_points : int : number of station points to filter
window_width : float : the width of window filter</p>
</dd>
<dt>return :</dt><dd><p>beta_array : array_like , (ndarray, 1) at each station .</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="csamtpy.ff.processing.zcalculator.z_error2r_phi_error">
<code class="sig-prename descclassname">csamtpy.ff.processing.zcalculator.</code><code class="sig-name descname">z_error2r_phi_error</code><span class="sig-paren">(</span><em class="sig-param">z_real</em>, <em class="sig-param">z_imag</em>, <em class="sig-param">error</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/csamtpy/ff/processing/zcalculator.html#z_error2r_phi_error"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#csamtpy.ff.processing.zcalculator.z_error2r_phi_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Error estimation from rectangular to polar coordinates.</p>
<p>By standard error propagation, relative error in resistivity is
2*relative error in z amplitude.</p>
<p>Uncertainty in phase (in degrees) is computed by defining a circle around
the z vector in the complex plane. The uncertainty is the absolute angle
between the vector to (x,y) and the vector between the origin and the
tangent to the circle.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>tuple containing relative error in resistivity, absolute error in phase</p>
</dd>
<dt class="field-even">Inputs</dt>
<dd class="field-even"><p>z_real = real component of z (real number or array)
z_imag = imaginary component of z (real number or array)
error = absolute error in z (real number or array)</p>
</dd>
</dl>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Package Processing</a><ul>
<li><a class="reference internal" href="#module-csamtpy.ff.processing.callffunc"><strong>Module Dispatcher</strong></a></li>
<li><a class="reference internal" href="#module-csamtpy.ff.processing.corr"><strong>Module Shifting</strong></a></li>
<li><a class="reference internal" href="#module-csamtpy.ff.processing.zcalculator"><strong>Module ZCalculator</strong></a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="csamt.html"
                        title="previous chapter">Package CSAMT</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="modeling.html"
                        title="next chapter">Package Modeling</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/processing.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="modeling.html" title="Package Modeling"
             >next</a> |</li>
        <li class="right" >
          <a href="csamt.html" title="Package CSAMT"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">pyCSAMT v1.0.01 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2021, Kouadio K. Laurent.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.4.0.
    </div>
  </body>
</html>